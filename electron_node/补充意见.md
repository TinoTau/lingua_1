结合你这两份文档，现在的情况其实已经很清楚了：
**问题不是“怎么修补现状”，而是“既然没有兼容需求，就应该怎么直接砍到只剩一套简单逻辑”。**

我下面给的是在你现有重构方案基础上的「补充意见」，全部围绕四个关键词：

> **只保留一套架构 / 不留兼容层 / 流程一条线 / 错了就直接爆出来**

---

## 1. 决策层面的补充：不要再想“渐进迁移”，直接做“硬切”

你在决策文档里还是保留了方案 1（兼容层）、方案 3（渐进迁移）作为备选。

在你现在的约束下：

* 没有线上用户
* 不考虑兼容
* 你已经厌倦反复打补丁、找不着问题

我的建议是非常明确的：

> **把整个项目当成“新项目起步”，只保留方案 2 的精神，但再往“更狠一点”去收缩：
> 不是“重构旧架构”，而是“用新架构替换旧架构，然后删代码”。**

具体含义：

1. 不要再维护 `legacyServiceRegistryManager` 之类兼容层，直接删除。
2. 不要再提“旧 PythonServiceManager / RustServiceManager 重构”，而是直接**新建一个薄的 ProcessServiceManager，专门服务新架构**。
3. InferenceService 直接改构造函数，要求传入 `ServiceRegistry` 和一个统一的 `ProcessServiceManager`，旧接口全部丢弃。

这样做的好处是：
**你以后排查问题时，永远只有一个调用链，从 UI → IPC → Supervisor → Registry → spawn，没有“这里绕一下旧 manager，再过一层兼容”的情况。**

---

## 2. Manager 层的补充意见：直接合并成一个「进程启动器」

当前决策文档里，还是保留了两个 manager：
`PythonServiceManager` 和 `RustServiceManager`，只是计划把硬编码配置改成从 ServiceRegistry 读。

在你“只求简洁”的前提下，我会建议：

> **合并成一个 ProcessServiceManager（或者干脆叫 ServiceProcessRunner），不再区分 Python / Rust。**

理由：

1. 对 Node 来说，启动服务本质就是：

   * 找到一个 `command`
   * 找到一堆 `args`
   * 在 `cwd` 下 `spawn`
     跟“对面是 Python 还是 Rust”没有本质区别。
2. 区分 Python/Rust 的意义只剩下两个：

   * `service.json` 写法略有不同（比如 env、端口）
   * 日志/调试习惯不同
     这些完全可以放在 `service.json` 里描述，而不是代码分两套类。
3. 你更关心的是：**哪一个服务没起来，为什么没起来**，而不是“它是不是 Python”。

建议你做的事情：

* 新建一个非常薄的类：

  ```ts
  class ServiceProcessRunner {
    constructor(private registry: ServiceRegistry) {}

    start(serviceId: string) {
      const entry = this.registry.get(serviceId);
      if (!entry) throw new Error(`Service not found: ${serviceId}`);

      const { command, args, cwd } = entry.def.exec;
      // spawn(command, args, { cwd, env: entry.def.exec.env ?? process.env })
      // 更新 entry.runtime.status / pid / lastError
    }

    stop(serviceId: string) {
      // 查 pid，kill
    }
  }
  ```

* 原来的 `PythonServiceManager` / `RustServiceManager` 直接删代码，用一个 `ServiceProcessRunner` 替代即可。

你以后看到启动失败，只需要看两块：

1. `service.json` 里 exec 写错没；
2. `ServiceProcessRunner` 一段代码里 spawn 的 error 和 exit code。

链路非常短，问题好找。

---

## 3. InferenceService 的补充：把“找服务”和“启动服务”从它身上拿掉

目前 InferenceService 强依赖旧的 `serviceRegistryManager`，你已经用 `legacyServiceRegistryManager` 这类兼容对象硬接了一下，这本身就是你不想要的“保险层”。

在「只追求简单」的前提下，我会建议你给 InferenceService 做两条手术刀：

1. **InferenceService 只关心：

   * 有哪些可用能力（NMT、ASR、TTS、语义修复等）
   * 如何通过 HTTP/gRPC 调用这些能力**

2. 不要再在 InferenceService 里参与：

   * 服务是否启动
   * 服务跑在哪个端口
   * 服务是 Python 还是 Rust
   * endpoint 从哪里来

这些都交给“外面”决定，然后直接把**“可用 endpoint 列表”**（或者一个轻量的 `ServiceEndpointResolver`）注入进来就行。

更激进一点的写法是：

```ts
class InferenceService {
  constructor(private endpointResolver: (capability: string) => URL) {}

  async translate(...) {
    const url = this.endpointResolver("nmt");
    // 发 HTTP 请求即可
  }
}
```

而 `endpointResolver` 的实现完全可以独立于 InferenceService，只跟 `ServiceRegistry` 和 `ServiceProcessRunner` 打交道：

* `endpointResolver` 查 `ServiceRegistry` 看哪一个 `type === "nmt"` 且 `runtime.status === "running"`；
* 对应的端口 / host 直接在 `service.json` 里定义。

这样一来：

* InferenceService 对“新旧架构”的依赖完全解除；
* 今后如果你改服务发现方式（比如 `ServiceRegistry` 改成别的数据结构），只要改 endpointResolver，不用动 InferenceService；
* 调试 InferenceService 只需要 mock 一个 resolver 即可，完全不用真实起服务。

这就符合你说的：**方便找到问题**——因为 InferenceService 的问题只会是“调用错了 URL / 协议没对上”，不会掺杂服务启动栈。

---

## 4. IPC 层的补充：只保留一份 handler，不带任何“防御性兜底”

在当前问题总结里已经指出：IPC handler 有重复注册、混用新旧 Manager 的问题。

在“不考虑兼容”的前提下，建议你一口气做到：

1. **删掉所有旧 handler，只保留一套基于新架构的 handler 文件**，例如 `service-ipc-handlers.ts`。
2. 这一套 handler 只做两件事：

   * 参数简单校验（serviceId 非空）
   * 调用 `ServiceProcessRunner` 或 `ServiceRegistry` / `ServiceDiscovery`
3. 不要再做任何“如果 manager 没初始化，就返回一个包装过的错误字符串”的防御逻辑——
   直接 throw / log fatal 即可，这样你能马上发现初始化顺序错了，而不是被掩盖。

例如：

```ts
ipcMain.handle("services:start", async (_event, serviceId: string) => {
  if (!serviceId) {
    throw new Error("serviceId is required");
  }
  await serviceRunner.start(serviceId);
  return { ok: true };
});
```

如果启动失败，就让 `start()` 抛异常或返回详细错误，直接 bubble 到前端，前端用 message box 弹出来都可以。**你现在是开发阶段，不需要给用户“优雅降级体验”，需要的是“错误越丑越好看得出来”。**

---

## 5. GPU 显示的补充：要么极简实现，要么干脆不做

当前问题总结里 GPU 只是显示 `--`，你也标成非阻塞。

在“保持代码简洁”的前提下，建议：

* 要么写一个**极简的实现**：

  * Windows：尝试调用一次 `nvidia-smi --query-gpu=utilization.gpu,memory.used --format=csv,noheader,nounits`，解析第一行，失败就 log error。
  * Linux：同理。
  * 不做复杂缓存、不搞多 GPU 聚合、不搞高频轮询（10–15 秒一次足够）。
* 要么在代码里直接写死：`gpu: null`，UI 文案改成「GPU 信息暂未实现」，等你整个服务架构跑顺畅再说。

不要为这个非核心功能加一整套监控 SDK 或抽象层，那完全违背你现在的优先级。

---

## 6. 补充一个“极简清理 checklist”

最后给你一个可以贴墙上的清单，完全从“删掉复杂度”的角度来写：

1. **架构层面**

   * [ ] 删除所有 `legacy*` / `*compat*` 类和文件。
   * [ ] 删除旧的 `PythonServiceManager` / `RustServiceManager` 实现。
   * [ ] 新建一个 `ServiceProcessRunner`，统一 spawn/kill 所有服务。

2. **配置层面**

   * [ ] 确认所有服务都只通过 `services/*/service.json` 配置。
   * [ ] 删掉所有硬编码的服务路径 / 端口 / 命令配置文件。

3. **Inference 层面**

   * [ ] InferenceService 构造函数改为只依赖：`endpointResolver`（或直接 `ServiceRegistry`）。
   * [ ] 全局搜索 `serviceRegistryManager`，确保没有任何引用残留。

4. **IPC 层面**

   * [ ] 只保留一份 IPC handler 文件，统一基于新架构。
   * [ ] 删除所有 duplicate handler 注册。
   * [ ] 出错直接抛异常，让错误暴露出来，不做多层包装兜底。

5. **调试体验**

   * [ ] 所有 spawn 失败都必须 log 出：

     * serviceId
     * command + args
     * cwd
     * exit code / error message
   * [ ] 前端在服务启动失败时直接显示这些信息（哪怕很丑）。

做到这些，你的节点端就会变成一套**很“直男”但极好排查问题的系统**：
请求链路短、数据来源单一、错误不被包装、任何问题都很快能定位到是哪一个 service / 哪一个 JSON / 哪一行 spawn。

如果你愿意，我可以再帮你把这份补充意见整理成一个 `ARCHITECTURE_REFACTOR_SUPPLEMENT_2026_01_20.md`，让你直接发给开发当“补充指令”。
