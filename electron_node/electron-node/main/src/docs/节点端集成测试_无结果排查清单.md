# 节点端集成测试「job2 之后无结果」排查清单

用于在本地/CI 节点端日志中快速定位：每个 job 是否被接收、在哪一步阻塞或未返回结果。

---

## 一、关键日志检索（按时间顺序看）

在节点端 stdout/日志文件中搜索下列关键字（建议保留 `job_id`、`session_id`、`utterance_index` 上下文）：

| 关键字 | 含义 |
|--------|------|
| `Received job_assign, starting processing` | 节点**已接受**该 job，并开始跑 Pipeline；日志里应有 `jobId`、`sessionId`、`utteranceIndex` |
| `Rejecting duplicate job_id` | 同一 `job_id` 被重复派发，节点拒绝 |
| `Rejecting duplicate (session_id, utterance_index)` | **同一 (session_id, utterance_index) 只接受一个 job**，后续同 slot 的 job 被拒绝（见下） |
| `Pipeline mode inferred` | Pipeline 已启动，下一句会带 `modeName`、`steps` |
| `runAsrStep: Audio buffered, returning empty` | ASR 步骤因「音频在 AudioAggregator 中缓冲」未送 ASR，本 job 会继续走后续步骤但 `ctx.asrText` 为空 |
| `Step ASR completed` | ASR 步骤完成 |
| `runAggregationStep: Turn segment accumulated, waiting for finalize` | 本 job 有 turn_id 且非 finalize，仅累积、不送语义修复 |
| `runAggregationStep: Aggregation completed` | 聚合步骤完成 |
| `Step AGGREGATION completed` | 聚合步骤完成（job-pipeline 层） |
| `Skipping step SEMANTIC_REPAIR` | 未送语义修复（条件不满足或 turn 累积中） |
| `Step SEMANTIC_REPAIR completed` | 语义修复步骤完成 |
| `Step X failed` | 某步骤抛错，Pipeline 可能中断（ASR/TRANSLATION/SEMANTIC_REPAIR 失败会 throw） |
| `Pipeline orchestration failed` | `runJobPipeline` 抛错，本 job 无正常结果返回 |
| `SEND_PLAN` | 准备发送的结果列表：`items` 里每个元素的 `job_id`、`shouldSend`、`isEmptyJob` |
| `SEND_ATTEMPT` | 实际发送一条 job 结果 |
| `Long job processing time detected` | 单 job 处理超过 30s，可能卡在 ASR/语义修复/NMT 等 |

---

## 二、节点端「同一 (session_id, utterance_index) 只接受一个 job」约束

代码位置：`node-agent-simple.ts`，`sessionUtteranceKey = session_id + ':' + utterance_index`。

- 每个 `(session_id, utterance_index)` 只会接受**第一个**到达的 job；同一 slot 的后续 job 会直接**拒绝**并打日志：  
  `Rejecting duplicate (session_id, utterance_index): only one job accepted per utterance slot`。
- 若调度端把**同一 turn 的多个 segment**（如长句拆成的多段）都标成**同一个 utterance_index**，则节点只会处理该 slot 的第一个 job，后面同 utterance_index 的 job 全部被拒，表现为「job2 之后没有任何结果返回」（实际是 job3、job4… 被拒，未进 Pipeline）。

**建议**：

1. 在日志中搜 **`Rejecting duplicate (session_id, utterance_index)`**：  
   若 job3/job4/… 出现在这类日志里，说明是 **utterance_index 冲突** 导致未处理。
2. 对照调度端逻辑：同一 turn 的多段 job 是否应使用**不同 utterance_index**（例如按 segment 递增），以保证节点端每个 job 占用不同 slot。

---

## 三、按 job 梳理「输入 / 输出」的推荐顺序

对每一个你关心的 `job_id`（例如 job0、job1、job2、job3…）：

1. **是否被节点接受**  
   搜：`Received job_assign` 且该条日志的 `jobId`（或上下文中的 job_id）等于目标 job。  
   若没有 → 再搜 `Rejecting duplicate` 或 `Rejecting duplicate (session_id, utterance_index)` 中是否包含该 job_id / session_id / utterance_index。

2. **Pipeline 是否启动**  
   搜：`Pipeline mode inferred`，且前后文是同一 job（通过时间戳或 job_id 关联）。

3. **ASR 是否有输出**  
   - 若出现 `runAsrStep: Audio buffered, returning empty`：本 job 未送 ASR，后续 `ctx.asrText` 为空，聚合/语义修复会按空处理。  
   - 若出现 `runAsrStep: [ASRService] ASR batch … completed`：说明有 ASR 输出，可继续看聚合/语义修复。

4. **聚合步骤**  
   - `runAggregationStep: Turn segment accumulated, waiting for finalize` → 本 job 仅做 turn 累积，不送语义修复。  
   - `runAggregationStep: Aggregation completed` → 聚合完成，可看后续是否进入语义修复。

5. **是否送语义修复**  
   - `Skipping step SEMANTIC_REPAIR (condition not met)` → 未送语义修复（例如 turn 累积中或条件不满足）。  
   - `runSemanticRepairStep: Semantic repair completed` → 语义修复已执行。

6. **是否发出结果**  
   搜：`SEND_PLAN` / `SEND_ATTEMPT`，看该 job_id 是否在发送列表中、`shouldSend` 与 `isEmptyJob` 的值。

---

## 四、你当前现象对应的快速检查

- **现象**：只有 [0] 和 [2] 有 ASR/译文，job2 之后没有任何结果。
- **建议先做**：
  1. 搜 **`Received job_assign`**：确认节点实际收到了哪些 job（记下每个的 job_id、utterance_index）。
  2. 搜 **`Rejecting duplicate (session_id, utterance_index)`**：确认 job3、job4… 是否因与已有 slot 冲突被拒。
  3. 若没有拒绝日志，再对 job3、job4… 按第三节逐步查：是否出现 `Pipeline mode inferred`、是否卡在 ASR（长时间无 `ASR batch … completed`）、是否出现 `Step X failed` 或 `Pipeline orchestration failed`。

若你提供一段**按时间排序的节点端日志**（可脱敏 job_id/session_id），可以据此精确定位是「未收到 job」「被拒绝」还是「某一步阻塞/抛错」。
