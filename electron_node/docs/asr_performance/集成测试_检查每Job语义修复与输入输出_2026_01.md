# 集成测试后：如何检查每个 Job 是否进行语义修复及输入/输出

**用途**：根据节点端日志，查看每个 job 在各服务（ASR、聚合、语义修复、NMT、TTS）的处理过程、输入是什么、输出是什么、**有没有进行语义修复**。  
**日期**：2026-01。

---

## 一、用现有脚本生成报告（推荐）

### 1.1 日志文件位置

- **从源码运行**（如 `npm run dev`）：一般为  
  `electron_node/electron-node/logs/electron-main.log`  
  或当前工作目录下的 `electron-node/logs/electron-main.log`。
- **从打包应用运行**：在应用数据目录下的 `logs/electron-main.log`（具体路径因系统而异）。

请用**本次集成测试**结束后产生的 `electron-main.log`（即你朗读「现在我们开始进行一次语音识别稳定性测试…」那次的日志）。

### 1.2 运行分析脚本

**方式 A：Node 脚本（可指定输出报告路径）**

```bash
cd electron_node
node scripts/analyze_jobs_per_service_flow.js electron-node/logs/electron-main.log --out electron-node/logs/docs/asr_performance/JOB_SERVICE_FLOW_REPORT.md
```

若日志在其他路径，把第一个参数换成你的日志绝对路径。

**方式 B：PowerShell 包装脚本**

```powershell
cd electron_node
.\scripts\analyze_jobs_per_service_flow.ps1 -LogPath "D:\你的路径\electron-node\logs\electron-main.log"
```

不指定 `-LogPath` 时，脚本会按默认顺序查找 `electron-node/logs/electron-main.log`。

---

## 二、报告怎么看：是否进行了语义修复

### 2.1 Summary 表（每 Job 一行）

| 列 | 含义 |
|----|------|
| **Repair req/resp** | 语义修复请求数 / 响应数。**1/1** = 本 job 调用了语义修复且有一次完成（有修复结果）。**0/0** = 本 job 未走语义修复（如被 Gate 跳过、或未发送到语义修复）。 |
| ASR / Agg / NMT req/resp / job_result sent | 各阶段请求与响应计数，用于判断是否缺响应、重复发送等。 |

**结论**：  
- **Repair req/resp = 1/1** → 本 job **有**进行语义修复。  
- **Repair req/resp = 0/0** → 本 job **没有**进行语义修复（需结合下文「语义修复」行与聚合 `shouldSendToSemanticRepair` 判断原因）。

### 2.2 每个 Job 的详细表格（阶段 | 输入 | 输出）

脚本会为每个 job 输出：

| 阶段 | 含义 |
|------|------|
| **ASR** | 输入：音频；输出：识别文本（asrText）。 |
| **聚合** | 输入：asrText；输出：`segmentForJobResult`（送给语义修复的本段）、`shouldSendToSemanticRepair`（true/false）。 |
| **语义修复** | **输入**：即上面的 `segmentForJobResult`（本段文本）。**输出**：若已执行，会显示 `decision=PASS/REPAIR/REJECT` 及 `repairedText` 的预览；若未执行，会写「未执行（跳过/无 initializer）」。 |
| **NMT** | 输入：语义修复后的文本（即 repairedText，或未走语义修复时为本段原文）；输出：translatedText 长度与预览。 |
| **TTS** | 输入：译文；输出：是否有音频及长度。 |

因此：

- **有没有进行语义修复**：看该 job 的「语义修复」行是「已执行: Y」且带 `repairedText`，还是「未执行」。
- **语义修复的输入**：即该 job 的「聚合」输出里的 `segmentForJobResult`。
- **语义修复的输出**：即「语义修复」行的 `repairedText`（报告中为预览）。  
  **最终送给 NMT 的**就是这份 `repairedText`（或未走语义修复时的本段原文）。

---

## 三、语义修复「服务端」的 text_in / text_out（可选）

节点端日志里已有：**输入** = `segmentForJobResult`，**输出** = `repairedText`。  
若还要看**语义修复服务（Python）**自己记录的 text_in → text_out（含 decision、reason_codes），需要看 **Python 语义修复进程的 stdout**：

- 统一服务（semantic-repair-en-zh）会打类似：  
  `[Unified SR] ZH_REPAIR OUTPUT: ... text_in=... text_out=... decision=REPAIR|PASS ...`
- 从这些行可以看到服务端收到的输入、返回的输出以及是否做了修改。

节点端 `electron-main.log` 里**没有**把 HTTP 请求体/响应体逐字打出来，所以「服务端一字不差的 text_in/text_out」只在 Python 进程日志里。

---

## 四、你本次测试结果对应的检查步骤

你提供的原文/译文是按 utterance_index [0]、[2]、[3]、[5]、[7]、[8]、[9] 等分段；且原文多为繁体（如 開始、劇、隨意、盡量、停盾、解斷、插滿、不良怪、丟事、千分、差勢、日治、關鍵保），说明：

1. **ASR 输出**：当前就是繁体或混用，报告里「ASR 输出」即各 job 的识别结果。
2. **是否走了语义修复**：  
   - 用上面命令对**本次测试的 electron-main.log** 跑一遍脚本。  
   - 看 Summary 里每个 job 的 **Repair req/resp** 是否为 **1/1**。  
   - 看每个 job 的「语义修复」行是「已执行: Y」+ `repairedText`，还是「未执行」。
3. **语义修复有没有改字**：  
   - 在报告中对比该 job 的「聚合」输出 `segmentForJobResult`（语义修复输入）与「语义修复」输出的 `repairedText`。  
   - 若两者一致，说明本次调用语义修复**没有改文**（可能 decision=REPAIR 但 text_out=text_in，或为 PASS/NO_CHANGE）。  
   - 若希望看到服务端更细的 decision/reason_codes，需查 Python 语义修复进程的 stdout（见第三节）。

建议你先在**本次集成测试**对应的 `electron-main.log` 上执行：

```bash
cd electron_node
node scripts/analyze_jobs_per_service_flow.js <你的 electron-main.log 路径> --out electron-node/logs/docs/asr_performance/JOB_SERVICE_FLOW_REPORT.md
```

然后打开生成的 `JOB_SERVICE_FLOW_REPORT.md`，按 Summary 和每个 Job 的「语义修复」行即可判断：每个 job 是否进行了语义修复，以及输入（segmentForJobResult）和输出（repairedText）分别是什么。
