# 返回结果原文有时简体有时繁体的原因

## 现象

客户端展示的「原文」(text_asr) 有时是简体中文、有时是繁体中文。

## 能否用简/繁体辨认 job 是否经过了语义修复？

**可以当作粗略的辨认依据，但不保证 100% 准确。**

- **原文 (text_asr) 的唯一来源**：`repairedText`（见 `result-builder.ts`：`text_asr` 仅用 `ctx.repairedText`）。
- **repairedText 的两种来源**：
  1. **语义修复跑通时**：`repairedText` = 语义修复服务返回的 `text_out`（LLM 输出）。
  2. **语义修复未跑或跳过时**：`repairedText` = 本段的 `segmentForJobResult`，即 **ASR 直出**（或聚合后的 ASR 文本）。

因此：
- **未经过语义修复**（未调用、失败、或 segment 为空等）：原文 = ASR 直出 → 在你当前环境下**多为繁体**（ASR 模型/口音偏繁体时）。
- **经过语义修复**：原文 = LLM 输出 → 常见中文 LLM 以简体为主，**多为简体**；但 prompt 未要求「必须输出简体」，少数情况下也可能保留繁体。

**结论**：用「原文为简体」来推断「大概率经过了语义修复」、「原文为繁体」来推断「大概率未经过语义修复」在多数情况下成立，可作为**经验性辨认**；若需要程序化判断，应依赖已有的 `semantic_repair_applied` 等字段，而不是仅靠简繁体。

## 根因拆解

1. **ASR（Faster Whisper）**
   - 代码里**没有**约定输出「简体」或「繁体」。
   - 模型/语言/口音不同时，可能输出繁体（例如 zh-TW 或部分多语言模型），也可能输出简体。

2. **语义修复（semantic_repair_zh / en_zh）**
   - Prompt（`prompt_templates.py`）只要求「同音字修复、保持原意、原样输出」等，**没有**写「输出使用简体中文」或「保持与输入相同的简繁体」。
   - 模型多为简体语料训练，修复/改写时容易输出简体；若「原样输出」则可能保留输入的繁体。
   - 因此**没有**「修复=转简体」的显式逻辑，只是模型倾向导致现象上多为简体。

3. **未走语义修复时**
   - 设计上**所有需发送的 ASR 结果必须经语义修复服务**（见 `SEMANTIC_REPAIR_REQUIRED_2026_01_29.md`）。当语义修复不可用（无 initializer、初始化失败、无 stage）时，不再透传原文：`ctx.repairedText = ''` 且 `ctx.shouldSend = false`，该结果不发送。
   - 若在测试中仍看到全文为繁体，说明当时语义修复服务未就绪或未注入，结果本应不发送；修复逻辑落地后，不可用时将不再产出带原文的 job 结果。

## 关于统一字体

统一原文的简/繁体应与 **Web 端用户选择**（例如用户偏好简体/繁体展示）保持一致。该功能尚未实现，目前无需在 Node 或语义修复侧做统一；待 Web 端有明确需求与交互后再考虑（例如在展示前按用户偏好做繁简转换）。
