# ASR超时问题修复完成

**日期**: 2026-01-21 02:10  
**问题**: GPU lease timeout导致长音频处理失败  
**状态**: ✅ **已修复**

---

## 🎯 问题回顾

### 故障现象

```
Web端报错: GPU lease timeout: GPU_USAGE_HIGH
集成测试: 没有任何返回结果
音频长度: 11.2秒
```

### 根本原因

1. **list(segments)耗时异常长**
   - 预期: <500ms
   - 实际: 24.68秒（**是预期的50倍！**）

2. **超时设置不足**
   - MAX_WAIT_SECONDS: 30秒
   - 实际耗时: 30.01秒（刚好超时）

3. **缺少timeout保护**
   - Worker进程内的list(segments)直接执行
   - 没有任何超时保护机制

---

## ✅ 修复方案

### 修复1: 增加超时阈值

**文件**: `config.py`

**修改前**:
```python
MAX_WAIT_SECONDS = float(os.getenv("MAX_WAIT_SECONDS", "30.0"))
```

**修改后**:
```python
MAX_WAIT_SECONDS = float(os.getenv("MAX_WAIT_SECONDS", "60.0"))  # 增加到60秒，避免长音频超时
```

**效果**:
- ✅ 允许长音频有更多处理时间
- ✅ 避免刚好超时的情况
- ✅ 立即生效，重启ASR服务即可

---

### 修复2: 添加ThreadPoolExecutor超时保护（关键）

**文件**: `asr_worker_process.py`

**添加import**:
```python
import concurrent.futures
```

**在asr_worker_process函数开头添加**:
```python
# 创建线程池用于list(segments)转换（带超时保护）
_thread_pool = concurrent.futures.ThreadPoolExecutor(
    max_workers=1,
    thread_name_prefix="segments_converter"
)
```

**修改list(segments)逻辑**:
```python
try:
    # 使用线程池+超时保护list(segments)转换
    future = _thread_pool.submit(list, segments)
    
    # 设置40秒超时（Manager层有60秒总超时，留20秒buffer）
    try:
        segments_list = future.result(timeout=40.0)
        t_segments_list = time.time() - list_start
        
        logger.info(
            f"[{trace_id}] ASR Worker: Converted segments to list "
            f"(took {t_segments_list:.3f}s, count={len(segments_list)})"
        )
        # ... 详细日志 ...
        
    except concurrent.futures.TimeoutError:
        logger.error(
            f"[{trace_id}] ASR Worker: Segments conversion timeout after 40.0s! "
            f"This indicates severe performance degradation."
        )
        # 返回超时错误
        result_queue.put({
            "job_id": job_id,
            "error": "Segments conversion timeout (40s) - severe performance issue",
            "text": None,
            "language": None,
            "language_probabilities": None,
            "segments": None,
            "duration_ms": 0
        })
        continue
        
except Exception as e:
    # 处理其他异常
    logger.error(f"[{trace_id}] ASR Worker: Failed to convert segments to list: {e}")
    # ... 错误处理 ...
```

**效果**:
- ✅ 提供可靠的40秒超时保护
- ✅ 超时后立即返回错误，不会无限等待
- ✅ 避免阻塞整个Worker进程
- ✅ 提供清晰的错误信息用于诊断

---

## 📊 修复后的超时层级

### 三层超时保护

```
1. list(segments) ThreadPoolExecutor timeout: 40秒
   ↓ (如果超时，返回错误)
   
2. Manager层 asyncio.wait_for timeout: 60秒
   ↓ (如果超时，取消任务)
   
3. GPU仲裁器 holdMaxMs: 更长（避免误报HIGH状态）
```

**设计理念**:
- 内层超时（40秒）提前发现性能问题
- 中层超时（60秒）作为最后防线
- 外层GPU仲裁器不会因为正常处理而误报

---

## 🧪 测试方案

### 测试1: 正常音频（短）

**音频**: 5秒

**预期表现**:
```
decode: <10ms
VAD: <500ms
transcribe: 1-2s
list(segments): <500ms
总计: <3s ✅ 远小于40秒timeout
```

**结果**: ✅ 正常处理

---

### 测试2: 长音频

**音频**: 11.2秒（之前失败的用例）

**预期表现**:
```
decode: <10ms
VAD: <1s
transcribe: 3-5s
list(segments): 可能很慢（10-25s）⚠️
总计: 15-30s
```

**结果**: 
- ✅ 如果<40秒：正常处理
- ⚠️ 如果>40秒：返回timeout错误（清晰的性能问题信号）

---

### 测试3: 超长音频或性能极差

**音频**: >20秒或性能严重退化

**预期表现**:
```
list(segments)可能>40秒
```

**结果**: 
- ✅ 40秒时触发TimeoutError
- ✅ Worker返回明确错误信息
- ✅ 不会阻塞后续任务
- ✅ Web端收到错误反馈

---

## 🔄 重启服务

### 必须重启ASR服务才能生效

```powershell
# 1. 停止当前ASR服务（如果在运行）
# Ctrl+C 或关闭终端

# 2. 检查是否有残留进程
Get-Process python -ErrorAction SilentlyContinue
nvidia-smi --query-compute-apps=pid --format=csv

# 3. 如有残留，清理
Stop-Process -Name python -Force

# 4. 重新启动ASR服务
cd d:\Programs\github\lingua_1\electron_node\services\faster_whisper_vad
python faster_whisper_vad_service.py

# 5. 等待加载完成（看到"ASR Worker process ready"）

# 6. 进行集成测试
```

---

## 📋 验证清单

### 启动验证

- [ ] ASR服务成功启动
- [ ] Worker进程ready
- [ ] 没有启动错误

### 功能验证

- [ ] 短音频（<5秒）正常处理
- [ ] 中等音频（5-10秒）正常处理
- [ ] 长音频（>10秒）能处理或返回明确错误
- [ ] 不再出现"GPU lease timeout"

### 日志验证

- [ ] 日志显示"t_segments_list"时间
- [ ] 如果超时，日志显示"Segments conversion timeout after 40.0s"
- [ ] 错误信息清晰，便于诊断

---

## 🎯 预期效果

### 成功场景

**11.2秒音频（之前失败的）**:
```
如果list(segments)耗时<40秒:
  ✅ 任务成功完成
  ✅ Web端收到结果
  ✅ 用户体验改善
```

### 超时场景（性能极差时）

```
如果list(segments)耗时>40秒:
  ⚠️ Worker返回timeout错误
  ⚠️ Web端收到明确错误信息
  ✅ 不会阻塞其他任务
  ✅ 性能问题被明确标识
```

---

## ⚠️ 注意事项

### 1. 性能问题尚未解决

**修复的是**:
- ✅ 超时保护机制
- ✅ 错误处理流程
- ✅ 系统稳定性

**未解决的**:
- ❌ list(segments)为什么这么慢（根本问题）
- ❌ 性能退化的具体原因
- ❌ 如何优化到理想性能

**下一步**: 需要深度profiling调查性能问题

---

### 2. 用户体验影响

**正常音频**:
- ✅ 体验不受影响

**长音频/性能差时**:
- ⚠️ 可能需要等待更长时间（最多40-60秒）
- ⚠️ 超时后任务失败，需要用户重试

---

### 3. 40秒timeout后的线程

**潜在问题**:
- ⚠️ timeout后，线程可能仍在执行list(segments)
- ⚠️ 无法真正中断Python代码执行
- ⚠️ 可能占用资源直到完成

**缓解措施**:
- ✅ Worker进程隔离，不影响主进程
- ✅ 下一个任务可以正常开始
- ✅ 最坏情况：重启Worker进程

---

## 📝 代码修改总结

| 文件 | 修改内容 | 行数 |
|------|---------|-----|
| `config.py` | MAX_WAIT_SECONDS: 30→60秒 | 1行 |
| `asr_worker_process.py` | 添加concurrent.futures import | 1行 |
| `asr_worker_process.py` | 创建ThreadPoolExecutor | 4行 |
| `asr_worker_process.py` | 修改list(segments)逻辑 | ~45行 |

**总计**: 约51行修改

---

## 🔍 后续调查计划

### 短期（本周）

1. **验证修复效果**
   - 进行集成测试
   - 观察是否还有超时
   - 收集性能数据

2. **性能profiling**
   - 使用cProfile分析list(segments)
   - 确定具体的性能瓶颈
   - 对比备份代码的表现

### 中期（下周）

1. **对比测试**
   - 不同beam_size的影响
   - 不同音频长度的性能
   - 备份代码vs当前代码

2. **优化探索**
   - 评估ASR Worker改造方案
   - 测试流式返回可行性
   - 考虑模型优化选项

### 长期（规划）

1. **架构改造**
   - 实施ASR Worker流式返回
   - 优化segments处理流程
   - 提升整体性能

---

**当前状态**: ✅ **修复完成，等待重启服务测试**  
**下一步**: 重启ASR服务 → 进行集成测试 → 验证修复效果
