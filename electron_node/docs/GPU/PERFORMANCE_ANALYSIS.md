# 性能分析总结

## 各服务耗时统计

### Semantic Repair服务
- Job[1]: 186ms
- Job[2]: 328ms
- Job[3]: 438ms
- Job[5]: 180ms
- Job[6]: 241ms
- Job[8]: 422ms
- Job[10]: 436ms
- Job[13]: 247ms
- **平均耗时**: ~310ms
- **范围**: 180-438ms

### NMT服务（从日志估算）
- 从日志看，NMT请求到返回大约需要1-2秒
- 包括GPU仲裁等待时间

### TTS服务（从日志估算）
- 从日志看，TTS生成大约需要300-600ms
- 包括GPU仲裁等待时间

## 整体耗时优化

### 优化前（估计）
- 串行执行：ASR → Semantic Repair → NMT → TTS
- 总耗时：约3-5秒/句
- GPU利用率低，存在等待时间

### 优化后（当前）
- 流水线并行：不同job的不同阶段可以并行执行
- GPU仲裁：避免GPU冲突，提高利用率
- 顺序执行：确保每个服务内部按顺序执行，避免混乱

### 性能提升（估计）
- **延迟降低**: 30-50%（通过流水线并行）
- **GPU利用率**: 提高40-60%（通过GPU仲裁）
- **吞吐量**: 提高50-70%（通过并发处理）

## 需要进一步优化的点

1. **文本切分问题**：需要优化AudioAggregator的切分逻辑
2. **context_text获取**：已修复，但需要持续监控
3. **顺序执行**：已实现，但需要优化超时处理
