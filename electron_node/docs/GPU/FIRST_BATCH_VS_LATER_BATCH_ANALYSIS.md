# 第一批vs后续批次质量差异分析

## 问题描述

用户发现：
- **第一批（job0-2）**：翻译质量非常好，语音非常完整
- **后续批次（job3+）**：被切分得非常短，无法合并，翻译质量差，明显的错误也无法被修复，还有最后一句话被吃掉的问题

## 日志分析

### 第一批（job0-2）
- 没有"Short utterance detected"的日志
- 音频正常聚合，文本完整
- 所有服务正常完成

### 后续批次（job3+）
- 从job6开始，大量出现"Short utterance detected, delaying processing to wait for merge"
- 然后"Short utterance wait timeout, processing buffered audio"
- 音频时长：2.5-7秒（都是短句）
- 文本被切分得非常短，无法合并

## 根本原因

### 问题1：短句延迟合并机制的问题

**当前逻辑**：
- 如果音频<6秒且`isManualCut=true`，延迟2秒等待下一个chunk
- 如果2秒内没有新chunk，超时后单独处理短句

**问题**：
1. **等待时间太短**：2秒可能不够，导致短句被单独处理
2. **短句无法合并**：如果后续chunk也是短句，每个短句都被单独处理
3. **文本质量差**：短句单独处理导致ASR识别不完整，翻译质量差

### 问题2：短句处理后的状态

**当前逻辑**：
- 短句等待超时后，清除等待标志，继续处理
- 但此时`isManualCut=true`，会立即处理短句

**问题**：
- 短句被单独处理，无法与后续chunk合并
- 导致文本被切分得非常短

### 问题3：第一批为什么正常？

**可能原因**：
1. 第一批音频较长（>6秒），不触发短句延迟合并
2. 第一批音频可能没有`isManualCut=true`，或者有其他标识
3. 第一批音频可能被正常聚合

## 解决方案

### 方案1：增加短句等待时间（推荐）

**问题**：当前等待时间2秒可能不够

**修复**：
- 将`SHORT_UTTERANCE_WAIT_MS`从2秒增加到5秒
- 或者根据音频时长动态调整等待时间

### 方案2：改进短句合并逻辑

**问题**：短句等待超时后，无法与后续chunk合并

**修复**：
- 即使等待超时，如果后续chunk很快到达，仍然尝试合并
- 或者，短句等待超时后，不立即处理，而是继续等待一段时间

### 方案3：调整短句阈值

**问题**：6秒的阈值可能太严格

**修复**：
- 将`SHORT_UTTERANCE_THRESHOLD_MS`从6秒增加到8秒或10秒
- 或者根据音频质量动态调整阈值

### 方案4：改进短句处理策略

**问题**：短句被单独处理，导致质量差

**修复**：
- 短句等待超时后，如果仍然很短（<3秒），继续等待
- 或者，短句等待超时后，检查是否有pendingSecondHalf，如果有则合并

## 建议的修复优先级

1. **高优先级**：增加短句等待时间（从2秒增加到5秒）
2. **中优先级**：改进短句合并逻辑，即使等待超时也尝试合并
3. **低优先级**：调整短句阈值或改进处理策略
