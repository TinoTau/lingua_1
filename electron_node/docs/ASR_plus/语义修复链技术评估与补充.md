# ASR语义修复链技术方案评估与补充

## 一、方案可行性评估

### ✅ 整体可行性：**高**

**核心优势**：
1. **架构兼容性好**：方案设计在ASR之后、NMT之前插入修复阶段，与现有`PostProcessCoordinator`架构完全兼容
2. **最小侵入**：可以作为一个新的Stage插入，不影响现有流程
3. **可渐进式实施**：基于服务发现机制，用户选择性安装服务包，系统自动启用功能
4. **问题定位准确**：针对ASR同音字/误识别问题，在翻译前修复，避免错误扩散
5. **服务独立性**：中英文修复服务完全独立，可以分别安装和优化
6. **模型独立性**：中英文使用不同的优化模型，可以根据语言特点优化

**潜在风险**：
1. **延迟增加**：LLM调用会增加50-2000ms延迟（取决于模型大小和硬件）
2. **成本控制**：需要严格控制触发率，避免成本爆炸
3. **误修复风险**：需要严格的prompt和验证机制
4. **服务依赖**：需要确保服务发现机制稳定可靠

---

## 二、需要补充的关键技术细节

### 2.1 架构集成点（关键）

#### 当前架构流程
```
PipelineOrchestrator.processJob()
  → ASR
  → AggregatorMiddleware.processASRResult()  // 文本聚合
  → PostProcessCoordinator.process()
    → AggregationStage.process()           // Stage 1: 进一步聚合
    → TranslationStage.process()           // Stage 2: 翻译
    → DedupStage.process()                 // Stage 3: 去重
    → TTSStage.process()                   // Stage 4: TTS
```

#### 建议插入点（最小侵入）

**方案A：在AggregationStage之后、TranslationStage之前插入（推荐）**

```typescript
PostProcessCoordinator.process()
  → AggregationStage.process()
  → [新增] SemanticRepairStage.process()  // 语义修复
  → TranslationStage.process()
  → DedupStage.process()
  → TTSStage.process()
```

**理由**：
- 修复的是聚合后的完整文本，而不是片段
- 在翻译前修复，避免错误扩散
- 可以利用已有的`quality_score`和`aggregatedText`

**实现位置**：
- 文件：`electron_node/electron-node/main/src/agent/postprocess/semantic-repair-stage.ts`
- 插入点：`postprocess-coordinator.ts` 的 `process()` 方法中，`AggregationStage` 之后

---

### 2.2 服务部署与调用方式

#### 方案选择（已确定：基于服务发现的服务包机制）

**最终方案**：**独立服务包 + 服务发现机制**

**设计要点**：
1. **服务包化**：语义修复服务作为独立服务包（`semantic-repair-zh`、`semantic-repair-en`、`en-normalize`）
2. **用户选择安装**：用户可以选择性安装中文或英文修复服务
3. **自动服务发现**：系统通过`ServiceRegistryManager`自动检测已安装的服务
4. **自动启用功能**：根据已安装的服务自动初始化对应的Stage
5. **无需配置开关**：功能启用由服务发现决定，配置文件只用于高级参数

**服务包结构**：
- `semantic-repair-zh`：中文修复服务（包含中文优化模型）
- `semantic-repair-en`：英文修复服务（包含英文优化模型）
- `en-normalize`：英文Normalize服务（无模型，纯规则处理）

**部署方式**：
- 服务包可以部署在节点端本地（通过ServiceRuntimeManager管理）
- 也可以部署为集中式服务（通过HTTP调用）
- 支持混合部署（部分节点本地，部分集中式）

#### 服务接口设计

**请求格式**：
```typescript
interface SemanticRepairRequest {
  job_id: string;
  session_id: string;
  utterance_index: number;
  lang: 'zh' | 'en';
  text_in: string;                    // 聚合后的ASR文本
  quality_score?: number;              // ASR质量分数
  micro_context?: string;              // 上一句尾部（80-150字）
  meta?: {
    segments?: any[];                  // ASR segments信息
    language_probability?: number;      // 语言检测概率
    reason_codes?: string[];           // 质量检测原因码
  };
}
```

**响应格式**：
```typescript
interface SemanticRepairResponse {
  decision: 'PASS' | 'REPAIR' | 'REJECT';
  text_out: string;                    // 修复后的文本（PASS则等于text_in）
  confidence: number;                   // 修复置信度（0-1）
  diff?: Array<{                       // 编辑差异（用于审计）
    from: string;
    to: string;
    position: number;
  }>;
  reason_codes: string[];              // 触发原因
  repair_time_ms?: number;              // 修复耗时
}
```

#### TaskRouter集成

**新增文件**：`task-router-semantic-repair.ts`

```typescript
export class TaskRouterSemanticRepair {
  async routeRepairTask(
    request: SemanticRepairRequest
  ): Promise<SemanticRepairResponse> {
    // 1. 服务选择（类似ASR/NMT服务选择）
    // 2. HTTP调用修复服务
    // 3. 超时处理（建议1-2秒）
    // 4. 错误降级（超时/错误时返回PASS）
  }
}
```

---

### 2.3 触发策略详细设计

#### 中文链路触发条件（细化）

```typescript
function shouldTriggerRepair(
  text: string,
  qualityScore: number | undefined,
  lang: string,
  meta: any
): { shouldRepair: boolean; reasonCodes: string[] } {
  const reasonCodes: string[] = [];
  
  // 条件1：质量分触发（主要触发条件）
  if (qualityScore !== undefined && qualityScore < 0.70) {
    reasonCodes.push('LOW_QUALITY_SCORE');
  }
  
  // 条件2：短句 + 异常词形（需要补充具体实现）
  if (text.length <= 16) {
    // 2.1 字符分布异常检测
    const nonChineseRatio = countNonChineseChars(text) / text.length;
    if (nonChineseRatio > 0.3) {
      reasonCodes.push('HIGH_NON_CHINESE_RATIO');
    }
    
    // 2.2 结构异常检测（需要补充）
    if (!hasBasicSyntax(text)) {
      reasonCodes.push('MISSING_BASIC_SYNTAX');
    }
  }
  
  // 条件3：可翻译性检查
  if (lang !== 'zh' || hasGarbageChars(text)) {
    reasonCodes.push('LOW_TRANSLATABILITY');
  }
  
  // 至少满足一个条件才触发
  return {
    shouldRepair: reasonCodes.length > 0,
    reasonCodes
  };
}
```

**需要补充的实现**：
1. `countNonChineseChars()` - 非中文字符统计
2. `hasBasicSyntax()` - 基本句法检查（动词/实体检测）
3. `hasGarbageChars()` - 乱码检测（可复用现有`bad-segment-detector.ts`）

#### 英文链路触发条件（细化）

```typescript
function shouldTriggerRepairEN(
  text: string,
  qualityScore: number | undefined,
  flags: NormalizeFlags  // 由EnNormalizeStage产生
): { shouldRepair: boolean; reasonCodes: string[] } {
  const reasonCodes: string[] = [];
  
  // 条件1：质量分触发
  if (qualityScore !== undefined && qualityScore < 0.70) {
    reasonCodes.push('LOW_QUALITY_SCORE');
  }
  
  // 条件2：Normalize后仍不可翻译
  if (flags.hasFragmentation || flags.hasStructuralIssue) {
    reasonCodes.push('NORMALIZE_FAILED');
  }
  
  // 条件3：数字/单位/专名密集且疑似错误
  if (flags.hasNumbers && flags.hasConflictingNumbers) {
    reasonCodes.push('CONFLICTING_NUMBERS');
  }
  
  return {
    shouldRepair: reasonCodes.length > 0,
    reasonCodes
  };
}
```

---

### 2.4 LLM模型选择与部署（已确定）

#### 模型推荐

**中文链路**：
- **服务包**：`semantic-repair-zh`
- **模型**：Qwen2.5-3B-Instruct（中文优化版本，INT4量化）
  - 显存需求：~2GB
  - 推理速度：50-200ms/句（取决于硬件）
  - 商用许可：✅
  - 模型路径：`${SERVICE_DIR}/models/qwen2.5-3b-instruct-zh`
- **备选**：Qwen2.5-7B-Instruct（增强版，显存~4GB，速度100-500ms/句）

**英文链路**：
- **服务包**：`semantic-repair-en`
- **模型**：Qwen2.5-3B-Instruct（英文优化版本或多语言版本，INT4量化）
  - 显存需求：~2GB
  - 推理速度：50-200ms/句
  - 模型路径：`${SERVICE_DIR}/models/qwen2.5-3b-instruct-en`
- **备选**：更小的英文专用模型（1-2B，显存~1GB，速度30-150ms/句）

**关键点**：
- **中英文使用不同的模型**，可以根据语言特点优化
- 模型包含在服务包中，随服务包一起安装
- 支持模型独立更新和迭代

#### 部署架构

**服务包部署方式**：
```
用户安装服务包
  ↓
服务包解压到 userData/services/
  ↓
ServiceRuntimeManager 管理服务进程
  ↓
服务通过HTTP提供接口（默认端口：5015/5016/5017）
  ↓
TaskRouter 通过服务发现调用服务
```

**支持部署模式**：
1. **节点端本地部署**（推荐）：服务包安装在节点端，通过ServiceRuntimeManager管理
2. **集中式部署**（可选）：服务部署在集中式服务器，节点通过HTTP调用
3. **混合部署**：部分节点本地，部分集中式

#### 性能优化（需要补充）

1. **批处理**：多个请求合并批处理（需要设计批处理接口）
2. **缓存**：修复结果缓存（相同文本不重复修复）
3. **量化**：INT4量化降低显存和延迟
4. **KV Cache**：复用KV Cache加速推理

---

### 2.5 Prompt设计（需要细化）

#### 中文Prompt（当前版本需要优化）

**问题**：当前prompt过于简单，需要更严格的约束

**优化建议**：
```typescript
const ZH_REPAIR_PROMPT = `你是语音识别后处理器。输入是一句ASR文本，可能有同音字、近音词、错别字。

**严格规则**：
1. **最小编辑原则**：只替换明显不合理或不符合语义的词，尽量少改动
2. **禁止扩写**：不要添加新信息，不要改变语气，不要解释
3. **禁止编造**：如果原文合理，原样输出；如果无法确定，保持原文
4. **长度限制**：输出文本长度变化不超过±20%
5. **格式保持**：保持标点、空格、大小写等格式

**输出格式**：只输出修正后的文本，不要任何解释或标记

原文：{text_in}
${micro_context ? `上一句片段：{micro_context}` : ''}
`;
```

**需要补充**：
- 同音字修复的示例（few-shot learning）
- 专业术语保护机制
- 数字/日期保护机制

#### 英文Prompt（需要补充）

```typescript
const EN_REPAIR_PROMPT = `You are a post-processor for ASR output. The input may contain misrecognized words, wrong abbreviations, or wrong numbers.

**Strict Rules**:
1. Make minimal edits only to fix obvious errors
2. Do not expand the sentence. Do not add new information
3. Preserve acronyms (API, HTTP, GPU...), URLs, emails, and file paths
4. If the input is already fine, output it unchanged
5. Output length change should not exceed ±20%

**Output Format**: Output ONLY the corrected text, no explanation

Input: {text_in}
${micro_context ? `Previous snippet: {micro_context}` : ''}
`;
```

---

### 2.6 与现有NMT Repair的协调（关键）

#### 当前NMT Repair机制

**位置**：`translation-stage.ts`
**触发条件**：`quality_score < 0.7` 且 `sourceCandidates.length === 1`
**行为**：生成5个翻译候选，通过打分选择最佳

#### 协调策略（需要实现）

**方案A：语义修复优先（推荐）**
```typescript
// 在TranslationStage中
if (quality_score < 0.7) {
  // 1. 先尝试语义修复（如果启用）
  if (semanticRepairEnabled) {
    const repairResult = await semanticRepairStage.process(...);
    if (repairResult.decision === 'REPAIR' && repairResult.confidence > 0.7) {
      // 使用修复后的文本翻译，不触发NMT Repair
      textForNMT = repairResult.text_out;
      skipNMTRepair = true;
    }
  }
  
  // 2. 如果语义修复未触发或置信度低，才触发NMT Repair
  if (!skipNMTRepair) {
    // 降低NMT Repair候选数（从5降到3）
    numCandidates = 3;
  }
}
```

**配置项**：
```typescript
{
  semanticRepairEnabled: true,
  semanticRepairPriority: true,  // 语义修复优先
  nmtRepairFallback: true,       // 语义修复失败时降级到NMT Repair
  nmtRepairCandidateReduction: true,  // 启用语义修复时减少NMT候选数
}
```

---

### 2.7 延迟与超时控制（关键）

#### 延迟预算

**目标延迟**：
- P50: < 100ms（不触发修复时）
- P95: < 500ms（触发修复时）
- P99: < 2000ms（极端情况）

**延迟分解**：
```
总延迟 = 服务选择(5ms) + 网络(10-50ms) + LLM推理(50-2000ms) + 后处理(5ms)
```

#### 超时策略

```typescript
const REPAIR_TIMEOUT_MS = 2000;  // 2秒超时

try {
  const result = await Promise.race([
    semanticRepairService.repair(request),
    new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Timeout')), REPAIR_TIMEOUT_MS)
    )
  ]);
} catch (error) {
  // 超时或错误时降级：返回PASS，使用原文
  return {
    decision: 'PASS',
    text_out: request.text_in,
    confidence: 0.0,
    reason_codes: ['TIMEOUT_OR_ERROR']
  };
}
```

---

### 2.8 错误处理与降级策略（需要补充）

#### 降级场景

1. **服务不可用**：返回PASS，使用原文
2. **超时**：返回PASS，使用原文
3. **低置信度修复**：如果`confidence < 0.5`，回退到原文
4. **长度异常**：如果输出长度变化 > ±20%，回退到原文

#### 实现代码

```typescript
function validateRepairResult(
  original: string,
  repaired: SemanticRepairResponse
): SemanticRepairResponse {
  // 检查1：置信度检查
  if (repaired.confidence < 0.5) {
    return {
      ...repaired,
      decision: 'PASS',
      text_out: original,
      reason_codes: [...repaired.reason_codes, 'LOW_CONFIDENCE_REJECTED']
    };
  }
  
  // 检查2：长度变化检查
  const lengthChange = Math.abs(repaired.text_out.length - original.length) / original.length;
  if (lengthChange > 0.2) {
    return {
      ...repaired,
      decision: 'PASS',
      text_out: original,
      reason_codes: [...repaired.reason_codes, 'LENGTH_CHANGE_TOO_LARGE']
    };
  }
  
  // 检查3：可翻译性检查（需要补充实现）
  if (!isTranslatable(repaired.text_out)) {
    return {
      ...repaired,
      decision: 'REJECT',
      text_out: original,
      reason_codes: [...repaired.reason_codes, 'STILL_NOT_TRANSLATABLE']
    };
  }
  
  return repaired;
}
```

---

### 2.9 可观测性设计（需要补充）

#### 日志字段（必须）

```typescript
interface SemanticRepairLog {
  // 输入
  job_id: string;
  session_id: string;
  utterance_index: number;
  lang: 'zh' | 'en';
  text_in: string;
  text_in_length: number;
  quality_score?: number;
  micro_context?: string;
  
  // 输出
  decision: 'PASS' | 'REPAIR' | 'REJECT';
  text_out: string;
  text_out_length: number;
  confidence: number;
  diff_count: number;  // 修改的字符/词数
  reason_codes: string[];
  
  // 性能
  repair_time_ms: number;
  service_endpoint?: string;
  
  // 下游影响
  translation_before?: string;  // 修复前的翻译（如果有）
  translation_after?: string;   // 修复后的翻译
}
```

#### 关键指标（需要实现）

1. **触发率**：`REPAIR决策数 / 总请求数`
2. **修复成功率**：`confidence > 0.7的REPAIR数 / REPAIR总数`
3. **延迟分布**：P50/P95/P99修复延迟
4. **误修复率**：人工抽样评估
5. **下游影响**：修复后翻译质量提升（需要设计评估方法）

#### 指标采集实现

```typescript
class SemanticRepairMetrics {
  recordRepair(request: SemanticRepairRequest, response: SemanticRepairResponse, duration: number) {
    // 1. 记录触发率
    this.metrics.increment('semantic_repair.requests.total');
    if (response.decision === 'REPAIR') {
      this.metrics.increment('semantic_repair.requests.repair');
    }
    
    // 2. 记录延迟
    this.metrics.histogram('semantic_repair.duration_ms', duration);
    
    // 3. 记录置信度
    this.metrics.histogram('semantic_repair.confidence', response.confidence);
    
    // 4. 记录原因码
    response.reason_codes.forEach(code => {
      this.metrics.increment(`semantic_repair.reason.${code}`);
    });
  }
}
```

---

### 2.10 英文Normalize Stage实现细节（需要补充）

#### 功能清单细化

**1. 文本规范化**
```typescript
function normalizeText(text: string): string {
  // 1.1 统一大小写
  text = normalizeCase(text);  // 句首大写、缩写全大写
  
  // 1.2 去除重复空格
  text = text.replace(/\s+/g, ' ');
  
  // 1.3 处理填充词（可选，仅在低质量时）
  if (shouldRemoveFillers(text)) {
    text = removeFillers(text);  // um/uh/like
  }
  
  return text.trim();
}
```

**2. 数字/单位/日期规范化**
```typescript
function normalizeNumbers(text: string): string {
  // 2.1 口语数字转数字（需要配置开关）
  // "one hundred and five" → "105"（可选）
  
  // 2.2 单位规范化
  text = text.replace(/\bkb\b/gi, 'KB');
  text = text.replace(/\bmb\b/gi, 'MB');
  text = text.replace(/\bghz\b/gi, 'GHz');
  text = text.replace(/\bpercent\b/gi, '%');
  
  // 2.3 日期时间（仅在必要时）
  // "Jan 5th" → "January 5th"（可选）
  
  return text;
}
```

**3. 缩写保护**
```typescript
const PROTECTED_ACRONYMS = [
  'API', 'URL', 'HTTP', 'HTTPS', 'GPU', 'CPU', 'SQL', 'JSON',
  'XML', 'HTML', 'CSS', 'JS', 'TS', 'REST', 'SOAP', 'RPC'
];

function protectAcronyms(text: string): string {
  PROTECTED_ACRONYMS.forEach(acronym => {
    const regex = new RegExp(`\\b${acronym}\\b`, 'gi');
    text = text.replace(regex, acronym);
  });
  return text;
}
```

**4. URL/邮箱/路径保护**
```typescript
function protectSpecialPatterns(text: string): {
  text: string;
  placeholders: Map<string, string>;
} {
  const placeholders = new Map<string, string>();
  let placeholderIndex = 0;
  
  // URL保护
  const urlRegex = /https?:\/\/[^\s]+/gi;
  text = text.replace(urlRegex, (match) => {
    const placeholder = `__URL_${placeholderIndex++}__`;
    placeholders.set(placeholder, match);
    return placeholder;
  });
  
  // 邮箱保护
  const emailRegex = /\b[\w.-]+@[\w.-]+\.\w+\b/gi;
  text = text.replace(emailRegex, (match) => {
    const placeholder = `__EMAIL_${placeholderIndex++}__`;
    placeholders.set(placeholder, match);
    return placeholder;
  });
  
  return { text, placeholders };
}
```

---

## 三、实施优先级建议

### Phase 1：服务包定义与服务发现（2周）

1. ✅ **服务包结构定义**
   - 定义`semantic-repair-zh`服务包（中文优化模型）
   - 定义`semantic-repair-en`服务包（英文优化模型）
   - 定义`en-normalize`服务包（无模型）
   - 编写`service.json`配置文件

2. ✅ **服务发现机制**
   - 扩展`ServicesHandler.getInstalledSemanticRepairServices()`
   - 扩展服务类型映射
   - 实现服务健康检查

### Phase 2：基础功能实现（2-3周）

3. ✅ **英文Normalize Stage**（不需要LLM，成本低）
   - 文本规范化
   - 缩写保护
   - URL/邮箱保护
   - 预期收益：修复20-30%的英文ASR错误

4. ✅ **中文SemanticRepairStage基础版**
   - 仅质量分触发（`quality_score < 0.7`）
   - 服务发现集成
   - 基础prompt
   - 超时和降级机制
   - 预期收益：修复30-40%的低质量中文ASR错误

### Phase 3：增强版本（2-3周）

5. ✅ **触发策略增强**
   - 短句+异常词形检测
   - 可翻译性检查
   - 英文SemanticRepairStage

6. ✅ **与NMT Repair协调**
   - 语义修复优先策略
   - NMT Repair降级为兜底

### Phase 4：优化版本（2周）

7. ✅ **性能优化**
   - 批处理
   - 缓存机制
   - 模型量化优化

8. ✅ **REJECT机制**
   - REJECT决策实现
   - 降级策略（文字不播报等）

---

## 四、风险评估与对策

### 风险1：延迟增加导致用户体验下降

**风险等级**：中
**对策**：
- 严格控制触发率（仅低质量句触发）
- 设置严格超时（2秒）
- 超时自动降级（返回PASS）
- 监控P95/P99延迟，设置告警

### 风险2：误修复导致翻译质量下降

**风险等级**：中
**对策**：
- 严格的Minimal Edit prompt
- 置信度检查（< 0.5回退）
- 长度变化检查（> ±20%回退）
- 灰度上线，逐步扩大范围
- 人工抽样评估

### 风险3：成本爆炸（LLM调用成本）

**风险等级**：低（如果严格控制触发率）
**对策**：
- 高门槛触发（仅低质量句）
- 使用小模型（3B INT4量化）
- 集中式部署，资源池化
- 监控触发率，设置上限

### 风险4：服务可用性问题

**风险等级**：低
**对策**：
- 完善的错误处理和降级
- 服务健康检查
- 可选本地fallback
- 监控服务可用性

---

## 五、验收标准

### 功能验收

1. ✅ 语义修复服务正常响应
2. ✅ 触发策略正确（质量分、短句等）
3. ✅ 修复结果合理（Minimal Edit）
4. ✅ 超时和降级机制正常
5. ✅ 与NMT Repair协调正常

### 性能验收

1. ✅ P95延迟 < 500ms（触发修复时）
2. ✅ 触发率 < 20%（避免成本爆炸）
3. ✅ 服务可用性 > 99.5%

### 质量验收

1. ✅ 修复准确率 > 70%（人工抽样评估）
2. ✅ 误修复率 < 5%
3. ✅ 下游翻译质量提升（需要设计评估方法）

---

## 六、总结

### 方案可行性：✅ **高**

**核心优势**：
- 架构兼容性好，最小侵入
- 问题定位准确，在翻译前修复
- 可渐进式实施，风险可控

**关键补充点**：
1. **架构集成**：在`PostProcessCoordinator`的`AggregationStage`之后插入
2. **服务部署**：基于服务发现的服务包机制，用户选择性安装
3. **触发策略**：需要细化实现（异常词形检测、句法检查等）
4. **LLM部署**：Qwen2.5-3B INT4量化，包含在服务包中
5. **模型独立性**：中英文使用不同的优化模型
6. **协调机制**：语义修复优先，NMT Repair降级为兜底
7. **延迟控制**：严格超时（2秒），自动降级
8. **可观测性**：完整的日志和指标采集
9. **服务发现**：通过`ServiceRegistryManager`自动检测已安装的服务

**建议**：
1. **优先实施服务包机制**：建立服务发现和自动启用机制
2. **优先实施英文Normalize Stage**（成本低、收益高）
3. **逐步上线语义修复功能**：先中文，后英文
4. **渐进式优化**：根据实际使用情况优化模型和参数
