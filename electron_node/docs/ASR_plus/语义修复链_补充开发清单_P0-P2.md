# 语义修复链补充开发清单（P0 / P1 / P2）

> 目的：补齐当前“语义修复链路”在工程稳定性、可控性与可维护性上的缺口，作为**开工前必须确认的补充清单**。  
> 适用对象：Node / Scheduler / Semantic Repair Service / NMT Repair 相关模块的开发与评审。

---

## P0 — 开工前必须完成（阻断级）

### P0-1 服务健康检查必须为真实实现
**问题**
- 当前 `checkServiceHealth()` 返回硬编码 true，无法反映真实运行状态。
- 模型未加载 / 端口占用 / 进程假活都会被误判为“可用”。

**补充要求**
- Health Check 必须调用真实 `/health` HTTP 接口，或：
  - 进程存活 + 端口可连通 + 模型已 warm。
- 服务状态需至少区分：
  - `INSTALLED`
  - `RUNNING`
  - `HEALTHY`
  - `WARMED`

**验收标准**
- 语义修复服务未启动或模型未加载时，节点端不得启用 repair。
- 日志可明确看到状态切换原因。

---

### P0-2 PostProcessCoordinator 初始化时序保证
**问题**
- SemanticRepairStage 初始化为 async，但存在未 await 即开始处理 job 的风险。
- 前几条 job 行为不一致，难以复现与排查。

**补充要求**
- 二选一实现：
  1. Node 启动阶段 `await coordinator.init()` 后再处理任务；
  2. 惰性初始化 + once Promise gate（首次 process 等待 init）。

**验收标准**
- 任意 job 处理时，SemanticRepairStage 要么稳定可用，要么稳定不可用，不得抖动。

---

### P0-3 热插拔（reinitialize）并发安全
**问题**
- 服务安装/卸载触发 coordinator 重建，可能与 in-flight job 冲突。

**补充要求**
- 采用以下任一方案：
  - 版本化指针（旧任务继续用旧 coordinator，新任务使用新实例）
  - RWLock（reinit 写锁，process 读锁）
- 避免在 reinit 时整体替换 PostProcessCoordinator（优先只替换 repairStage）。

**验收标准**
- 服务热插拔期间不丢任务、不双写、不 panic。
- in-flight job 完整结束。

---

### P0-4 与 NMT Repair 的自动协调机制（语义修复优先，NMT Repair 作为兜底）
**问题**
- 若语义修复与 NMT Repair 同时触发，会导致双重修复与 GPU 阻塞。
- 需要确保语义修复服务不可用时，系统能够自动降级到 NMT Repair。

**补充要求**
- **自动识别模式**：根据已安装和运行的服务自动判断是否启用语义修复
  - 通过服务发现机制检测 `semantic-repair-zh` 或 `semantic-repair-en` 是否已安装且健康
  - 如果语义修复服务可用，优先使用语义修复
  - 如果语义修复服务不可用（未安装、未运行、服务崩溃），自动启用 NMT Repair 作为兜底
- **优先级策略**：在 TranslationStage 入口明确：
  - 若语义修复已应用且 `semantic_repair_applied == true && confidence >= threshold`：
    - 必须跳过 NMT Repair（避免双重修复）
  - 若语义修复未应用或置信度低（`confidence < threshold`）：
    - 自动启用 NMT Repair 作为兜底方案
  - 若语义修复服务不可用（服务崩溃、超时、错误）：
    - 自动降级到 NMT Repair，确保系统不中断
- **NMT Repair 优化**：
  - 当语义修复服务可用时，NMT Repair 候选数下调（建议 5 → 3）
  - 当语义修复服务不可用时，NMT Repair 候选数保持原值（5）
  - 增加超时保护（例如 10–15s）

**实现要点**
```typescript
// TranslationStage.process()
// 1. 检查语义修复是否已应用
const semanticRepairApplied = result.metrics?.repairApplied === true;
const semanticRepairConfidence = result.metrics?.repairConfidence || 0;

// 2. 检查语义修复服务是否可用（通过服务发现）
const semanticRepairServiceAvailable = await checkSemanticRepairServiceAvailable(job.src_lang);

// 3. 决定是否触发 NMT Repair
const shouldTriggerNMTRepair = 
  !semanticRepairApplied ||  // 语义修复未应用
  (semanticRepairApplied && semanticRepairConfidence < 0.7) ||  // 置信度低
  !semanticRepairServiceAvailable;  // 服务不可用（自动兜底）

if (shouldTriggerNMTRepair && shouldRepair) {
  // 根据语义修复服务可用性调整候选数
  const numCandidates = semanticRepairServiceAvailable ? 3 : 5;
  // 执行 NMT Repair...
}
```

**验收标准**
- 语义修复服务可用时，优先使用语义修复，跳过 NMT Repair
- 语义修复服务不可用时，自动启用 NMT Repair 作为兜底
- 语义修复服务崩溃时，系统自动降级到 NMT Repair，不中断服务
- 任意一句文本最多只经历一次"重修复路径"
- 修复路径在日志中清晰可见（包含服务可用性状态）

---

### P0-5 端口与资源冲突处理
**问题**
- service.json 固定端口易冲突。
- 多模型并发易打满 GPU/CPU。

**补充要求**
- 支持端口 = 0（随机）或端口池探测。
- service.json 增加：
  - `gpu_required`
  - `vram_estimate`
  - `max_concurrency`
- TaskRouter 层需限制语义修复并发（建议 1–2）。

**验收标准**
- 端口冲突时可自动恢复。
- 高并发下不因 repair 阻塞 NMT/TTS。

---

## P1 — 强烈建议（首版上线即可带来显著收益）

### P1-1 触发逻辑改为“打分器”而非布尔条件
**补充要求**
- 将 low_quality / short_sentence / garbage_chars 等合并为 score。
- 输出 `reason_codes` 用于调试与统计。

**收益**
- 更易调参、灰度与 A/B。
- 降低误触发与漏触发。

---

### P1-2 Prompt 与输出校验增强
**补充要求**
- Prompt 明确：
  - 数字 / 日期 / 单位 / URL / 邮箱 / 路径不可被修改。
- 输出侧增加校验：
  - 数字/URL 缺失 → 回退 PASS。
  - 长度变化超过 ±20% → 回退 PASS。

**收益**
- 防止“修复模型编造内容”。
- 保护专业参数与版本号。

---

### P1-3 REJECT 语义分级
**补充要求**
- 不建议只有 `shouldSend=false`。
- 至少定义：
  - `REJECT_SOFT`：不修复但继续翻译或仅文本输出
  - `REJECT_HARD`：极端垃圾文本才丢弃

**收益**
- 避免实时对话“断句/静默”。

---

## P2 — 可后置（建议进入 Backlog）

### P2-1 语义修复结果缓存
**补充要求**
- Cache Key：
  - `(lang + text_in + model_version)`
- TTL：短（如 5–10 分钟）

**收益**
- 降低重复调用成本。
- 稳定同句多次出现的一致性。

---

### P2-2 服务包与模型完整性校验
**补充要求**
- 服务包 hash / 签名校验。
- 模型文件校验（防损坏假可用）。

**收益**
- 降低供应链与运行时风险。

---

## 建议作为“开工门槛”的最小集合
> 未完成以下 5 项不建议进入大规模开发：

1. P0-1 健康检查真实化  
2. P0-2 初始化时序保证  
3. P0-3 热插拔并发安全  
4. P0-4 与 NMT Repair 的互斥  
5. P0-5 端口与资源控制  

---

## 建议下一步
- 将 P0/P1 条目拆分为 JIRA Tasks（含验收标准）。
- P2 条目进入 Backlog，不阻塞首版上线。
