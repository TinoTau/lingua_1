# 语义修复链开发任务清单

> 基于 `ASR_plus` 目录下的技术文档整理  
> 目标：实现基于服务发现的语义修复机制，支持中英文独立安装和自动启用

---

## 一、任务分类

- **P0**：阻断级，开工前必须完成
- **P1**：强烈建议，首版上线即可带来显著收益
- **P2**：可后置，建议进入 Backlog

---

## 二、P0 任务（阻断级）

### P0-1 服务健康检查真实实现

**任务描述**：
- 实现真实的语义修复服务健康检查机制
- 替换当前硬编码的 `checkServiceHealth()` 实现

**技术要求**：
- Health Check 必须调用真实 `/health` HTTP 接口
- 或检查：进程存活 + 端口可连通 + 模型已 warm
- 服务状态需至少区分：`INSTALLED`、`RUNNING`、`HEALTHY`、`WARMED`

**验收标准**：
- 语义修复服务未启动或模型未加载时，节点端不得启用 repair
- 日志可明确看到状态切换原因

**相关文档**：
- `语义修复链技术评估与补充.md` - 2.2 服务部署与调用方式
- `语义修复架构设计（评估版）.md` - 六、TaskRouter服务发现

**预估工作量**：3-5天

---

### P0-2 PostProcessCoordinator 初始化时序保证

**任务描述**：
- 确保 SemanticRepairStage 初始化完成后再处理 job
- 避免前几条 job 行为不一致的问题

**技术要求**：
- 二选一实现：
  1. Node 启动阶段 `await coordinator.init()` 后再处理任务
  2. 惰性初始化 + once Promise gate（首次 process 等待 init）

**验收标准**：
- 任意 job 处理时，SemanticRepairStage 要么稳定可用，要么稳定不可用，不得抖动

**相关文档**：
- `语义修复架构设计（评估版）.md` - 五、PostProcessCoordinator自动初始化

**预估工作量**：2-3天

---

### P0-3 热插拔（reinitialize）并发安全

**任务描述**：
- 实现服务安装/卸载时的安全重新初始化机制
- 避免与 in-flight job 冲突

**技术要求**：
- 采用以下任一方案：
  - 版本化指针（旧任务继续用旧 coordinator，新任务使用新实例）
  - RWLock（reinit 写锁，process 读锁）
- 避免在 reinit 时整体替换 PostProcessCoordinator（优先只替换 repairStage）

**验收标准**：
- 服务热插拔期间不丢任务、不双写、不 panic
- in-flight job 完整结束

**相关文档**：
- `语义修复架构设计（评估版）.md` - 五、PostProcessCoordinator自动初始化 - 5.2 服务状态变化监听

**预估工作量**：3-5天

---

### P0-4 与 NMT Repair 的自动协调机制（语义修复优先，NMT Repair 作为兜底）

**任务描述**：
- 实现语义修复与 NMT Repair 的自动协调机制
- 语义修复优先，NMT Repair 作为兜底方案
- 根据服务可用性自动切换

**技术要求**：
- **自动识别模式**：根据已安装和运行的服务自动判断
  - 通过服务发现机制检测语义修复服务是否可用
  - 如果语义修复服务可用，优先使用语义修复
  - 如果语义修复服务不可用（未安装、未运行、服务崩溃），自动启用 NMT Repair 作为兜底
- **优先级策略**：
  - 若语义修复已应用且置信度 >= threshold：跳过 NMT Repair
  - 若语义修复未应用或置信度低：自动启用 NMT Repair
  - 若语义修复服务不可用：自动降级到 NMT Repair
- **NMT Repair 优化**：
  - 语义修复服务可用时，候选数下调（5 → 3）
  - 语义修复服务不可用时，候选数保持原值（5）
  - 增加超时保护（10–15s）

**实现位置**：
- `translation-stage.ts` - `process()` 方法
- 需要接收语义修复结果（从 PostProcessCoordinator 传递）

**验收标准**：
- 语义修复服务可用时，优先使用语义修复，跳过 NMT Repair
- 语义修复服务不可用时，自动启用 NMT Repair 作为兜底
- 语义修复服务崩溃时，系统自动降级到 NMT Repair，不中断服务
- 任意一句文本最多只经历一次"重修复路径"
- 修复路径在日志中清晰可见（包含服务可用性状态）

**相关文档**：
- `语义修复链技术评估与补充.md` - 2.6 与现有NMT Repair的协调
- `ASR_SEMANTIC_REPAIR_CHAIN_ZH_INPUT.md` - 8. 与现有 NMT Repair 的协同
- `ASR_SEMANTIC_REPAIR_CHAIN_EN_INPUT.md` - 7. 与现有 NMT Repair 的关系

**预估工作量**：5-7天

---

### P0-5 端口与资源冲突处理

**任务描述**：
- 处理服务包端口冲突问题
- 管理多模型并发时的资源占用

**技术要求**：
- 支持端口 = 0（随机）或端口池探测
- service.json 增加：
  - `gpu_required`
  - `vram_estimate`
  - `max_concurrency`
- TaskRouter 层需限制语义修复并发（建议 1–2）

**验收标准**：
- 端口冲突时可自动恢复
- 高并发下不因 repair 阻塞 NMT/TTS

**相关文档**：
- `语义修复架构设计（评估版）.md` - 二、服务包定义

**预估工作量**：3-5天

---

### P0-6 服务发现机制实现

**任务描述**：
- 扩展 ServicesHandler 支持语义修复服务发现
- 实现自动检测已安装的语义修复服务

**技术要求**：
- 扩展 `ServicesHandler.getInstalledSemanticRepairServices()`
- 扩展服务类型映射（`semantic-repair-zh`、`semantic-repair-en`、`en-normalize`）
- 实现服务健康检查

**验收标准**：
- 能够准确检测已安装的语义修复服务
- 能够区分服务状态（已安装、运行中、健康）

**相关文档**：
- `语义修复架构设计（评估版）.md` - 三、服务发现机制

**预估工作量**：3-5天

---

### P0-7 PostProcessCoordinator 服务发现集成

**任务描述**：
- 修改 PostProcessCoordinator 支持基于服务发现的自动初始化
- 实现服务状态变化监听

**技术要求**：
- PostProcessCoordinator 构造函数接收 ServicesHandler
- 实现 `initializeSemanticRepairStage()` 方法（异步）
- 实现服务安装/卸载事件监听
- 实现自动重新初始化机制

**验收标准**：
- 根据已安装的服务自动初始化对应的 Stage
- 服务安装/卸载后自动重新初始化
- 初始化失败不影响其他功能

**相关文档**：
- `语义修复架构设计（评估版）.md` - 五、PostProcessCoordinator自动初始化

**预估工作量**：5-7天

---

### P0-8 TaskRouter 语义修复服务路由

**任务描述**：
- 扩展 TaskRouter 支持语义修复服务发现和路由
- 实现服务端点获取和降级机制

**技术要求**：
- 实现 `routeSemanticRepairTask()` 方法
- 扩展 ServiceSelector 支持语义修复服务选择
- 实现服务健康检查
- 实现降级机制（服务不可用时返回 PASS）

**验收标准**：
- 能够正确路由到已安装的语义修复服务
- 服务不可用时自动降级，不阻塞流程

**相关文档**：
- `语义修复架构设计（评估版）.md` - 六、TaskRouter服务发现

**预估工作量**：3-5天

---

### P0-9 SemanticRepairStage 实现

**任务描述**：
- 实现语义修复 Stage（语言感知路由）
- 实现中文和英文修复 Stage

**技术要求**：
- 实现 `SemanticRepairStage`（统一入口，语言路由）
- 实现 `SemanticRepairStageZH`（中文修复）
- 实现 `SemanticRepairStageEN`（英文修复）
- 实现 `EnNormalizeStage`（英文Normalize）

**验收标准**：
- 能够根据源语言正确路由到对应的 Stage
- 各 Stage 能够正确处理修复请求
- 错误时能够降级返回 PASS

**相关文档**：
- `语义修复架构设计（评估版）.md` - 四、架构设计
- `ASR_SEMANTIC_REPAIR_CHAIN_ZH_INPUT.md` - 4. 新增模块：SemanticRepairStage
- `ASR_SEMANTIC_REPAIR_CHAIN_EN_INPUT.md` - 4. 新增模块 A：EN Normalize Stage

**预估工作量**：7-10天

---

## 三、P1 任务（强烈建议）

### P1-1 触发逻辑改为"打分器"而非布尔条件

**任务描述**：
- 将多个触发条件合并为综合评分机制
- 输出详细的 reason_codes 用于调试和统计

**技术要求**：
- 将 low_quality / short_sentence / garbage_chars 等合并为 score
- 输出 `reason_codes` 用于调试与统计
- 支持可配置的阈值和权重

**收益**：
- 更易调参、灰度与 A/B
- 降低误触发与漏触发

**相关文档**：
- `语义修复链技术评估与补充.md` - 2.3 触发策略详细设计

**预估工作量**：3-5天

---

### P1-2 Prompt 与输出校验增强

**任务描述**：
- 增强 Prompt 约束，防止误修复
- 实现输出校验机制

**技术要求**：
- Prompt 明确：数字 / 日期 / 单位 / URL / 邮箱 / 路径不可被修改
- 输出侧增加校验：
  - 数字/URL 缺失 → 回退 PASS
  - 长度变化超过 ±20% → 回退 PASS

**收益**：
- 防止"修复模型编造内容"
- 保护专业参数与版本号

**相关文档**：
- `语义修复链技术评估与补充.md` - 2.5 Prompt设计
- `ASR_SEMANTIC_REPAIR_CHAIN_ZH_INPUT.md` - 6. Minimal Repair 实现方案
- `ASR_SEMANTIC_REPAIR_CHAIN_EN_INPUT.md` - 5. 新增模块 B：EN Semantic Gate + Minimal Repair

**预估工作量**：3-5天

---

### P1-3 REJECT 语义分级

**任务描述**：
- 实现 REJECT 的分级处理机制
- 避免实时对话"断句/静默"

**技术要求**：
- 至少定义：
  - `REJECT_SOFT`：不修复但继续翻译或仅文本输出
  - `REJECT_HARD`：极端垃圾文本才丢弃

**收益**：
- 避免实时对话"断句/静默"

**相关文档**：
- `ASR_SEMANTIC_REPAIR_CHAIN_ZH_INPUT.md` - 5.2 REJECT 条件
- `ASR_SEMANTIC_REPAIR_CHAIN_EN_INPUT.md` - 5.4 REJECT 与降级

**预估工作量**：2-3天

---

### P1-4 异常词形和句法检测实现

**任务描述**：
- 实现中文和英文的异常检测逻辑
- 补充触发策略的具体实现

**技术要求**：
- 实现 `countNonChineseChars()` - 非中文字符统计
- 实现 `hasBasicSyntax()` - 基本句法检查（动词/实体检测）
- 实现 `hasGarbageChars()` - 乱码检测（可复用现有代码）
- 实现英文的异常检测（片段化、结构异常等）

**验收标准**：
- 能够准确检测异常词形和句法问题
- 触发策略准确，误触发率低

**相关文档**：
- `语义修复链技术评估与补充.md` - 2.3 触发策略详细设计

**预估工作量**：5-7天

---

## 四、P2 任务（可后置）

### P2-1 语义修复结果缓存

**任务描述**：
- 实现修复结果缓存机制
- 降低重复调用成本

**技术要求**：
- Cache Key：`(lang + text_in + model_version)`
- TTL：短（如 5–10 分钟）

**收益**：
- 降低重复调用成本
- 稳定同句多次出现的一致性

**相关文档**：
- `语义修复链技术评估与补充.md` - 2.4 LLM模型选择与部署 - 性能优化

**预估工作量**：2-3天

---

### P2-2 服务包与模型完整性校验

**任务描述**：
- 实现服务包和模型文件的完整性校验
- 降低供应链与运行时风险

**技术要求**：
- 服务包 hash / 签名校验
- 模型文件校验（防损坏假可用）

**收益**：
- 降低供应链与运行时风险

**预估工作量**：3-5天

---

### P2-3 批处理优化

**任务描述**：
- 实现语义修复请求的批处理机制
- 提高 GPU 利用率

**技术要求**：
- 设计批处理接口
- 实现请求合并和分发
- 控制批处理大小和超时

**收益**：
- 提高 GPU 利用率
- 降低延迟（平均）

**相关文档**：
- `语义修复链技术评估与补充.md` - 2.4 LLM模型选择与部署 - 性能优化

**预估工作量**：5-7天

---

## 五、任务依赖关系

```
P0-6 (服务发现机制)
  ↓
P0-7 (PostProcessCoordinator集成)
  ↓
P0-9 (SemanticRepairStage实现)
  ↓
P0-4 (NMT Repair协调) ← 依赖 P0-9
  ↓
P0-8 (TaskRouter路由) ← 依赖 P0-6
  ↓
P0-1 (健康检查) ← 依赖 P0-8
  ↓
P0-2 (初始化时序) ← 依赖 P0-7
  ↓
P0-3 (热插拔安全) ← 依赖 P0-7
  ↓
P0-5 (端口资源) ← 并行开发
```

---

## 六、实施建议

### Phase 1：基础架构（2-3周）

**必须完成**：
1. P0-6：服务发现机制实现
2. P0-7：PostProcessCoordinator 服务发现集成
3. P0-8：TaskRouter 语义修复服务路由
4. P0-1：服务健康检查真实实现

**目标**：建立服务发现和路由机制

---

### Phase 2：核心功能（3-4周）

**必须完成**：
1. P0-9：SemanticRepairStage 实现
   - 先实现 EnNormalizeStage（不需要LLM，成本低）
   - 再实现 SemanticRepairStageZH（中文修复）
   - 最后实现 SemanticRepairStageEN（英文修复）
2. P0-4：与 NMT Repair 的自动协调机制
3. P0-2：初始化时序保证
4. P0-3：热插拔并发安全

**目标**：实现核心修复功能

---

### Phase 3：稳定性和优化（2-3周）

**必须完成**：
1. P0-5：端口与资源冲突处理
2. P1-1：触发逻辑改为打分器
3. P1-2：Prompt 与输出校验增强
4. P1-4：异常词形和句法检测实现

**目标**：提升稳定性和准确性

---

### Phase 4：增强功能（可选，1-2周）

**可选完成**：
1. P1-3：REJECT 语义分级
2. P2-1：语义修复结果缓存
3. P2-2：服务包与模型完整性校验

**目标**：增强功能和可靠性

---

## 七、关键里程碑

### Milestone 1：服务发现机制完成
- ✅ P0-6 完成
- ✅ P0-7 完成
- ✅ P0-8 完成
- **验收**：能够检测已安装的服务并正确路由

### Milestone 2：核心功能完成
- ✅ P0-9 完成（至少 EnNormalizeStage）
- ✅ P0-4 完成
- ✅ P0-2 完成
- ✅ P0-3 完成
- **验收**：能够进行语义修复，并与 NMT Repair 协调

### Milestone 3：稳定性完成
- ✅ P0-1 完成
- ✅ P0-5 完成
- ✅ P1-1 完成
- ✅ P1-2 完成
- **验收**：系统稳定运行，误修复率低

---

## 八、风险提示

1. **服务发现机制稳定性**：需要确保服务发现机制稳定可靠，避免误判
2. **NMT Repair 协调复杂性**：需要仔细设计协调逻辑，避免双重修复
3. **热插拔并发安全**：需要充分测试，避免数据竞争
4. **模型加载时间**：需要考虑模型加载对启动时间的影响

---

## 九、总结

**P0 任务总数**：9个
**P1 任务总数**：4个
**P2 任务总数**：3个

**建议开工门槛**（必须完成）：
1. P0-1：服务健康检查真实实现
2. P0-2：初始化时序保证
3. P0-3：热插拔并发安全
4. P0-4：与 NMT Repair 的自动协调机制
5. P0-5：端口与资源控制
6. P0-6：服务发现机制实现
7. P0-7：PostProcessCoordinator 服务发现集成
8. P0-8：TaskRouter 语义修复服务路由
9. P0-9：SemanticRepairStage 实现

**预估总工作量**：P0 任务约 35-50 天，P1 任务约 13-20 天，P2 任务约 10-15 天
