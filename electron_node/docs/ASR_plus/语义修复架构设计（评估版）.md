# 语义修复架构设计（最终版）

## 一、设计理念

**核心思想**：语义修复服务作为**独立服务包**，用户可以选择性安装。系统通过**服务发现机制**自动检测已安装的服务，并启用对应的功能。

**与现有架构一致**：
- 遵循现有的服务注册表机制（`ServiceRegistryManager`）
- 类似ASR、NMT、TTS服务的发现和启用方式
- 用户安装服务包 → 系统自动检测 → 自动启用功能
- **无需配置开关**：功能启用由已安装的服务决定，配置文件只用于高级参数调整

---

## 二、服务包定义

### 2.1 服务包结构

#### 中文语义修复服务包
```
semantic-repair-zh/
  ├─ service.json
  ├─ models/
  │   └─ qwen2.5-3b-instruct-zh/  (中文优化模型，INT4量化)
  └─ platforms/
      ├─ windows/
      ├─ linux/
      └─ darwin/
```

**service.json**：
```json
{
  "service_id": "semantic-repair-zh",
  "name": "中文语义修复服务",
  "version": "1.0.0",
  "type": "semantic-repair",
  "lang": "zh",
  "description": "用于修复中文ASR识别错误的语义修复服务",
  "model": {
    "name": "qwen2.5-3b-instruct",
    "variant": "zh-optimized",  // 中文优化版本
    "quantization": "int4",
    "size_gb": 2.0
  },
  "platforms": {
    "windows": {
      "default_port": 5015,
      "command": "python",
      "args": ["-m", "semantic_repair_zh.main"],
      "env": {
        "MODEL_PATH": "${SERVICE_DIR}/models/qwen2.5-3b-instruct-zh",
        "MODEL_QUANTIZATION": "int4"
      }
    },
    "linux": { ... },
    "darwin": { ... }
  }
}
```

**模型说明**：
- **推荐模型**：Qwen2.5-3B-Instruct（中文优化版本，INT4量化）
- **显存需求**：~2GB
- **推理速度**：50-200ms/句（取决于硬件）
- **商用许可**：✅
- **备选模型**：Qwen2.5-7B-Instruct（增强版，显存~4GB，速度100-500ms/句）

#### 英文语义修复服务包
```
semantic-repair-en/
  ├─ service.json
  ├─ models/
  │   └─ qwen2.5-3b-instruct-en/  (英文优化模型，或英文专用小模型)
  └─ platforms/
      ├─ windows/
      ├─ linux/
      └─ darwin/
```

**service.json**：
```json
{
  "service_id": "semantic-repair-en",
  "name": "英文语义修复服务",
  "version": "1.0.0",
  "type": "semantic-repair",
  "lang": "en",
  "description": "用于修复英文ASR识别错误的语义修复服务",
  "model": {
    "name": "qwen2.5-3b-instruct",
    "variant": "en-optimized",  // 英文优化版本，或多语言版本
    "quantization": "int4",
    "size_gb": 2.0,
    "alternative": "small-english-model-1b"  // 可选：更小的英文专用模型
  },
  "platforms": {
    "windows": {
      "default_port": 5016,
      "command": "python",
      "args": ["-m", "semantic_repair_en.main"],
      "env": {
        "MODEL_PATH": "${SERVICE_DIR}/models/qwen2.5-3b-instruct-en",
        "MODEL_QUANTIZATION": "int4"
      }
    },
    "linux": { ... },
    "darwin": { ... }
  }
}
```

**模型说明**：
- **推荐模型**：Qwen2.5-3B-Instruct（多语言版本，英文优化，INT4量化）
- **备选模型**：更小的英文专用模型（1-2B，显存~1GB，速度更快）
- **显存需求**：~2GB（3B模型）或 ~1GB（1-2B模型）
- **推理速度**：30-150ms/句（1-2B模型）或 50-200ms/句（3B模型）

**注意**：中英文服务包使用**不同的模型**，可以根据语言特点优化：
- 中文模型：针对同音字、近音词优化
- 英文模型：针对缩写、专有名词、数字单位优化

#### 英文Normalize服务包（可选，轻量级）
```
en-normalize/
  ├─ service.json
  └─ platforms/
      ├─ windows/
      ├─ linux/
      └─ darwin/
```

**service.json**：
```json
{
  "service_id": "en-normalize",
  "name": "英文文本规范化服务",
  "version": "1.0.0",
  "type": "semantic-repair",
  "lang": "en",
  "subtype": "normalize",  // 标识为Normalize服务（不需要LLM）
  "description": "英文文本规范化服务（缩写保护、URL保护等，不需要LLM）",
  "model": null,  // 不需要模型
  "platforms": {
    "windows": {
      "default_port": 5017,
      "command": "python",
      "args": ["-m", "en_normalize.main"]
    },
    "linux": { ... },
    "darwin": { ... }
  }
}
```

**特点**：
- **无模型依赖**：纯规则和正则表达式处理
- **极低延迟**：< 5ms
- **零成本**：不需要GPU，CPU即可
- **预期收益**：修复20-30%的英文ASR错误

---

## 三、服务发现机制

### 3.1 扩展ServicesHandler

```typescript
// node-agent-services.ts 扩展
export class ServicesHandler {
  // ... 现有代码
  
  /**
   * 检测已安装的语义修复服务
   */
  async getInstalledSemanticRepairServices(): Promise<{
    zh: boolean;           // 是否安装了中文修复服务
    en: boolean;           // 是否安装了英文修复服务
    enNormalize: boolean;  // 是否安装了英文Normalize服务
  }> {
    const result = {
      zh: false,
      en: false,
      enNormalize: false,
    };
    
    // 从服务注册表获取已安装的服务
    if (this.serviceRegistryManager) {
      try {
        await this.serviceRegistryManager.loadRegistry();
        const installed = this.serviceRegistryManager.listInstalled();
        
        for (const service of installed) {
          if (service.service_id === 'semantic-repair-zh') {
            result.zh = this.isServiceRunning('semantic-repair-zh');
          } else if (service.service_id === 'semantic-repair-en') {
            result.en = this.isServiceRunning('semantic-repair-en');
          } else if (service.service_id === 'en-normalize') {
            result.enNormalize = this.isServiceRunning('en-normalize');
          }
        }
      } catch (error) {
        logger.error({ error }, 'Failed to get installed semantic repair services');
      }
    }
    
    return result;
  }
  
  /**
   * 检查语义修复服务是否运行
   */
  isSemanticRepairServiceRunning(serviceId: string): boolean {
    // 可以通过HTTP健康检查或进程检查
    if (serviceId === 'semantic-repair-zh' || 
        serviceId === 'semantic-repair-en' || 
        serviceId === 'en-normalize') {
      // 检查服务是否在运行（可以通过HTTP健康检查）
      // 实际实现应该检查服务健康状态
      return this.checkServiceHealth(serviceId);
    }
    return false;
  }
  
  private checkServiceHealth(serviceId: string): boolean {
    // 实现HTTP健康检查
    // 或通过ServiceRuntimeManager检查进程状态
    // 这里简化处理
    return true;
  }
}
```

### 3.2 扩展服务类型映射

```typescript
// node-agent-services.ts
const serviceTypeMap: Record<string, ServiceType> = {
  'faster-whisper-vad': ServiceType.ASR,
  'node-inference': ServiceType.ASR,
  'nmt-m2m100': ServiceType.NMT,
  'piper-tts': ServiceType.TTS,
  'speaker-embedding': ServiceType.TONE,
  'your-tts': ServiceType.TONE,
  // 新增：语义修复服务
  'semantic-repair-zh': ServiceType.ASR,  // 或新增 ServiceType.SEMANTIC_REPAIR
  'semantic-repair-en': ServiceType.ASR,
  'en-normalize': ServiceType.ASR,
};
```

---

## 四、架构设计

### 4.1 整体架构

```
PostProcessCoordinator
  ├─ AggregationStage (固定)
  ├─ [可插拔] SemanticRepairStage (语言感知路由，基于服务发现)
  │   ├─ SemanticRepairStageZH (中文修复，如果服务已安装)
  │   ├─ EnNormalizeStage (英文Normalize，如果服务已安装)
  │   └─ SemanticRepairStageEN (英文修复，如果服务已安装)
  ├─ TranslationStage (固定)
  ├─ DedupStage (固定)
  └─ TTSStage (固定)
```

### 4.2 核心设计：语言感知的Stage路由

**设计思路**：`SemanticRepairStage`作为统一入口，根据`src_lang`和已安装的服务路由到对应的语言特定Stage。

```typescript
// semantic-repair-stage.ts
export class SemanticRepairStage {
  private zhStage: SemanticRepairStageZH | null = null;
  private enStage: SemanticRepairStageEN | null = null;
  private enNormalizeStage: EnNormalizeStage | null = null;
  
  constructor(
    private taskRouter: TaskRouter | null,
    private config: SemanticRepairConfig  // 仅包含参数，不包含enabled
  ) {
    // 根据已安装的服务初始化各语言Stage
    // 注意：enabled状态由服务发现决定，不在config中
    if (config.zh) {
      this.zhStage = new SemanticRepairStageZH(taskRouter, config.zh);
    }
    
    if (config.en) {
      if (config.en.normalize) {
        this.enNormalizeStage = new EnNormalizeStage(config.en.normalize);
      }
      if (config.en.repair) {
        this.enStage = new SemanticRepairStageEN(taskRouter, config.en.repair);
      }
    }
  }
  
  async process(
    job: JobAssignMessage,
    aggregatedText: string,
    qualityScore?: number,
    meta?: any
  ): Promise<SemanticRepairResult> {
    const srcLang = job.src_lang;
    
    // 根据源语言路由到对应的Stage
    if (srcLang === 'zh' && this.zhStage) {
      return await this.zhStage.process(job, aggregatedText, qualityScore, meta);
    } else if (srcLang === 'en') {
      // 英文链路：先Normalize，再Repair
      let text = aggregatedText;
      if (this.enNormalizeStage) {
        const normalizeResult = this.enNormalizeStage.process(text);
        text = normalizeResult.text;
      }
      if (this.enStage) {
        return await this.enStage.process(job, text, qualityScore, meta);
      }
      // 如果只有Normalize没有Repair，返回Normalize结果
      if (this.enNormalizeStage) {
        return {
          decision: 'PASS',
          text_out: text,
          confidence: 1.0,
          reason_codes: []
        };
      }
    }
    
    // 未安装对应服务或语言不支持，返回PASS
    return {
      decision: 'PASS',
      text_out: aggregatedText,
      confidence: 1.0,
      reason_codes: ['SERVICE_NOT_INSTALLED_OR_UNSUPPORTED_LANG']
    };
  }
}
```

---

## 五、PostProcessCoordinator自动初始化

### 5.1 基于服务发现的初始化

```typescript
// postprocess-coordinator.ts
export class PostProcessCoordinator {
  private semanticRepairStage: SemanticRepairStage | null = null;
  
  constructor(
    private aggregatorManager: AggregatorManager | null,
    private taskRouter: TaskRouter | null,
    private servicesHandler: ServicesHandler | null,  // 新增：用于服务发现
    config?: PostProcessConfig
  ) {
    const nodeConfig = loadNodeConfig();
    this.enablePostProcessTranslation = nodeConfig.features?.enablePostProcessTranslation ?? true;
    
    // 初始化各 Stage
    this.aggregationStage = new AggregationStage(aggregatorManager);
    this.dedupStage = new DedupStage();
    
    // 自动检测并初始化语义修复Stage
    this.initializeSemanticRepairStage();
    
    // ... 其他Stage初始化
  }
  
  /**
   * 自动检测已安装的语义修复服务并初始化Stage
   */
  private async initializeSemanticRepairStage(): Promise<void> {
    if (!this.servicesHandler || !this.taskRouter) {
      logger.debug({}, 'PostProcessCoordinator: ServicesHandler or TaskRouter not available, skipping semantic repair initialization');
      return;
    }
    
    try {
      // 检测已安装的语义修复服务
      const installedServices = await this.servicesHandler.getInstalledSemanticRepairServices();
      
      if (!installedServices.zh && !installedServices.en && !installedServices.enNormalize) {
        logger.info({}, 'PostProcessCoordinator: No semantic repair services installed, skipping initialization');
        return;
      }
      
      // 读取配置（仅用于高级参数，如阈值、超时等）
      const nodeConfig = loadNodeConfig();
      const repairConfig = nodeConfig.features?.semanticRepair || {};
      
      // 根据已安装的服务构建配置（不包含enabled字段）
      const semanticRepairConfig: SemanticRepairConfig = {
        zh: installedServices.zh ? {
          // 注意：不包含enabled字段，因为服务已安装即表示启用
          qualityThreshold: repairConfig.zh?.qualityThreshold || 0.7,
          shortSentenceThreshold: repairConfig.zh?.shortSentenceThreshold || 16,
          timeoutMs: repairConfig.zh?.timeoutMs || 2000,
          rejectEnabled: repairConfig.zh?.rejectEnabled || false,
        } : undefined,
        en: (installedServices.en || installedServices.enNormalize) ? {
          normalize: installedServices.enNormalize ? {
            // 不包含enabled字段
            protectAcronyms: repairConfig.en?.normalize?.protectAcronyms !== false,
            protectUrls: repairConfig.en?.normalize?.protectUrls !== false,
            normalizeNumbers: repairConfig.en?.normalize?.normalizeNumbers || false,
          } : undefined,
          repair: installedServices.en ? {
            // 不包含enabled字段
            qualityThreshold: repairConfig.en?.repair?.qualityThreshold || 0.7,
            timeoutMs: repairConfig.en?.repair?.timeoutMs || 2000,
          } : undefined,
        } : undefined,
      };
      
      // 初始化语义修复Stage
      this.semanticRepairStage = new SemanticRepairStage(
        this.taskRouter,
        semanticRepairConfig
      );
      
      logger.info(
        {
          zhEnabled: installedServices.zh,
          enRepairEnabled: installedServices.en,
          enNormalizeEnabled: installedServices.enNormalize,
        },
        'PostProcessCoordinator: SemanticRepairStage initialized based on installed services'
      );
    } catch (error) {
      logger.error({ error }, 'PostProcessCoordinator: Failed to initialize semantic repair stage');
      // 失败时不影响其他功能，继续初始化
    }
  }
  
  async process(job: JobAssignMessage, result: JobResult): Promise<PostProcessResult> {
    // ... Stage 1: Aggregation
    
    // Stage 1.5: 语义修复（可插拔）
    let textForTranslation = aggregationResult.aggregatedText;
    let repairMetrics: any = {};
    
    if (this.semanticRepairStage) {
      try {
        const repairStartTime = Date.now();
        const repairResult = await this.semanticRepairStage.process(
          job,
          aggregationResult.aggregatedText,
          result.quality_score,
          {
            segments: result.segments,
            language_probability: result.extra?.language_probability,
            reason_codes: result.reason_codes
          }
        );
        const repairDuration = Date.now() - repairStartTime;
        
        if (repairResult.decision === 'REPAIR') {
          textForTranslation = repairResult.text_out;
          repairMetrics = {
            repairApplied: true,
            repairDurationMs: repairDuration,
            repairConfidence: repairResult.confidence,
            repairReasonCodes: repairResult.reason_codes,
            repairDiffCount: repairResult.diff?.length || 0,
          };
          
          logger.info(
            {
              jobId: job.job_id,
              sessionId: job.session_id,
              srcLang: job.src_lang,
              originalText: aggregationResult.aggregatedText.substring(0, 50),
              repairedText: repairResult.text_out.substring(0, 50),
              confidence: repairResult.confidence,
              durationMs: repairDuration,
            },
            'PostProcessCoordinator: Semantic repair applied'
          );
        } else if (repairResult.decision === 'REJECT') {
          // REJECT处理：返回空结果，不进行翻译
          logger.warn(
            {
              jobId: job.job_id,
              sessionId: job.session_id,
              reasonCodes: repairResult.reason_codes,
            },
            'PostProcessCoordinator: Semantic repair rejected text'
          );
          return {
            shouldSend: false,
            aggregatedText: aggregationResult.aggregatedText,
            translatedText: '',
            ttsAudio: '',
            ttsFormat: 'opus',
            reason: `Semantic repair rejected: ${repairResult.reason_codes.join(', ')}`,
          };
        } else {
          // PASS：使用原文
          repairMetrics = {
            repairApplied: false,
            repairDurationMs: repairDuration,
            repairReasonCodes: repairResult.reason_codes,
          };
        }
      } catch (error) {
        // 修复失败，降级使用原文
        logger.error(
          {
            error,
            jobId: job.job_id,
            sessionId: job.session_id,
          },
          'PostProcessCoordinator: Semantic repair failed, using original text'
        );
        // 继续使用原文，不阻塞流程
      }
    }
    
    // Stage 2: 翻译（使用修复后的文本）
    if (needsTranslation && this.translationStage) {
      translationResult = await this.translationStage.process(
        job,
        textForTranslation,  // 使用修复后的文本
        result.quality_score,
        aggregationResult.metrics?.dedupCharsRemoved || 0
      );
    }
    
    // ... 其他Stage
  }
}
```

### 5.2 服务状态变化监听

```typescript
// node-agent.ts
export class NodeAgent {
  constructor(...) {
    // ... 现有初始化
    
    // 监听服务状态变化，重新初始化PostProcessCoordinator
    if (this.serviceRegistryManager) {
      // 监听服务安装/卸载事件
      this.serviceRegistryManager.on('service-installed', (serviceId: string) => {
        if (serviceId.startsWith('semantic-repair-') || serviceId === 'en-normalize') {
          logger.info({ serviceId }, 'Semantic repair service installed, reinitializing PostProcessCoordinator');
          this.reinitializePostProcessCoordinator();
        }
      });
      
      this.serviceRegistryManager.on('service-uninstalled', (serviceId: string) => {
        if (serviceId.startsWith('semantic-repair-') || serviceId === 'en-normalize') {
          logger.info({ serviceId }, 'Semantic repair service uninstalled, reinitializing PostProcessCoordinator');
          this.reinitializePostProcessCoordinator();
        }
      });
    }
  }
  
  private reinitializePostProcessCoordinator(): void {
    // 重新创建PostProcessCoordinator（会重新检测已安装的服务）
    const taskRouter = (this.inferenceService as any).taskRouter;
    const aggregatorManager = (this.aggregatorMiddleware as any).manager;
    const servicesHandler = this.servicesHandler;
    
    const postProcessConfig: PostProcessConfig = {
      enabled: true,
      translationConfig: {
        // ... 从配置读取
      },
    };
    
    this.postProcessCoordinator = new PostProcessCoordinator(
      aggregatorManager,
      taskRouter,
      servicesHandler,  // 传递ServicesHandler用于服务发现
      postProcessConfig
    );
    
    // 更新JobProcessor的引用
    this.jobProcessor.updatePostProcessCoordinator(this.postProcessCoordinator);
  }
}
```

---

## 六、TaskRouter服务发现

### 6.1 扩展TaskRouter支持语义修复服务

```typescript
// task-router.ts
export class TaskRouter {
  // ... 现有代码
  
  /**
   * 路由语义修复任务
   * 自动从ServiceRegistryManager发现服务
   */
  async routeSemanticRepairTask(
    request: SemanticRepairRequest
  ): Promise<SemanticRepairResponse> {
    const serviceId = request.lang === 'zh' 
      ? 'semantic-repair-zh' 
      : 'semantic-repair-en';
    
    // 从服务注册表获取服务端点
    const endpoint = await this.serviceSelector.selectSemanticRepairService(
      serviceId,
      request.lang
    );
    
    if (!endpoint) {
      // 服务不可用，降级返回PASS
      logger.warn(
        { serviceId, lang: request.lang },
        'Semantic repair service not available, returning PASS'
      );
      return {
        decision: 'PASS',
        text_out: request.text_in,
        confidence: 0.0,
        reason_codes: ['SERVICE_NOT_AVAILABLE']
      };
    }
    
    // HTTP调用修复服务
    const url = `${endpoint.baseUrl}/v1/repair`;
    try {
      const response = await this.httpClient.post(url, request, {
        timeout: request.timeoutMs || 2000,
      });
      return response.data;
    } catch (error) {
      // 服务错误，降级返回PASS
      logger.error({ error, serviceId }, 'Semantic repair service error, returning PASS');
      return {
        decision: 'PASS',
        text_out: request.text_in,
        confidence: 0.0,
        reason_codes: ['SERVICE_ERROR']
      };
    }
  }
}
```

### 6.2 ServiceSelector扩展

```typescript
// task-router-service-selector.ts
export class ServiceSelector {
  // ... 现有代码
  
  /**
   * 选择语义修复服务
   */
  async selectSemanticRepairService(
    serviceId: string,
    lang: string
  ): Promise<ServiceEndpoint | null> {
    // 从服务注册表获取已安装的服务
    const installedServices = await this.serviceRegistryManager.listInstalled();
    const service = installedServices.find(s => s.service_id === serviceId);
    
    if (!service) {
      return null;  // 服务未安装
    }
    
    // 检查服务是否运行
    const isRunning = await this.checkServiceRunning(serviceId);
    if (!isRunning) {
      return null;  // 服务未运行
    }
    
    // 获取服务端点（从服务注册表或配置）
    const endpoint = await this.getServiceEndpoint(serviceId);
    return endpoint;
  }
  
  private async checkServiceRunning(serviceId: string): Promise<boolean> {
    // 可以通过HTTP健康检查
    const endpoint = await this.getServiceEndpoint(serviceId);
    if (!endpoint) return false;
    
    try {
      const response = await this.httpClient.get(`${endpoint.baseUrl}/health`, {
        timeout: 1000,
      });
      return response.status === 200;
    } catch {
      return false;
    }
  }
}
```

---

## 七、配置文件设计（仅用于高级参数）

### 7.1 配置结构

```typescript
// node-config.ts
export interface SemanticRepairConfig {
  /** 中文修复高级参数（服务已安装时生效） */
  zh?: {
    qualityThreshold?: number;      // 质量分阈值（默认0.7）
    shortSentenceThreshold?: number; // 短句阈值（默认16）
    timeoutMs?: number;              // 超时时间（默认2000ms）
    rejectEnabled?: boolean;         // 是否启用REJECT（默认false）
  };
  
  /** 英文修复高级参数（服务已安装时生效） */
  en?: {
    normalize?: {
      protectAcronyms?: boolean;    // 是否保护缩写（默认true）
      protectUrls?: boolean;         // 是否保护URL（默认true）
      normalizeNumbers?: boolean;    // 是否规范化数字（默认false）
    };
    repair?: {
      qualityThreshold?: number;    // 质量分阈值（默认0.7）
      timeoutMs?: number;           // 超时时间（默认2000ms）
    };
  };
}
```

**关键点**：
- 配置文件中**不包含**`enabled`字段
- `enabled`状态由**服务发现机制**自动决定
- 配置文件只用于调整**参数**（阈值、超时等）

### 7.2 配置示例

```json
{
  "features": {
    "semanticRepair": {
      "zh": {
        "qualityThreshold": 0.65,  // 调整阈值（更敏感）
        "timeoutMs": 3000           // 调整超时（更宽松）
      },
      "en": {
        "normalize": {
          "protectAcronyms": true,
          "normalizeNumbers": true   // 启用数字规范化
        },
        "repair": {
          "qualityThreshold": 0.75   // 调整阈值
        }
      }
    }
  }
}
```

---

## 八、语言特定Stage实现

### 8.1 中文修复Stage

```typescript
// semantic-repair-stage-zh.ts
export class SemanticRepairStageZH {
  constructor(
    private taskRouter: TaskRouter | null,
    private config: SemanticRepairConfig['zh']
  ) {}
  
  async process(
    job: JobAssignMessage,
    text: string,
    qualityScore?: number,
    meta?: any
  ): Promise<SemanticRepairResult> {
    // 触发策略检查
    const shouldRepair = this.shouldTriggerRepair(text, qualityScore, meta);
    if (!shouldRepair.shouldRepair) {
      return {
        decision: 'PASS',
        text_out: text,
        confidence: 1.0,
        reason_codes: []
      };
    }
    
    // 调用修复服务
    try {
      const result = await this.taskRouter?.routeSemanticRepairTask({
        job_id: job.job_id,
        session_id: job.session_id,
        utterance_index: job.utterance_index,
        lang: 'zh',
        text_in: text,
        quality_score: qualityScore,
        micro_context: this.getMicroContext(job.session_id),
        meta: meta
      });
      
      return result || {
        decision: 'PASS',
        text_out: text,
        confidence: 0.0,
        reason_codes: ['SERVICE_ERROR']
      };
    } catch (error) {
      // 服务错误，降级返回PASS
      logger.error({ error }, 'SemanticRepairStageZH: Service error');
      return {
        decision: 'PASS',
        text_out: text,
        confidence: 0.0,
        reason_codes: ['SERVICE_ERROR']
      };
    }
  }
  
  private shouldTriggerRepair(
    text: string,
    qualityScore: number | undefined,
    meta: any
  ): { shouldRepair: boolean; reasonCodes: string[] } {
    const reasonCodes: string[] = [];
    const threshold = this.config?.qualityThreshold || 0.7;
    
    // 条件1：质量分触发
    if (qualityScore !== undefined && qualityScore < threshold) {
      reasonCodes.push('LOW_QUALITY_SCORE');
    }
    
    // 条件2：短句+异常词形
    const shortThreshold = this.config?.shortSentenceThreshold || 16;
    if (text.length <= shortThreshold) {
      // 异常检测逻辑
      const nonChineseRatio = countNonChineseChars(text) / text.length;
      if (nonChineseRatio > 0.3) {
        reasonCodes.push('HIGH_NON_CHINESE_RATIO');
      }
      if (!hasBasicSyntax(text)) {
        reasonCodes.push('MISSING_BASIC_SYNTAX');
      }
    }
    
    return {
      shouldRepair: reasonCodes.length > 0,
      reasonCodes
    };
  }
}
```

### 8.2 英文Normalize Stage

```typescript
// en-normalize-stage.ts
export class EnNormalizeStage {
  constructor(private config: SemanticRepairConfig['en']['normalize']) {}
  
  process(text: string): { text: string; flags: NormalizeFlags } {
    let normalized = text;
    const flags: NormalizeFlags = {
      hasAcronyms: false,
      hasUrls: false,
      hasNumbers: false,
      hasFragmentation: false,
    };
    
    // 1. 文本规范化
    normalized = this.normalizeText(normalized);
    
    // 2. 缩写保护
    if (this.config?.protectAcronyms !== false) {
      normalized = this.protectAcronyms(normalized);
      flags.hasAcronyms = this.hasAcronyms(normalized);
    }
    
    // 3. URL/邮箱保护
    if (this.config?.protectUrls !== false) {
      const result = this.protectSpecialPatterns(normalized);
      normalized = result.text;
      flags.hasUrls = result.hasUrls;
    }
    
    // 4. 数字规范化（可选）
    if (this.config?.normalizeNumbers) {
      normalized = this.normalizeNumbers(normalized);
      flags.hasNumbers = this.hasNumbers(normalized);
    }
    
    return { text: normalized, flags };
  }
  
  // ... 具体实现方法
}
```

### 8.3 英文修复Stage

```typescript
// semantic-repair-stage-en.ts
export class SemanticRepairStageEN {
  constructor(
    private taskRouter: TaskRouter | null,
    private config: SemanticRepairConfig['en']['repair']
  ) {}
  
  async process(
    job: JobAssignMessage,
    text: string,  // 已经过Normalize的文本
    qualityScore: number | undefined,
    meta: any
  ): Promise<SemanticRepairResult> {
    // 类似中文修复的逻辑
    // ...
  }
}
```

---

## 九、用户使用流程

### 9.1 安装服务包

**场景1：只安装中文修复服务**
```bash
# 用户通过UI或命令行安装服务包
install-service semantic-repair-zh

# 系统自动：
# 1. 下载服务包到 userData/services/
# 2. 注册到服务注册表
# 3. 检测到服务已安装
# 4. 自动初始化SemanticRepairStage（中文）
# 5. 中文ASR错误自动修复
```

**场景2：只安装英文Normalize服务**
```bash
install-service en-normalize

# 系统自动：
# 1. 注册服务
# 2. 检测到en-normalize已安装
# 3. 自动初始化EnNormalizeStage
# 4. 英文ASR错误自动修复（低成本）
```

**场景3：安装英文完整修复服务**
```bash
install-service en-normalize
install-service semantic-repair-en

# 系统自动：
# 1. 检测到两个服务已安装
# 2. 自动初始化EnNormalizeStage + SemanticRepairStageEN
# 3. 英文ASR错误完整修复
```

**场景4：同时安装中英文修复服务**
```bash
install-service semantic-repair-zh
install-service semantic-repair-en
install-service en-normalize

# 系统自动：
# 1. 检测到所有服务已安装
# 2. 自动初始化所有Stage
# 3. 中英文ASR错误自动修复
```

### 9.2 卸载服务包

```bash
# 卸载中文修复服务
uninstall-service semantic-repair-zh

# 系统自动：
# 1. 从服务注册表移除
# 2. 检测到服务已卸载
# 3. 重新初始化PostProcessCoordinator
# 4. 中文修复功能自动禁用
```

---

## 十、架构优势

### ✅ 完全基于服务发现
- 用户安装服务 → 系统自动启用
- 用户卸载服务 → 系统自动禁用
- 无需手动配置开关

### ✅ 灵活选择
- 可以只安装中文修复
- 可以只安装英文Normalize（低成本）
- 可以只安装英文完整修复
- 可以同时安装所有服务

### ✅ 与现有架构一致
- 遵循现有的服务注册表机制
- 类似ASR、NMT、TTS的发现方式
- 用户使用习惯一致

### ✅ 配置简化
- 配置文件只用于高级参数
- 不需要手动设置功能开关
- 降低配置错误风险

### ✅ 热插拔
- 安装/卸载服务后自动生效
- 无需重启节点
- 支持运行时动态调整

### ✅ 服务独立性
- 各修复服务独立部署
- 故障隔离（一个服务故障不影响其他）
- 独立扩展（可以单独扩容中文或英文服务）

### ✅ 模型独立性
- 中文和英文使用不同的模型
- 可以根据语言特点优化
- 可以独立更新和迭代

---

## 十一、实施步骤

### Phase 1：服务包定义（1周）
1. 定义`semantic-repair-zh`服务包结构（中文优化模型）
2. 定义`semantic-repair-en`服务包结构（英文优化模型）
3. 定义`en-normalize`服务包结构（无模型）
4. 编写`service.json`配置文件

### Phase 2：服务发现扩展（1周）
1. 扩展`ServicesHandler.getInstalledSemanticRepairServices()`
2. 扩展服务类型映射
3. 实现服务健康检查

### Phase 3：自动初始化（1周）
1. 修改`PostProcessCoordinator`支持服务发现初始化
2. 实现服务状态变化监听
3. 实现自动重新初始化机制

### Phase 4：TaskRouter集成（1周）
1. 扩展`TaskRouter`支持语义修复服务发现
2. 实现服务端点获取
3. 实现降级机制

### Phase 5：测试和优化（1周）
1. 测试服务安装/卸载流程
2. 测试自动启用/禁用机制
3. 测试配置参数调整

---

## 十二、总结

这个架构设计完全满足您的需求：

1. ✅ **用户选择安装**：用户可以选择性安装中文或英文修复服务
2. ✅ **自动启用**：系统根据已安装的服务自动启用功能
3. ✅ **无需配置开关**：不需要在配置文件中手动设置`enabled`
4. ✅ **与现有架构一致**：遵循服务注册表机制
5. ✅ **热插拔**：安装/卸载后自动生效
6. ✅ **模型独立性**：中英文使用不同的优化模型

**关键设计点**：
- 语义修复服务作为独立服务包
- 通过`ServiceRegistryManager`发现已安装的服务
- `PostProcessCoordinator`根据服务发现结果自动初始化
- 配置文件只用于高级参数，不用于功能开关
- 中英文服务包使用不同的模型，可以根据语言特点优化

这样的设计让用户可以：
- 根据需求选择安装哪些服务
- 系统自动适配已安装的服务
- 通过配置调整参数，而不是控制开关
- 享受针对不同语言优化的模型性能
