# 音频聚合 8 秒阈值业务逻辑说明

## 核心参数

- **`SHORT_UTTERANCE_THRESHOLD_MS = 8000`** (8秒)：短句阈值
- **`SHORT_UTTERANCE_WAIT_MS = 3000`** (3秒)：短句等待时间

---

## 业务逻辑

### 1. 短句检测

**判断条件**：
```typescript
const isShortUtterance = buffer.totalDurationMs < this.SHORT_UTTERANCE_THRESHOLD_MS; // < 8秒
```

**含义**：
- 如果当前缓冲区的音频总时长 < 8秒，被认为是"短句"
- 8秒是一个经验值，从6秒增加到8秒，目的是"减少短句误判"

### 2. 延迟合并决策

**触发条件**（所有条件必须同时满足）：
```typescript
const shouldDelayForMerge = 
  isShortUtterance &&                    // 1. 音频 < 8秒
  !isManualCut &&                        // 2. 不是手动截断（用户没有点击发送）
  !isPauseTriggered &&                   // 3. 不是3秒静音触发
  !isTimeoutTriggered &&                 // 4. 不是超时触发
  !buffer.shortUtteranceWaitUntil;        // 5. 当前没有在等待中
```

**业务含义**：
- **只有非手动截断的短句才延迟合并**
- 如果用户手动点击发送（`isManualCut=true`），说明用户认为这句话完整，不应该等待合并
- 如果是静音或超时触发，说明已经检测到句子结束，不应该等待

### 3. 延迟等待机制

**如果触发延迟合并**：
```typescript
if (shouldDelayForMerge) {
  // 设置延迟等待，等待下一个chunk到达
  buffer.shortUtteranceWaitUntil = nowMs + this.SHORT_UTTERANCE_WAIT_MS; // 3秒后
  buffer.shortUtteranceJobId = job.job_id;
  return null; // 继续缓冲，等待下一个chunk
}
```

**等待逻辑**：
1. **设置等待截止时间**：当前时间 + 3秒
2. **继续缓冲**：返回 `null`，不立即处理音频
3. **期望合并**：等待下一个音频块到达，期望可以合并成一个更完整的句子

### 4. 等待超时处理

**如果等待期间没有新chunk到达**：
```typescript
if (buffer.shortUtteranceWaitUntil) {
  if (nowMs < buffer.shortUtteranceWaitUntil) {
    // 还在等待期间，继续缓冲
    return null;
  } else {
    // 等待超时，直接处理，不再延长等待
    buffer.shortUtteranceWaitUntil = undefined;
    // 继续执行后续处理逻辑
  }
}
```

**超时后的行为**：
- 清除等待标志
- 直接处理当前缓冲的音频（即使仍然很短）
- **不再延长等待**，避免用户等待过久

---

## 业务目标

### 1. 避免ASR识别不完整的短句

**问题场景**：
- 用户说话时，音频可能被意外切分成很小的块（比如只有2-3秒）
- 如果直接发送给ASR，可能识别出不完整的文本（比如"你好"而不是"你好世界"）

**解决方案**：
- 检测到短句（< 8秒）时，延迟3秒等待
- 如果下一个音频块在3秒内到达，可以合并成一个更完整的句子
- 合并后的音频（可能 > 8秒）更容易被ASR正确识别

### 2. 提高识别准确率

**原理**：
- 更长的音频包含更多的上下文信息
- ASR模型在更长的音频上通常表现更好
- 合并后的完整句子比碎片化的短句更容易识别

### 3. 减少NMT翻译次数

**优化效果**：
- 如果短句被合并，可以减少NMT翻译次数
- 例如：3个2秒的短句合并成1个6秒的句子，只需要1次NMT翻译，而不是3次

---

## 参数调优历史

### 短句阈值（SHORT_UTTERANCE_THRESHOLD_MS）

- **初始值**：6秒
- **当前值**：8秒
- **调整原因**："减少短句误判"
- **说明**：6秒可能太短，导致很多正常短句被误判为需要合并的短句

### 等待时间（SHORT_UTTERANCE_WAIT_MS）

- **初始值**：5秒
- **当前值**：3秒
- **调整原因**："减少用户等待时间，避免用户感觉系统很慢"
- **说明**：5秒等待时间过长，导致用户等待过久（Job 9等待9秒，Job 12等待32秒）

---

## 与其他机制的关系

### 1. 与手动截断（isManualCut）的关系

**优先级**：手动截断 > 短句延迟合并

- 如果用户手动点击发送（`isManualCut=true`），说明用户认为这句话完整
- **不触发延迟合并**，立即处理

### 2. 与静音触发（isPauseTriggered）的关系

**优先级**：静音触发 > 短句延迟合并

- 如果检测到3秒静音（`isPauseTriggered=true`），说明句子已经结束
- **不触发延迟合并**，立即处理

### 3. 与超时触发（isTimeoutTriggered）的关系

**优先级**：超时触发 > 短句延迟合并

- 如果调度服务器检测到没有更多chunk（`isTimeoutTriggered=true`），说明这是最后一句话
- **不触发延迟合并**，立即处理

### 4. 与最短自动处理时长（MIN_AUTO_PROCESS_DURATION_MS = 10秒）的关系

**区别**：
- **8秒阈值**：用于判断是否需要延迟合并（等待下一个chunk）
- **10秒阈值**：用于判断是否自动处理（不需要等待标识）

**逻辑**：
- < 8秒：可能是短句，延迟3秒等待合并
- 8-10秒：不延迟，但也不自动处理（需要等待标识）
- ≥ 10秒：自动处理（不需要等待标识）

---

## 潜在问题

### 1. 与文本聚合的冲突

**问题**：
- 音频聚合基于时长（8秒）判断是否需要等待
- 文本聚合基于字符数（6-16字符）判断是否需要等待
- 判断标准不一致，可能导致：
  - 音频聚合认为应该等待，但文本聚合认为应该发送
  - 音频聚合认为应该发送，但文本聚合认为应该等待

**示例场景**：
```
场景1：音频聚合等待，但文本聚合直接发送
1. 音频：7秒（< 8秒）→ AudioAggregator 延迟3秒等待
2. 3秒后，音频聚合完成，ASR 识别出文本："你好世界"（8字符）
3. TextForwardMergeManager：8字符 < 16字符，应该等待合并
   但音频已经聚合完成，无法再等待
   结果：文本聚合的等待机制失效

场景2：音频聚合直接发送，但文本聚合等待
1. 音频：9秒（> 8秒）→ AudioAggregator 立即处理
2. ASR 识别出文本："你好"（4字符）
3. TextForwardMergeManager：4字符 < 6字符，直接丢弃
   结果：音频已经处理，但文本被丢弃，浪费了 ASR 处理
```

### 2. 延迟叠加

**问题**：
- 音频聚合：短句等待3秒
- 文本聚合：短句等待3秒
- 如果两个等待机制都触发，可能导致总延迟 = 3秒 + 3秒 = 6秒

**影响**：
- 用户等待时间过长
- 用户体验差

---

## 优化建议

### 方案1（推荐）：统一判断标准

**思路**：
- 音频聚合：只负责音频合并，不做"是否等待"的决策
- 文本聚合：统一负责所有"是否等待/发送"的决策
- 音频聚合始终输出，由文本聚合决定是否等待

**优点**：
- 避免判断标准不一致
- 避免延迟叠加
- 简化状态管理

### 方案2：移除音频聚合的等待机制

**思路**：
- AudioAggregator 只做音频合并，不做延迟等待
- 所有等待决策由 TextForwardMergeManager 统一处理
- 简化状态管理，避免冲突

**优点**：
- 完全避免冲突
- 状态管理更简单
- 延迟只发生一次（在文本聚合阶段）

---

## 总结

**8秒阈值的业务逻辑**：
1. **目的**：避免ASR识别不完整的短句，提高识别准确率
2. **机制**：检测到短句（< 8秒）时，延迟3秒等待下一个chunk，期望合并成更完整的句子
3. **条件**：只有非手动截断、非静音触发、非超时触发的短句才延迟合并
4. **超时**：如果3秒内没有新chunk到达，超时后直接处理，不再延长等待

**潜在问题**：
- 与文本聚合的判断标准不一致（时长 vs 字符数）
- 可能导致延迟叠加或逻辑冲突

**建议**：
- 统一判断标准，移除音频聚合的等待机制
- 由文本聚合统一负责所有等待决策
