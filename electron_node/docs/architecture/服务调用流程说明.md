# 服务调用流程说明

## 当前架构

### 统一入口：NodeAgent

所有服务调用都在 **`NodeAgent`** 中统一管理，通过以下调用链：

```
NodeAgent.handleMessage() 
  → NodeAgent.handleJob() 
    → JobProcessor.processJob()
      → InferenceService.processJob() [ASR + 聚合 + 去重 + 语义修复]
        → PipelineOrchestrator.processJob()
          ├─ AudioAggregator (音频聚合)
          ├─ ASR Service (语音识别)
          ├─ AggregationStage (文本聚合)
          ├─ MergeHandler (合并处理)
          ├─ TextFilter (文本过滤)
          ├─ SemanticRepairStage (语义修复)
          └─ DedupStage (去重检查)
      → PostProcessCoordinator.process() [NMT, TTS, TONE]
        ├─ TranslationStage (NMT)
        ├─ TTSStage (TTS)
        └─ TONEStage (TONE)
```

---

## 详细调用流程

### 1. NodeAgent.handleMessage() - 消息接收

**文件**：`electron_node/electron-node/main/src/agent/node-agent.ts`

**位置**：第 286-346 行

```typescript
private async handleMessage(data: string): Promise<void> {
  const message = JSON.parse(data);
  
  switch (message.type) {
    case 'job_assign': {
      const job = message as JobAssignMessage;
      await this.handleJob(job);  // 统一入口
      break;
    }
  }
}
```

**职责**：
- 接收 WebSocket 消息
- 解析 `job_assign` 消息
- 调用 `handleJob()` 处理任务

---

### 2. NodeAgent.handleJob() - 任务分发

**文件**：`electron_node/electron-node/main/src/agent/node-agent.ts`

**位置**：第 348-448 行

```typescript
private async handleJob(job: JobAssignMessage): Promise<void> {
  const startTime = Date.now();
  
  // 统一调用 JobProcessor
  const processResult = await this.jobProcessor.processJob(job, startTime);
  
  // 发送结果
  if (processResult.shouldSend) {
    await this.resultSender.sendResult(job, processResult.finalResult);
  }
}
```

**职责**：
- 统一调用 `JobProcessor.processJob()`
- 统一调用 `ResultSender.sendResult()` 发送结果

---

### 3. JobProcessor.processJob() - 服务调用统一入口

**文件**：`electron_node/electron-node/main/src/agent/node-agent-job-processor.ts`

**位置**：第 36-186 行

```typescript
async processJob(
  job: JobAssignMessage,
  startTime: number
): Promise<{ finalResult: JobResult; shouldSend: boolean; reason?: string }> {
  
  // ========== 1. ASR 阶段 ==========
  // 调用 InferenceService（内部调用 PipelineOrchestrator）
  const result = await this.inferenceService.processJob(job, partialCallback);
  
  // ========== 2. 后处理阶段 ==========
  // 调用 PostProcessCoordinator（内部调用 NMT, TTS, TONE, 语义修复）
  if (enablePostProcessTranslation && this.postProcessCoordinator) {
    const postProcessResult = await this.postProcessCoordinator.process(job, result);
    
    // 处理 TTS Opus 编码
    // ...
    
    // 构建最终结果
    finalResult = {
      ...result,
      text_asr: postProcessResult.aggregatedText,
      text_translated: postProcessResult.translatedText,
      tts_audio: ttsAudio,
      tts_format: ttsFormat,
    };
  }
  
  return { finalResult, shouldSend, reason };
}
```

**职责**：
- ✅ **统一管理所有服务调用**
- ✅ **ASR 阶段**：调用 `InferenceService.processJob()`
- ✅ **后处理阶段**：调用 `PostProcessCoordinator.process()`
- ✅ **结果处理**：统一处理 TTS Opus 编码

---

### 4. InferenceService.processJob() - ASR 服务调用

**文件**：`electron_node/electron-node/main/src/inference/inference-service.ts`

**位置**：第 188-244 行

```typescript
async processJob(
  job: JobAssignMessage,
  partialCallback?: PartialResultCallback
): Promise<JobResult> {
  
  // 检查 use_asr
  if (job.pipeline?.use_asr === false) {
    return emptyResult;
  }
  
  // 调用 PipelineOrchestrator（ASR）
  const result = await this.pipelineOrchestrator.processJob(job, partialCallback);
  
  return result;
}
```

**职责**：
- 检查 `pipeline.use_asr`
- 调用 `PipelineOrchestrator.processJob()` 执行 ASR

---

### 5. PostProcessCoordinator.process() - 后处理服务调用

**文件**：`electron_node/electron-node/main/src/agent/postprocess/postprocess-coordinator.ts`

**位置**：第 167-548 行

**注意**：聚合和去重逻辑已迁移到 PipelineOrchestrator，PostProcessCoordinator 现在只负责翻译、TTS 和 TONE。

```typescript
async process(
  job: JobAssignMessage,
  result: JobResult
): Promise<PostProcessResult> {
  
  // ========== Stage 1: 检查是否应该处理 ==========
  // 聚合和去重已在 PipelineOrchestrator 中处理
  if (result.should_send === false) {
    return { shouldSend: false, ... };
  }
  
  // 检查文本是否为空
  if (!result.text_asr || result.text_asr.trim().length === 0) {
    return { shouldSend: true, aggregatedText: '', ... };
  }
  
  // ========== Stage 2: 翻译（如果 use_nmt !== false）==========
  if (job.pipeline?.use_nmt !== false) {
    // 支持只选择 NMT（文本翻译模式）
    if (job.pipeline?.use_asr === false) {
      textToTranslate = job.input_text;  // 使用输入文本
    } else {
      textToTranslate = result.text_asr;  // 使用 PipelineOrchestrator 处理后的文本（已聚合和修复）
    }
    translationResult = await this.translationStage.process(...);
  }
  
  // ========== Stage 3: TTS（如果 use_tts !== false）==========
  if (job.pipeline?.use_tts !== false) {
    ttsResult = await this.ttsStage.process(...);
  }
  
  // ========== Stage 4: TONE（如果 use_tone === true）==========
  if (job.pipeline?.use_tone === true) {
    toneResult = await this.toneStage.process(...);
  }
  
  return {
    shouldSend: result.should_send ?? true,
    aggregatedText: result.text_asr,  // 已经是聚合和修复后的文本
    translatedText: translationResult.translatedText,
    ttsAudio: toneResult.toneAudio || ttsResult.ttsAudio,
    toneAudio: toneResult.toneAudio,
    speakerId: toneResult.speakerId,
  };
}
```

**职责**：
- ✅ **检查 should_send**：如果 PipelineOrchestrator 已决定不发送，直接返回
- ✅ **翻译（NMT）**：如果 `use_nmt !== false`，执行翻译
- ✅ **TTS**：如果 `use_tts !== false`，生成 TTS 音频
- ✅ **TONE**：如果 `use_tone === true`，生成音色配音

**注意**：
- 语义修复、聚合和去重现在在 PipelineOrchestrator 中处理
- `result.text_asr` 已经是聚合和语义修复后的文本

---

## 各场景的服务调用流程

### 场景1：ASR+NMT+TTS+TONE（个人专属语音处理）

```
NodeAgent.handleJob()
  → JobProcessor.processJob()
    → InferenceService.processJob() [ASR]
      → PipelineOrchestrator.processJob()
        → TaskRouter.routeASRTask() [ASR 服务调用]
        → AggregationStage.process() [文本聚合]
        → MergeHandler.process() [合并处理]
        → TextFilter.process() [文本过滤]
        → SemanticRepairStage.process() [语义修复服务调用]
        → DedupStage.process() [去重检查]
    → PostProcessCoordinator.process()
      → TranslationStage.process() [NMT 服务调用]
        → TaskRouter.routeNMTTask()
      → TTSStage.process() [TTS 服务调用]
        → TaskRouter.routeTTSTask()
      → TONEStage.process() [TONE 服务调用]
        → TaskRouter.routeTONETask()
```

**服务调用位置**：
- ✅ ASR：`InferenceService.processJob()` → `PipelineOrchestrator.processJob()`
- ✅ 聚合：`PipelineOrchestrator.processJob()` → `AggregationStage.process()`
- ✅ 语义修复：`PipelineOrchestrator.processJob()` → `SemanticRepairStage.process()`
- ✅ 去重：`PipelineOrchestrator.processJob()` → `DedupStage.process()`
- ✅ NMT：`PostProcessCoordinator.process()` → `TranslationStage.process()`
- ✅ TTS：`PostProcessCoordinator.process()` → `TTSStage.process()`
- ✅ TONE：`PostProcessCoordinator.process()` → `TONEStage.process()`

---

### 场景2：ASR+NMT+TTS（语音转译）

```
NodeAgent.handleJob()
  → JobProcessor.processJob()
    → InferenceService.processJob() [ASR]
    → PostProcessCoordinator.process()
      → SemanticRepairHandler.process() [语义修复]
      → TranslationStage.process() [NMT]
      → TTSStage.process() [TTS]
      → TONEStage.process() [跳过，use_tone !== true]
```

**服务调用位置**：
- ✅ ASR：`InferenceService.processJob()`
- ✅ 聚合：`PipelineOrchestrator.processJob()`
- ✅ 语义修复：`PipelineOrchestrator.processJob()`
- ✅ 去重：`PipelineOrchestrator.processJob()`
- ✅ NMT：`PostProcessCoordinator.process()`
- ✅ TTS：`PostProcessCoordinator.process()`
- ❌ TONE：跳过

---

### 场景3：ASR+NMT（字幕模式）

```
NodeAgent.handleJob()
  → JobProcessor.processJob()
    → InferenceService.processJob() [ASR]
    → PostProcessCoordinator.process()
      → SemanticRepairHandler.process() [语义修复]
      → TranslationStage.process() [NMT]
      → TTSStage.process() [跳过，use_tts === false]
      → TONEStage.process() [跳过，use_tone !== true]
```

**服务调用位置**：
- ✅ ASR：`InferenceService.processJob()`
- ✅ 聚合：`PipelineOrchestrator.processJob()`
- ✅ 语义修复：`PipelineOrchestrator.processJob()`
- ✅ 去重：`PipelineOrchestrator.processJob()`
- ✅ NMT：`PostProcessCoordinator.process()`
- ❌ TTS：跳过
- ❌ TONE：跳过

---

### 场景4：只选择 NMT（文本翻译）

```
NodeAgent.handleJob()
  → JobProcessor.processJob()
    → InferenceService.processJob() [跳过，use_asr === false]
      → PipelineOrchestrator.processJob() [返回空结果]
    → PostProcessCoordinator.process()
      → SemanticRepairHandler.process() [跳过，use_asr === false]
      → TranslationStage.process() [NMT，使用 job.input_text]
        → TaskRouter.routeNMTTask()
      → TTSStage.process() [跳过，use_tts === false]
      → TONEStage.process() [跳过，use_tone !== true]
```

**服务调用位置**：
- ❌ ASR：跳过
- ❌ 聚合：跳过（因为 `use_asr === false`）
- ❌ 语义修复：跳过（因为 `use_asr === false`）
- ❌ 去重：跳过（因为 `use_asr === false`）
- ✅ NMT：`PostProcessCoordinator.process()` → `TranslationStage.process()`（使用 `job.input_text`）
- ❌ TTS：跳过
- ❌ TONE：跳过

**注意**：需要 web 端在 `JobAssignMessage` 中提供 `input_text` 字段。

---

### 场景5：只选择 ASR

```
NodeAgent.handleJob()
  → JobProcessor.processJob()
    → InferenceService.processJob() [ASR]
      → PipelineOrchestrator.processJob()
        → TaskRouter.routeASRTask() [ASR 服务调用]
    → PostProcessCoordinator.process()
      → SemanticRepairHandler.process() [语义修复]
      → TranslationStage.process() [跳过，use_nmt === false]
      → TTSStage.process() [跳过，use_tts === false]
      → TONEStage.process() [跳过，use_tone !== true]
```

**服务调用位置**：
- ✅ ASR：`InferenceService.processJob()`
- ✅ 聚合：`PipelineOrchestrator.processJob()`
- ✅ 语义修复：`PipelineOrchestrator.processJob()`（因为 `use_asr === true`）
- ✅ 去重：`PipelineOrchestrator.processJob()`
- ❌ NMT：跳过
- ❌ TTS：跳过
- ❌ TONE：跳过

---

## 服务调用统一管理位置

### ✅ 当前架构：JobProcessor.processJob()

**文件**：`electron_node/electron-node/main/src/agent/node-agent-job-processor.ts`

**优势**：
- ✅ 所有服务调用都在一个方法中统一管理
- ✅ 清晰的调用顺序：ASR → 后处理（NMT, TTS, TONE）
- ✅ 统一的错误处理和结果处理
- ✅ 统一的 TTS Opus 编码处理

**调用链**：
```
NodeAgent.handleJob()
  └─> JobProcessor.processJob()  ← 统一入口
      ├─> InferenceService.processJob() [ASR]
      └─> PostProcessCoordinator.process() [NMT, TTS, TONE, 语义修复]
```

---

## 总结

### 服务调用统一位置

**✅ 当前架构已经统一在 `JobProcessor.processJob()` 中**

所有服务调用都通过以下路径：

1. **NodeAgent.handleJob()** - 任务接收和分发
2. **JobProcessor.processJob()** - 服务调用统一入口
   - `InferenceService.processJob()` - ASR 服务调用
   - `PostProcessCoordinator.process()` - 后处理服务调用（NMT, TTS, TONE, 语义修复）

### 各场景的服务调用

| 场景 | ASR | 语义修复 | NMT | TTS | TONE |
|------|-----|---------|-----|-----|------|
| ASR+NMT+TTS+TONE | ✅ | ✅ | ✅ | ✅ | ✅ |
| ASR+NMT+TTS | ✅ | ✅ | ✅ | ✅ | ❌ |
| ASR+NMT | ✅ | ✅ | ✅ | ❌ | ❌ |
| 只选择 NMT | ❌ | ❌ | ✅ | ❌ | ❌ |
| 只选择 ASR | ✅ | ✅ | ❌ | ❌ | ❌ |

### 关键点

1. **聚合、语义修复和去重与 ASR 绑定**：
   - 如果 `use_asr === true`，必须执行聚合、语义修复和去重
   - 如果 `use_asr === false`，跳过聚合、语义修复和去重
   - 这些逻辑现在统一在 `PipelineOrchestrator` 中处理

2. **只选择 NMT 模式**：
   - 如果 `use_asr === false` 且 `use_nmt === true`，使用 `job.input_text` 作为输入
   - 需要 web 端提供 `input_text` 字段

3. **TONE 音色配音**：
   - 在 TTS 之后执行
   - 从 `job.speaker_id` 或 `job.voice_id` 提取音色ID

---

## 建议

当前架构已经很好地统一了服务调用，所有调用都在 `JobProcessor.processJob()` 中管理。如果需要进一步优化，可以考虑：

1. **添加服务调用日志**：在 `JobProcessor.processJob()` 中记录每个服务的调用情况
2. **添加服务调用监控**：在 `JobProcessor.processJob()` 中记录每个服务的耗时
3. **添加服务调用配置**：在 `JobProcessor.processJob()` 中根据 `pipeline` 字段动态决定调用哪些服务
