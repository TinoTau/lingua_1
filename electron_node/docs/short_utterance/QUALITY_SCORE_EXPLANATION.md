# Quality Score 计算原理和阈值说明

## 质量分数的来源

`qualityScore` 是由 **`bad-segment-detector.ts`** 中的 `detectBadSegment()` 函数计算出来的，用于评估 ASR 识别结果的质量。

## 计算原理

### 1. 初始值

```typescript
let qualityScore = 1.0;  // 从 1.0 开始（满分）
```

### 2. 扣分机制（减法模式）

质量分数采用**减法模式**，从 1.0 开始，根据各种异常情况扣分：

#### 2.1 Segments 时间戳异常检测

**检测项**：
1. **相邻 segments 间隔过大**（文本断裂）
   - 如果间隔 > 1.0 秒：`qualityScore -= 0.3`
   - 如果间隔 > 2.0 秒：`qualityScore -= 0.2`（额外）

2. **Segments 数量异常**
   - 如果音频时长 > 2 秒，但 segments 数 < 2：`qualityScore -= 0.2`
   - 如果音频时长 > 5 秒，但 segments 数 < 3：`qualityScore -= 0.2`

3. **Segment 时长异常**
   - 如果单个 segment 时长 > 10 秒：`qualityScore -= 0.3`
   - 如果单个 segment 时长 < 0.1 秒：`qualityScore -= 0.2`

4. **Coverage 覆盖率异常**
   - 如果 segments 覆盖的时长 < 音频时长的 50%：`qualityScore -= 0.2`

#### 2.2 语言置信度检测

**检测项**：
1. **语言置信度过低**
   - 如果 `language_probability < 0.70`：`qualityScore -= 0.4`
   - 如果 `language_probability < 0.50`：`qualityScore -= (0.70 - langProb)`（动态扣分）

#### 2.3 文本质量检测

**检测项**：
1. **乱码/非法字符比例过高**
   - 如果乱码比例 > 10%：`qualityScore -= 0.3`

2. **与上一段高度重叠**
   - 如果与上一段文本重叠度 > 80%：`qualityScore -= 0.3`

### 3. 最终分数

```typescript
// 限制在 0.0-1.0 范围
qualityScore = Math.max(0.0, Math.min(1.0, qualityScore));
```

### 4. 坏段判定

```typescript
// 如果有任何异常原因，或者质量评分 < 0.5，视为坏段
const isBad = reasonCodes.length > 0 || qualityScore < 0.5;
```

## 质量分数范围

- **范围**：`0.0` 到 `1.0`
- **满分**：`1.0`（无任何异常）
- **最低分**：`0.0`（严重异常）

## 质量等级划分

根据代码中的使用情况，质量分数可以划分为：

| 质量等级 | 分数范围 | 说明 | 使用场景 |
|---------|---------|------|---------|
| **高质量** | `>= 0.65` | 识别结果可靠，可用于上下文 | S1 Prompt 的 recent context |
| **中等质量** | `0.50 - 0.65` | 识别结果基本可靠，可用于关键词提取 | S1 Prompt 的 keywords from recent |
| **低质量** | `0.40 - 0.50` | 识别结果可能有问题，不建议使用 | 禁用 recent context 和 keywords from recent |
| **极低质量** | `< 0.40` | 识别结果不可靠，可能是坏段 | 完全禁用，触发重跑 |

## 阈值 0.65 的选择依据

### 1. 基于坏段判定阈值

代码中，坏段判定阈值是 `0.5`：
```typescript
const isBad = reasonCodes.length > 0 || qualityScore < 0.5;
```

因此：
- `>= 0.5`：不是坏段，基本可用
- `< 0.5`：是坏段，不可用

### 2. 安全边界

为了确保用于上下文的文本是**高质量**的，需要设置一个**安全边界**：

- **0.65 = 0.5 + 0.15**（安全边界）
- 这样可以确保：
  - 即使质量分数有轻微波动，也不会低于坏段阈值
  - 用于上下文的文本是**真正高质量**的，而不是"勉强可用"的

### 3. 经验值

根据实际使用经验：
- **0.7+**：非常高质量，几乎无异常
- **0.65-0.7**：高质量，可能有轻微异常但不影响使用
- **0.5-0.65**：中等质量，可能有轻微问题，不建议用于上下文
- **< 0.5**：低质量，是坏段

### 4. 与其他阈值的对比

代码中还有其他质量阈值的使用：

| 阈值 | 用途 | 位置 |
|-----|------|------|
| `0.5` | 坏段判定阈值 | `bad-segment-detector.ts` |
| `0.4` | 低质量禁用 context | `task-router.ts` (P0.5-CTX-1) |
| `0.45` | offline 模式低质量阈值 | `need-rescore.ts` |
| `0.50` | room 模式低质量阈值 | `need-rescore.ts` |
| `0.65` | S1 Prompt recent context 阈值 | `prompt-builder.ts` |
| `0.7` | NMT Repair 触发阈值 | `aggregator-middleware.ts` |

**0.65 的选择**：
- 高于坏段阈值（0.5）和低质量阈值（0.4/0.45/0.50）
- 低于 NMT Repair 阈值（0.7）
- 处于"高质量但不需要修复"的区间

## 质量分数计算示例

### 示例 1：高质量识别

```
初始分数：1.0
- 无 segments 异常：-0.0
- 语言置信度 0.95：-0.0
- 无乱码：-0.0
- 无重叠：-0.0
最终分数：1.0 ✅（高质量）
```

### 示例 2：中等质量识别

```
初始分数：1.0
- Segments 间隔 1.5 秒：-0.3
- 语言置信度 0.75：-0.0
- 无乱码：-0.0
- 无重叠：-0.0
最终分数：0.7 ✅（高质量，可用于 recent context）
```

### 示例 3：低质量识别

```
初始分数：1.0
- Segments 间隔 2.5 秒：-0.3 - 0.2 = -0.5
- 语言置信度 0.60：-0.4
- 乱码比例 15%：-0.3
- 无重叠：-0.0
最终分数：0.0 - 0.2 = -0.2 → 0.0（极低质量，坏段）
```

### 示例 4：边界情况（0.65）

```
初始分数：1.0
- Segments 间隔 1.2 秒：-0.3
- 语言置信度 0.80：-0.0
- 无乱码：-0.0
- 无重叠：-0.0
最终分数：0.7 ✅（高质量，可用于 recent context）

或者：

初始分数：1.0
- 无 segments 异常：-0.0
- 语言置信度 0.65：-0.05（0.70 - 0.65）
- 无乱码：-0.0
- 无重叠：-0.0
最终分数：0.95 ✅（高质量，可用于 recent context）
```

## 总结

### 0.65 阈值的原理

1. **基于坏段判定**：坏段阈值是 0.5，0.65 提供了安全边界
2. **经验值**：0.65-0.7 是"高质量但不需要修复"的区间
3. **平衡效果和安全性**：
   - 太低（如 0.5）：可能包含低质量文本，导致错误传播
   - 太高（如 0.8）：可能过滤掉太多有用的上下文
   - 0.65：平衡了效果和安全性

### 质量分数的意义

- **不是准确率**：质量分数不是识别准确率，而是基于各种异常检测的综合评分
- **相对指标**：质量分数是相对的，用于判断识别结果是否可靠
- **动态调整**：可以根据实际效果调整阈值（如 0.6、0.7 等）

### 建议

如果发现识别准确率仍然低，可以考虑：
1. **提高阈值**：从 0.65 提高到 0.7 或 0.75
2. **检查质量分数分布**：查看日志中 `qualityScore` 的实际分布
3. **调整扣分权重**：如果某些异常检测过于严格，可以调整扣分权重

