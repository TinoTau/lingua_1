# 节点端重复逻辑及上下游流程 — 决策部门审议文档

**文档版本**：2026-01  
**适用范围**：electron_node 主进程 `main/src`（含 pipeline-orchestrator、aggregator 等）  
**目的**：将重复逻辑及其上下游流程整理成文，供决策部门审议是否合并、何时合并及影响范围。

---

## 一、文档说明

### 1.1 背景

节点端在 2026-01 代码整理中已完成多轮拆分（audio-aggregator、original-job-result-dispatcher、aggregator-state、gpu-arbiter、sequential-executor、ServiceProcessRunner 等），并完成「Import 移至头部」。计划文档（`CODE_REFACTOR_PLAN_ELECTRON_NODE_2026_01.md`）第三节列出的两类重复逻辑（空音频/空 buffer 检查、Buffer 创建）**已实施**；另有「sessionId 作 bufferKey 的临时兼容」等可选一致化项，需明确上下游与决策后再动。

### 1.2 读者与使用方式

- **决策部门**：据此审议是否同意合并/保留现状、是否纳入排期。
- **开发**：据此理解重复逻辑所在模块、调用链与风险，实施时按审议结论执行。

### 1.3 相关文档

| 文档 | 说明 |
|------|------|
| `CODE_REFACTOR_PLAN_ELECTRON_NODE_2026_01.md` | 节点端整理计划（拆分项、重复逻辑建议、Import 约定） |
| `IMPORT_AND_DUPLICATE_LOGIC_2026_01.md` | Import 已做项 + 重复逻辑罗列与建议 |
| 本文档 | 重复逻辑的**上下游流程**与**审议要点** |

---

## 二、重复逻辑及上下游流程

### 2.1 已完成的重复逻辑合并（现状说明）

以下两项已在前期拆分中完成，此处仅说明**上下游与现状**，供决策部门知悉，**无需再审议合并**。

#### 2.1.1 空音频 / 空 buffer 检查

- **计划描述**：`audio-aggregator.ts` 内「当前为空且无 pending 则返回 EMPTY」抽成单一纯函数，主流程多处调用。
- **当前实现**：
  - **提供方**：`pipeline-orchestrator/audio-aggregator-buffer-lifecycle.ts` 导出 `shouldReturnEmptyInput(buffer, currentAudio, currentDurationMs)`。
  - **条件**：`currentAudio` 为空且 `currentDurationMs` 为 0，且 buffer 无 pending（无 pendingMaxDurationAudio、pendingTimeoutAudio、pendingSmallSegments）且无已缓冲音频，则返回 `true`。
- **上游**：
  - `AudioAggregator.processAudioChunk(job)` 由 `PipelineOrchestratorAudioProcessor.processAudio(job)` 调用；
  - `processAudio` 由 `InferenceService` 在流水线中调用；
  - 入参 `job` 来自调度/前端，含 `session_id` 等，内部用 `buildBufferKey(job)` 得到 `bufferKey`，再对 `this.buffers.get(bufferKey)` 取 buffer。
- **下游**：
  - `processAudioChunk` 内两处调用 `shouldReturnEmptyInput(...)`：约 233 行（更新 buffer 前）、约 476 行（`shouldProcessNow` 前）。
  - 若为 `true`，则调用 `this.deleteBuffer(bufferKey, currentBuffer, 'Empty audio input', nowMs)`，并返回 `{ audioSegments: [], shouldReturnEmpty: true, reason: 'EMPTY_INPUT' }`。
  - `PipelineOrchestratorAudioProcessor` 收到 `shouldReturnEmpty: true` 时返回空结果，不送 ASR。
- **结论**：无重复内联实现，两处调用均委托 `shouldReturnEmptyInput`，行为与计划一致。

#### 2.1.2 Buffer 创建

- **计划描述**：`audio-aggregator.ts` 中「新建 buffer」与「新 epoch buffer」结构相同，抽成 `createEmptyBuffer(...)`。
- **当前实现**：
  - **提供方**：`audio-aggregator-buffer-lifecycle.ts` 导出 `createEmptyBuffer(bufferKey, sessionId, utteranceIndex, nowMs, epoch)`，返回统一结构的 `AudioBuffer`（state: 'OPEN', audioChunks: [], ...）。
  - **上游**：与 2.1.1 相同，`processAudioChunk(job)` 在需要新建 buffer 或新 epoch 时调用。
  - **下游**：新建或重置的 buffer 写入 `this.buffers.set(bufferKey, ...)`，供后续 `processAudioChunk` 使用；删除时通过 `deleteBufferFromMap` 从 Map 移除。
- **结论**：无重复创建逻辑，主流程统一通过 `createEmptyBuffer` 创建，行为与计划一致。

---

### 2.2 ~~待审议项~~ 已移除：sessionId 作 bufferKey 的临时兼容

**实施结论（2026-01）**：已按《节点端_buffer_key_最小patch与tasklist》完成改造。节点端 bufferKey 的最终定义为 **jobId**（即 `job.job_id`）；`clearBuffer(sessionId)`、`getBufferStatus(sessionId)` 已删除，统一为 `clearBufferByKey(bufferKey: string)`、`getBufferStatusByKey(bufferKey: string)`。详见《节点端_buffer_key_最小patch与tasklist》《节点端_buffer_key_改造_可行性确认与待确认项》。以下为改造前说明（保留供追溯）。

#### 2.2.1 重复点说明（改造前）

- **位置**：`pipeline-orchestrator/audio-aggregator.ts`。
- **表现**：两处均以「入参为 sessionId，内部用 sessionId 当作 bufferKey」的方式访问 `this.buffers`：
  - `clearBuffer(sessionId: string)`（约 852 行）：`const bufferKey = sessionId;  // 临时兼容`，再 `this.buffers.get(bufferKey)`，若有则 `this.deleteBuffer(bufferKey, buffer, ...)`。
  - `getBufferStatus(sessionId: string)`（约 926 行）：`const bufferKey = sessionId;  // 临时兼容`，再 `this.buffers.get(bufferKey)`，若有则返回状态对象，否则 `null`。
- **与主流程的差异**：主流程 `processAudioChunk(job)` 使用 `buildBufferKey(job)` 作为 key。`buildBufferKey` 可能返回 `sessionId`、`sessionId|room:xxx`、`sessionId|stream:xxx` 等；即 **bufferKey 与 sessionId 并非总相等**。因此「用 sessionId 当 bufferKey」仅在「当前仅用 session_id 且未扩展 room/stream」时与主流程一致，否则存在查不到或清错 buffer 的风险。

#### 2.2.2 上下游流程

- **clearBuffer(sessionId)**  
  - **上游调用方**：目前**仅测试**调用。  
    - `audio-aggregator.test.ts`：`afterEach` 中对多个 session 调用 `aggregator.clearBuffer('test-session-xxx')` 做清理。  
    - `audio-aggregator.legacy.test.ts`、`audio-aggregator-optimization.test.ts`：同样在测试中调用 `clearBuffer('test-session-1')` 等。  
  - **生产代码**：未发现对 `clearBuffer(sessionId)` 的调用。  
  - **下游**：内部调用 `this.deleteBuffer(bufferKey, buffer, ...)` → `deleteBufferFromMap(this.buffers, bufferKey, buffer, ...)`，从 `this.buffers` 移除对应项。

- **getBufferStatus(sessionId)**  
  - **上游调用方**：目前**仅测试**调用。  
    - `audio-aggregator-optimization.test.ts`：`aggregator.getBufferStatus('test-session-1')` 用于断言状态。  
  - **生产代码**：`pipeline-orchestrator-audio-processor.ts` 仅注释写明「热路径不取 getBufferStatus，仅 debug 时可选」，无实际调用。  
  - **下游**：返回只读状态对象（bufferKey、epoch、state、chunkCount、totalDurationMs、pending 相关等）或 `null`，无写操作。

- **主流程 bufferKey 来源（对照）**  
  - `processAudioChunk(job)` → `buildBufferKey(job)` → 可能为 `sessionId` 或 `sessionId|room:xxx` 等。  
  - 若未来启用 room_code / input_stream_id 等，同一 session 下会有多个 bufferKey，则 `clearBuffer(sessionId)` / `getBufferStatus(sessionId)` 用单一 sessionId 无法覆盖所有相关 buffer，语义不完整。

#### 2.2.3 影响与风险

| 维度 | 说明 |
|------|------|
| **当前行为** | 测试与现有主流程均以「单 session、无 room/stream 扩展」为主，用 sessionId 当 bufferKey 在测试中与 `buildBufferKey(job)`（仅 session_id）一致，故测试通过。 |
| **未来扩展** | 若采用 `buildBufferKey` 的完整形式（含 room、stream 等），则 clearBuffer/getBufferStatus 仅按 sessionId 查找会漏掉或错清 buffer，需改为按 bufferKey 或「sessionId 下所有 bufferKey」语义设计。 |
| **兼容性** | 若保留现有 API（入参仍为 sessionId），仅内部抽成 `sessionIdToBufferKey(sessionId)` 且仍返回 sessionId，则行为不变，仅减少重复写法；若改为 bufferKey 入参，则属 API 变更，需评估调用方（当前仅测试）并更新测试。 |

#### 2.2.4 方案选项（供审议）

| 选项 | 内容 | 优点 | 缺点/注意 |
|------|------|------|-----------|
| **A. 维持现状** | 两处继续 `const bufferKey = sessionId;  // 临时兼容`，不抽函数、不改 API。 | 无改动风险，与当前测试一致。 | 两处重复写法；扩展 room/stream 后语义不完整需再改。 |
| **B. 仅抽辅助函数，API 不变** | 抽成例如 `resolveBufferKeyFromSessionId(sessionId: string): string`，内部仍 `return sessionId`，两处改为调用该函数。 | 消除重复、表意集中；行为不变。 | 不解决「未来 bufferKey ≠ sessionId」的语义问题。 |
| **C. 改为 bufferKey 入参（破兼容）** | `clearBuffer(bufferKey: string)`、`getBufferStatus(bufferKey: string)`，调用方传入 buildBufferKey(job) 或等价 key。 | 与主流程 key 一致，扩展 room/stream 时语义完整。 | 需改测试（当前仅测试调用）；若有隐藏调用方需一并排查。 |

**建议**：在未明确启用 room/stream 多 key 前，可采用 **B**；若决策部门已规划「单 session 多 bufferKey」能力，可择机采用 **C** 并同步改测试与文档。

---

### 2.3 可选：测试中 buildBufferKey 的重复调用

- **表现**：`audio-aggregator.test.ts`、`audio-aggregator-optimization.test.ts` 中多处 `const bufferKey = buildBufferKey(job)` 或 `buildBufferKey(jobA1)`，属测试内重复写法。
- **上下游**：仅测试使用，无生产调用链；buildBufferKey 本身为已导出的工具函数，行为稳定。
- **建议**：视为测试风格一致化，非必须合并；若审议认为可做，可在测试中抽公共 helper（如 `getBufferKeyForJob(job)`）减少重复，不改生产逻辑。

---

## 三、决策要点汇总

| 序号 | 事项 | 类型 | 建议 |
|------|------|------|------|
| 1 | 空音频/空 buffer 检查、Buffer 创建 | 已完成 | 无需审议，仅知悉现状与上下游。 |
| 2 | sessionId 作 bufferKey 的临时兼容（clearBuffer / getBufferStatus） | 待审议 | 建议在「未扩展多 key」前采用方案 B（抽辅助函数、API 不变）；若规划多 bufferKey，再审议方案 C 及排期。 |
| 3 | 测试中 buildBufferKey 重复调用 | 可选 | 可按需做测试 helper 一致化，不阻塞。 |

---

## 四、附录

### 4.1 相关文件清单

| 文件 | 说明 |
|------|------|
| `main/src/pipeline-orchestrator/audio-aggregator.ts` | AudioAggregator 主类；processAudioChunk、clearBuffer、getBufferStatus、getBuffer。 |
| `main/src/pipeline-orchestrator/audio-aggregator-buffer-lifecycle.ts` | createEmptyBuffer、shouldReturnEmptyInput、deleteBufferFromMap、cleanupExpiredBuffersFromMap。 |
| `main/src/pipeline-orchestrator/audio-aggregator-buffer-key.ts` | buildBufferKey、parseBufferKey。 |
| `main/src/pipeline-orchestrator/pipeline-orchestrator-audio-processor.ts` | 调用 processAudioChunk，热路径不调用 getBufferStatus。 |
| `main/src/inference/inference-service.ts` | 动态 require AudioAggregator，创建实例并注入流水线。 |
| `main/src/pipeline-orchestrator/audio-aggregator*.test.ts` | 调用 clearBuffer(sessionId)、getBufferStatus(sessionId)、buildBufferKey(job)。 |

### 4.2 关键接口（便于对照）

- **buildBufferKey(job[, ctx])**：返回 `sessionId` 或 `sessionId|room:xxx`、`sessionId|stream:xxx` 等。
- **clearBuffer(sessionId)**：内部用 sessionId 当 bufferKey 从 `this.buffers` 删除对应项。
- **getBufferStatus(sessionId)**：内部用 sessionId 当 bufferKey 返回状态或 null。
- **getBuffer(job)**：内部用 `buildBufferKey(job)` 取 buffer，与主流程一致。

---

**文档结束**。审议结论可记录在决策部门会议纪要或本仓库的决策索引中，并与 `CODE_REFACTOR_PLAN_ELECTRON_NODE_2026_01.md`、`IMPORT_AND_DUPLICATE_LOGIC_2026_01.md` 保持一致。
