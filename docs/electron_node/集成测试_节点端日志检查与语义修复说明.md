# 集成测试：节点端日志检查与语义修复说明

本文档说明如何通过节点端日志确认每个 job 在各服务中的处理过程（输入/输出）、是否经过语义修复，以及本次 turnId 合并改造是否引入了影响质量的额外逻辑。

---

## 一、如何从日志确认每个 job 的处理过程

节点端日志使用结构化字段（如 `jobId`、`sessionId`、`utteranceIndex`、`step` 等）。建议按 **job_id** 或 **session_id + utterance_index** 过滤，按时间顺序查看一条 job 的完整链路。

### 1. Pipeline 模式与步骤

- 搜索：`Pipeline mode inferred` 或 `modeName`
- 可确认：该 job 使用的模式（如 `个人特色语音转译`）及步骤列表 `steps`（应包含 ASR → AGGREGATION → SEMANTIC_REPAIR → DEDUP → TRANSLATION → YOURTTS 等）。

### 2. ASR 步骤（输入/输出）

- **输入**：由 AudioAggregator 决定；若为 turn 合并后的 flush，则输入为当前 buffer 内累积的整段音频。
- **输出**：写入 `ctx.asrText`，不会在 pipeline 层单独打一条 “ASR 输出” 的 info；可结合下一步聚合的输入反推。
- 相关日志：
  - `AudioAggregator: MaxDuration append only, no output` → 该 job 为 MaxDuration 中间段，未跑 ASR，无 ASR 输出。
  - `AudioAggregator: [StateMachine] Buffer state -> FINALIZING` → 该 job 触发 manual/timeout 合并并输出音频给 ASR。
  - 若需确认“送给 ASR 的音频时长”，可在 aggregator 中查找 `bufferKey`、`totalDurationMs`、`chunkCount` 等。

### 3. Aggregation 步骤（输入/输出）

- **输入**：上一步的 ASR 结果（即 `ctx.asrText` / `result.text_asr`）。
- **输出**：`segmentForJobResult`（本段，供 job_result.text_asr 与下游）、`shouldSendToSemanticRepair`（是否送语义修复）。
- 必看日志：
  - `runAggregationStep: Aggregation completed`  
    含 `segmentLength`、`originalTextLength`、`action`、`aggregationChanged`。
  - `AggregationStage: Processing completed with forward merge`  
    含 **`shouldSendToSemanticRepair`**（true/false）、`segmentForJobResultPreview`、`aggregatedTextPreview`。

若某 job 的 `shouldSendToSemanticRepair === false`，则该 job **不会执行 SEMANTIC_REPAIR 步骤**（见下）。

### 4. 是否执行了语义修复（SEMANTIC_REPAIR）

- **执行条件**：Pipeline 配置了 SEMANTIC_REPAIR 且 **`ctx.shouldSendToSemanticRepair === true`**（由 AGGREGATION 步骤写入）。
- 若被跳过，会看到：
  - `Skipping step SEMANTIC_REPAIR (condition not met)`
- 若执行了，会有以下日志（任一条即可确认“有调用语义修复”）：
  - **节点端**：`SemanticRepairHandler: Calling semantic repair service`  
    含 `jobId`、`serviceId`、`textLength`（即送入语义修复的文本长度）。
  - **节点端**：`Semantic repair task completed`  
    含 `decision`（REPAIR/PASS/REJECT）、`confidence`、`serviceCallDurationMs`。
  - **节点端**：`runSemanticRepairStep: Semantic repair completed`  
    含 `decision`、`originalText`（前 100 字）、`repairedText`（前 100 字）、`textChanged`。
  - **节点端**：`runSemanticRepairStep: Updated recentCommittedText with repaired text`  
    含 `originalTextLength`、`repairedTextLength`、`textChanged`。

**语义修复的输入/输出**：

- **输入**：`textToRepair` = `ctx.segmentForJobResult`（来自聚合步骤的本段文本）。
- **输出**：`ctx.repairedText`、`ctx.semanticRepairApplied`、`ctx.semanticRepairConfidence`；最终 **job_result.text_asr** 使用 **repairedText**（见 result-builder）。

若 `decision === 'PASS'` 且 `textChanged === false`，表示语义修复未改文，你看到的“质量差”可能来自 ASR 本身；若 `decision === 'REJECT'`，则保留原文（同样可能质量差）。

### 5. Translation 步骤（输入/输出）

- **输入**：`ctx.repairedText`（语义修复后的本段，若未送语义修复则由 aggregation 等路径写入）。
- **输出**：`ctx.translatedText`。
- 日志：翻译相关日志在 task-router 或 NMT 调用处；Pipeline 层可结合 `buildJobResult` 的 `text_translated` 反推。

### 6. job_result 最终产出

- **text_asr**：来自 `ctx.repairedText`（即语义修复/聚合后的本段），不是原始 ASR 直出。
- **semantic_repair_applied** / **semantic_repair_confidence**：由 `ctx.semanticRepairApplied` / `ctx.semanticRepairConfidence` 写入，可在日志或上报结果中确认本次 job 是否“应用了语义修复”及置信度。

---

## 二、本次集成测试 job 是否经过语义修复？

请在你的节点端日志中按 **job_id**（或 session_id + utterance_index）过滤本次测试的若干条 job，重点查：

1. **AGGREGATION 是否将本 job 送语义修复**  
   搜：`AggregationStage: Processing completed with forward merge`，且同一 `jobId` 下 **`shouldSendToSemanticRepair`** 是否为 **true**。
2. **是否真的执行了 SEMANTIC_REPAIR**  
   搜：同一 `jobId` 下是否出现 `SemanticRepairHandler: Calling semantic repair service` 或 `runSemanticRepairStep: Semantic repair completed`。
3. **语义修复的决策与是否改文**  
   若出现 `runSemanticRepairStep: Semantic repair completed`，看 **`decision`**（REPAIR/PASS/REJECT）和 **`textChanged`**。  
   - 若多为 **PASS** 且 **textChanged === false**：说明语义修复认为无需修改或未改，你看到的“繁体/错别字”等很可能来自 **ASR 输出质量**。  
   - 若出现 **REJECT**：则保留原文，质量同样取决于 ASR。

若同一 job 下先出现 `Skipping step SEMANTIC_REPAIR (condition not met)`，则该 job **没有经过语义修复**；此时 `job_result.text_asr` 来自聚合步骤的 `segmentForJobResult`（或未送语义修复时的 fallback），质量完全取决于 ASR 与聚合逻辑。

---

## 三、本次 turnId 合并改造是否增加了“打补丁/兜底”或影响质量的逻辑？

结论：**没有**。本次改造没有增加任何“在正常路径上跳过语义修复”或“改变语义修复输入/输出”的代码；也没有为“兼容旧行为”增加额外分支。

### 3.1 本次改造涉及的文件与行为

| 改动点 | 行为 | 是否影响语义修复或质量 |
|--------|------|------------------------|
| **buildBufferKey** | mergeKey 从 `job_id` 改为 `turn_id + tgt_lang`（无 turn_id 时退化为 job_id）。 | 否，仅影响音频缓冲的 key，不改变 ASR/聚合/语义修复的输入输出。 |
| **AudioAggregator（MaxDuration）** | MaxDuration 时只 append 音频，不跑 ASR，直接返回 `shouldReturnEmpty: true`，reason `TURN_NOT_FLUSHED`。 | 否，该 job 不会进入后续 AGGREGATION/SEMANTIC_REPAIR，不改变“会跑语义修复的 job”的流程。 |
| **AudioAggregator（manual/timeout）** | manual/timeout finalize 时必合并 buffer 并输出一段音频给 ASR，不再有 `shouldHoldPendingMaxDur` 等前向补丁。 | 否，只是保证合并后的那一帧会走完整 Pipeline（含聚合与语义修复），不改变语义修复的触发条件或输入。 |
| **JobPipeline 错误处理** | 当步骤 ASR / TRANSLATION / SEMANTIC_REPAIR 失败时，若存在 `turn_id`，则清理该 turn 的 merge buffer（`clearBufferByKey`），并打日志 `Turn segment failed, cleared merge buffer`。 | 否，仅失败时清理 buffer，避免脏数据进入后续 turn；不改变成功路径上的任何步骤或语义修复逻辑。 |

### 3.2 未新增的路径

- **没有**在“成功路径”上跳过 SEMANTIC_REPAIR 的分支。  
  SEMANTIC_REPAIR 是否执行仍只由 **`shouldExecuteStep('SEMANTIC_REPAIR', ...)`** 决定，即 **`ctx.shouldSendToSemanticRepair === true`**（由 AGGREGATION 写入）。
- **没有**在语义修复前/后对文本做“兜底”或“补丁”处理。  
  语义修复的输入仍是 **`ctx.segmentForJobResult`**，输出仍是 **`ctx.repairedText`**；**job_result.text_asr** 仍仅来自 **repairedText**（见 result-builder）。
- **没有**为“兼容旧版”增加双路径或条件分支；逻辑是“有 turn_id 则按 turn 合并，无则按 job”，无额外兜底逻辑。

因此，**本次集成测试若出现“语音识别/语义修复质量差”**，更可能来自：

1. **ASR 本身**：长句、口音、静音/断句导致识别为繁体或错词（如 音樂、盡硬、熱舞、千分、預製 等）。  
2. **语义修复未修改**：语义修复被调用但返回 PASS（或 REJECT），未改文或保留原文。  
3. **语义修复未被调用**：该 job 的 `shouldSendToSemanticRepair === false`（例如被聚合判定为“等待更多内容”或丢弃），需按第二节在日志中确认。

建议先按 **第二节** 在日志中确认：每个 job 的 **shouldSendToSemanticRepair** 与 **runSemanticRepairStep: Semantic repair completed** 的 **decision/textChanged**，再结合 ASR 服务日志（若可获取）一起排查质量问题的环节。

---

## 四、日志检索关键字速查

| 目的 | 建议搜索的日志消息或字段 |
|------|--------------------------|
| 某 job 使用的 Pipeline 模式与步骤 | `Pipeline mode inferred`、`modeName`、`steps` |
| 某 job 是否未跑 ASR（MaxDuration 中间段） | `MaxDuration append only`、`TURN_NOT_FLUSHED` |
| 某 job 聚合结果与是否送语义修复 | `AggregationStage: Processing completed with forward merge`、`shouldSendToSemanticRepair` |
| 某 job 是否被跳过语义修复 | `Skipping step SEMANTIC_REPAIR (condition not met)` |
| 某 job 是否调用了语义修复服务 | `SemanticRepairHandler: Calling semantic repair service`、`Semantic repair task completed` |
| 某 job 语义修复结果（是否改文） | `runSemanticRepairStep: Semantic repair completed`、`decision`、`textChanged` |
| 某 job 语义修复失败（回退为 ASR 原文） | **`runSemanticRepairStep: Semantic repair failed, using original text`** |
| turn 内关键步骤失败并清理 buffer | `Turn segment failed, cleared merge buffer`、`clearBufferByKey` |

以上均为节点端现有逻辑与日志，无新增“补丁”或“兜底”路径；若你提供某条 job 的 `job_id` 及对应日志片段，可进一步精确定位是否经过语义修复以及质量问题的环节。
