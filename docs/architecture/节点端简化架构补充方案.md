
# 节点端极简流水线架构

## ——开发部门反馈整合与可行性落地说明（最终稿）

**版本：v1.0**
**适用范围：Electron 节点端主进程服务（ASR / 聚合 / 修复 / 翻译 / TTS）**
**目标：在保持架构极简的前提下，吸收开发部门反馈中所有关键注意事项，使代码可维护、可监控、可扩展。**

---

## 1. 文档目的

开发部门在先前架构审阅中提出了多项注意事项，包括：

* Session 生命周期管理
* 动态依赖更新入口
* 回调 & 计算指标
* 流式 ASR partial 回调
* Gate-A 上下文重置
* 错误处理 / 日志行为
* JobResult 字段映射

本文件明确说明：
在 **不引入任何 Stage/Orchestrator/Coordinator 抽象层**、**坚持极简 JobPipeline 架构** 的前提下，
可以完整吸收这些注意点并实现稳定运行。

目标架构为：

> **InferenceService → runJobPipeline() → runXxxStep() → ResultSender**
> 无层级、无抽象、可读性极强。

---

## 2. 极简架构基础（已确定）

仅保留三个核心构件：

1. **JobPipeline（唯一编排器）**

   * 一个函数：`runJobPipeline(options)`
   * 按顺序执行：ASR → 聚合 → 修复 → 去重 → 翻译 → TTS → TONE
   * 每一步都是普通函数，不使用类。

2. **JobContext（流水线上唯一上下文结构）**

   * 存放所有中间结果，如 asrText、aggregatedText、translatedText、ttsAudio 等。

3. **runXxxStep（步骤函数）**

   * 一个步骤 = 一个文件，如 runAsrStep、runAggregationStep。
   * 无继承、无接口、无泛型，不制造认知负担。

---

## 3. 开发部门反馈项：在极简架构中的落地方式（重点）

以下为开发部门关注的全部问题及在极简架构下的解决方案。

---

### 3.1 Session 生命周期统一管理

**来源：** feedback 文档中关于 removeSession 多处散落的风险


#### 极简版解决思路

**会话清理只在一个地方完成：InferenceService。**

新增函数：

```ts
removeSession(sessionId: string) {
  this.servicesBundle.aggregatorManager?.removeSession(sessionId);
  this.servicesBundle.deduplicationHandler?.removeSession(sessionId);
  this.servicesBundle.servicesHandler?.removeSession?.(sessionId);
  this.servicesBundle.sessionContextManager?.removeSession?.(sessionId);
}
```

NodeAgent 中只做：

```ts
this.inferenceService.removeSession(sessionId)
```

#### 好处

* Session 清理的“唯一真相”位于 InferenceService
* 任何 session 泄漏问题只查一处
* 不依赖 Stage/Coordinator 分散职责

---

### 3.2 动态依赖更新（aggregatorManager / handlers 等）

**来源：** feedback 文档中的 setXxxManager/setXxxHandler


#### 极简版解决思路

只维护一个 `servicesBundle` 对象：

```ts
this.servicesBundle = {
  taskRouter,
  aggregatorManager: null,
  servicesHandler: null,
  deduplicationHandler: null,
  sessionContextManager: null,
};
```

动态更新只操作这个对象，而不是替换 orchestrator 或 pipeline：

```ts
setAggregatorManager(m) { this.servicesBundle.aggregatorManager = m; }
```

#### 好处

* 依赖注入路径只有一个
* 无需重新初始化编排器（因为根本不存在 Orchestrator 类）
* 结构极简，风险低

---

### 3.3 任务级回调 & 服务指标收集

**来源：** feedback 对 onTaskStart/onTaskEnd/onTaskProcessed 的要求


#### 极简版解决思路

回调集中在一层：runJobPipeline(options.callbacks)

```ts
callbacks?: {
  onTaskStart?: () => void;
  onTaskEnd?: () => void;
  onTaskProcessed?: (serviceName: string) => void;
}
```

JobPipeline 调用：

```ts
callbacks?.onTaskStart?.();

await runAsrStep(...);
callbacks?.onTaskProcessed?.('ASR');

await runTranslationStep(...);
callbacks?.onTaskProcessed?.('NMT');

callbacks?.onTaskEnd?.();
```

#### 好处

* 监控逻辑不分散、不增加新架构
* 只需看 JobPipeline 一处即可排查服务调用顺序
* 满足运维指标需求

---

### 3.4 流式 ASR partial 回调

**来源：** 在反馈里担忧 partialCallback 丢失


#### 极简版解决思路

partialCallback 仅在 runAsrStep 内透传：

```ts
await services.taskRouter.routeASRTask(asrTask, opts?.partialCallback);
```

#### 好处

* 不需要“流式 pipeline”架构
* 流式 & 非流式统一在一个 runAsrStep 中处理
* 回调不会丢

---

### 3.5 Gate-A：自动上下文重置逻辑

**来源：** feedback 中 Gate-A 重置语境


#### 极简版解决思路

Gate-A → 只在 runAsrStep 加一个 if：

```ts
if (asrResult.shouldResetContext) {
  services.sessionContextManager.resetContext(
    { sessionId, reason: 'low_quality', jobId },
    services.taskRouter
  );
}
```

#### 好处

* Gate-A 逻辑透明、直观
* 解耦于编排器逻辑，不需额外抽象层
* 改动风险极小

---

### 3.6 服务就绪检查（waitForServicesReady）

**来源：** feedback 对服务可用性的担忧

#### 极简版解决思路

保留在 InferenceService，不进 Pipeline。

如果需要进一步简化：

```ts
waitForServicesReady(job) {
  if (job.pipeline.use_asr)   check ASR
  if (job.pipeline.use_nmt)   check NMT
  if (job.pipeline.use_tts)   check TTS
}
```

#### 好处

* JobPipeline 不负责等待逻辑 → 保持纯净
* 依旧遵守“只在一处检查依赖”

---

### 3.7 JobResult 映射

**来源：** feedback 提到字段一致性


#### 极简版解决思路

所有字段映射集中在：

`buildJobResult(job, ctx)`

```ts
return {
  job_id: job.job_id,
  session_id: job.session_id,
  text_asr: ctx.asrText,
  text_repaired: ctx.repairedText,
  text_translated: ctx.translatedText,
  tts_audio: ctx.ttsAudio,
  language_probabilities: ctx.languageProbabilities,
  quality_score: ctx.qualityScore,
};
```

一眼能看清楚。

---

## 4. 最终建议（架构与实现）

开发团队可以放心：
**以上所有注意事项可在极简 JobPipeline 架构下稳定且低成本解决，不需要引入新的架构层级。**

最终结构非常简单：

### 4.1 代码层结构

```
InferenceService
  ├── waitForServicesReady()
  ├── removeSession()
  └── runJobPipeline()
         ├── runAsrStep()
         ├── runAggregationStep()
         ├── runSemanticRepairStep()
         ├── runDedupStep()
         ├── runTranslationStep()
         ├── runTtsStep()
         └── runToneStep()
```

### 4.2 三个检查点

* Session 管理 → InferenceService
* 流程执行 → runJobPipeline
* 单步逻辑 → runXxxStep

几十个文件 → 3 个核心区域，任何问题都能被快速定位。

---

## 5. 结论

**本架构在保持最小认知负担的前提下：**

* 完全覆盖 ASR / 聚合 / 语义修复 / 翻译 / TTS / TONE 全流程
* 完整吸收所有开发部门提出的注意事项
* 不引入额外抽象层级
* 可维护性与故障排查能力显著提升
* 足够轻量，适合当前开发资源紧张的项目阶段

可正式提交给开发部门作为架构最终定稿。

