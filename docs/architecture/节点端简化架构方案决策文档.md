# 节点端简化架构方案决策文档

**版本：v1.0**  
**日期：2024年**  
**目标受众：决策部门**  
**文档类型：技术决策与风险评估**

---

## 执行摘要

本文档详细说明节点端简化架构方案中**5个高优先级注意点**的前因后果，帮助决策部门理解技术风险和实施要求。

**核心结论**：方案可行，但需要在实施过程中重点关注这5个关键点，确保功能完整性和系统稳定性。

---

## 一、Session 生命周期管理

### 1.1 问题背景

**当前架构中的实现**：
- 节点端需要管理多个会话（Session），每个会话包含多个任务（Job）
- 当会话结束时，需要清理该会话的所有状态数据
- 当前 `PostProcessCoordinator` 和 `DedupStage` 都有 `removeSession(sessionId)` 方法
- 这些方法会清理：
  - 去重缓存（`DedupStage` 中的 `jobIdMap`）
  - 最后发送的文本记录（`DeduplicationHandler` 中的 `lastSentText`）
  - 聚合状态（`AggregatorManager` 中的 `AggregatorState`）

**业务场景**：
- 用户结束对话，会话关闭
- 会话超时，自动清理
- 用户切换会话，需要清理旧会话状态

### 1.2 如果不处理会有什么后果？

**风险等级：高** ⚠️

1. **内存泄漏**：
   - 会话状态数据不会被清理，导致内存持续增长
   - 长时间运行后可能导致系统内存不足
   - 影响系统稳定性和性能

2. **数据污染**：
   - 旧会话的状态数据可能影响新会话
   - 去重逻辑可能失效（使用了旧会话的 `lastSentText`）
   - 聚合逻辑可能出错（使用了旧会话的 `AggregatorState`）

3. **功能异常**：
   - 去重功能失效，导致重复发送相同文本
   - 聚合功能异常，导致文本合并错误
   - 用户体验下降

**实际影响**：
- 系统运行时间越长，问题越严重
- 可能导致节点端崩溃或性能严重下降
- 需要重启节点端才能恢复正常

### 1.3 解决方案

**实施方式**：
```typescript
// 在 InferenceService 中提供统一的 session 清理接口
export class InferenceService {
  removeSession(sessionId: string): void {
    // 清理 AggregatorManager 的 session 状态
    this.servicesBundle.aggregatorManager?.removeSession(sessionId);
    
    // 清理 DedupStage 的 session 状态
    this.servicesBundle.dedupStage?.removeSession(sessionId);
    
    // 清理 DeduplicationHandler 的 session 状态
    this.servicesBundle.deduplicationHandler?.removeSession(sessionId);
    
    // 清理其他需要 session 状态管理的组件
    logger.info({ sessionId }, 'Session removed from all components');
  }
}
```

**实施要求**：
- 在 `NodeAgent.removeSession` 中调用 `InferenceService.removeSession`
- 确保所有需要 session 状态管理的组件都被清理
- 添加日志记录，便于排查问题

**工作量评估**：
- 实施时间：0.5天
- 测试时间：0.5天
- **总计：1天**

### 1.4 风险评估

- **实施风险**：低（逻辑简单，主要是调用清理方法）
- **遗漏风险**：中（如果遗漏某个组件的清理，会导致内存泄漏）
- **缓解措施**：代码审查、单元测试、集成测试

---

## 二、动态依赖更新

### 2.1 问题背景

**当前架构中的实现**：
- `InferenceService` 提供了多个动态更新方法：
  - `setAggregatorManager(aggregatorManager)`：动态更新聚合管理器
  - `setServicesHandler(servicesHandler)`：动态更新服务处理器
  - `setDeduplicationHandler(deduplicationHandler)`：动态更新去重处理器
- 这些方法在运行时被调用，用于：
  - 初始化时设置依赖（延迟初始化）
  - 运行时更新依赖（服务发现、配置变更）
  - 测试时注入 mock 对象

**业务场景**：
- 节点端启动时，某些服务可能还未就绪，需要延迟初始化
- 服务发现机制发现新服务，需要更新服务处理器
- 配置变更，需要更新聚合管理器

### 2.2 如果不处理会有什么后果？

**风险等级：中** ⚠️

1. **功能失效**：
   - 如果 `AggregatorManager` 未正确设置，聚合功能失效
   - 如果 `ServicesHandler` 未正确设置，语义修复服务无法发现
   - 如果 `DeduplicationHandler` 未正确设置，去重功能失效

2. **初始化失败**：
   - 节点端启动时可能因为依赖未设置而失败
   - 需要重启节点端才能恢复正常

3. **测试困难**：
   - 无法在测试中注入 mock 对象
   - 测试覆盖率下降

**实际影响**：
- 某些功能可能无法正常工作
- 节点端启动可能失败
- 测试和维护成本增加

### 2.3 解决方案

**实施方式**：
```typescript
// 在 InferenceService 中维护 servicesBundle，动态更新
export class InferenceService {
  private servicesBundle: ServicesBundle = {
    taskRouter: this.taskRouter,
    aggregatorManager: null,
    servicesHandler: null,
    deduplicationHandler: null,
    // ... 其他依赖
  };
  
  setAggregatorManager(aggregatorManager: AggregatorManager): void {
    this.servicesBundle.aggregatorManager = aggregatorManager;
    logger.info({}, 'AggregatorManager updated');
  }
  
  setServicesHandler(servicesHandler: ServicesHandler): void {
    this.servicesBundle.servicesHandler = servicesHandler;
    logger.info({}, 'ServicesHandler updated');
  }
  
  setDeduplicationHandler(deduplicationHandler: DeduplicationHandler): void {
    this.servicesBundle.deduplicationHandler = deduplicationHandler;
    logger.info({}, 'DeduplicationHandler updated');
  }
  
  async processJob(job: JobAssignMessage, partialCallback?: PartialResultCallback): Promise<JobResult> {
    // 使用 servicesBundle 调用 runJobPipeline
    return await runJobPipeline({
      job,
      partialCallback,
      services: this.servicesBundle,  // 使用最新的 servicesBundle
      // ...
    });
  }
}
```

**实施要求**：
- 在 `InferenceService` 中维护 `servicesBundle` 对象
- 所有动态更新方法都更新 `servicesBundle` 中的对应字段
- 不需要重新创建 `runJobPipeline`（因为它是函数，不是类）

**工作量评估**：
- 实施时间：0.5天
- 测试时间：0.5天
- **总计：1天**

### 2.4 风险评估

- **实施风险**：低（逻辑简单，主要是更新对象属性）
- **遗漏风险**：中（如果遗漏某个依赖的更新，会导致功能失效）
- **缓解措施**：代码审查、单元测试、集成测试

---

## 三、回调函数和指标收集

### 3.1 问题背景

**当前架构中的实现**：
- `InferenceService` 提供了多个回调函数：
  - `onTaskProcessedCallback(serviceName)`：任务处理完成回调
  - `onTaskStartCallback()`：任务开始回调
  - `onTaskEndCallback()`：任务结束回调
- 这些回调函数用于：
  - GPU 使用率跟踪（任务开始/结束）
  - 服务调用统计（任务处理完成）
  - 性能监控和指标收集
- 提供了指标收集方法：
  - `getRerunMetrics()`：获取 ASR 重试指标
  - `getASRMetrics()`：获取 ASR 处理指标

**业务场景**：
- 监控系统需要收集节点端的性能指标
- 调度服务器需要了解节点端的服务调用情况
- 运维人员需要监控 GPU 使用率

### 3.2 如果不处理会有什么后果？

**风险等级：高** ⚠️

1. **监控失效**：
   - 无法跟踪 GPU 使用率
   - 无法统计服务调用情况
   - 无法收集性能指标

2. **运维困难**：
   - 无法及时发现性能问题
   - 无法进行容量规划
   - 无法进行故障排查

3. **调度失效**：
   - 调度服务器无法了解节点端的实际负载
   - 负载均衡可能失效
   - 任务分配可能不均衡

**实际影响**：
- 系统监控能力下降
- 运维成本增加
- 系统可观测性降低

### 3.3 解决方案

**实施方式**：
```typescript
// 在 runJobPipeline 中支持回调函数
export async function runJobPipeline(options: {
  job: JobAssignMessage;
  partialCallback?: PartialResultCallback;
  asrCompletedCallback?: (done: boolean) => void;
  services: ServicesBundle;
  callbacks?: {
    onTaskStart?: () => void;
    onTaskEnd?: () => void;
    onTaskProcessed?: (serviceName: string) => void;
  };
}): Promise<JobResult> {
  const ctx = initJobContext(job);
  
  // 任务开始回调
  options.callbacks?.onTaskStart?.();
  
  try {
    // ASR 步骤
    if (job.pipeline?.use_asr !== false) {
      await runAsrStep(job, ctx, services, {
        partialCallback: options.partialCallback,
        asrCompletedCallback: options.asrCompletedCallback,
      });
      options.callbacks?.onTaskProcessed?.('ASR');
    }
    
    // 聚合步骤
    await runAggregationStep(job, ctx, services);
    
    // 语义修复步骤
    await runSemanticRepairStep(job, ctx, services);
    options.callbacks?.onTaskProcessed?.('SEMANTIC_REPAIR');
    
    // 去重步骤
    await runDedupStep(job, ctx, services);
    
    // 翻译步骤
    if (job.pipeline?.use_nmt !== false) {
      await runTranslationStep(job, ctx, services);
      options.callbacks?.onTaskProcessed?.('NMT');
    }
    
    // TTS 步骤
    if (job.pipeline?.use_tts !== false) {
      await runTtsStep(job, ctx, services);
      options.callbacks?.onTaskProcessed?.('TTS');
    }
    
    // TONE 步骤
    if (job.pipeline?.use_tone === true) {
      await runToneStep(job, ctx, services);
      options.callbacks?.onTaskProcessed?.('TONE');
    }
    
  } finally {
    // 任务结束回调
    options.callbacks?.onTaskEnd?.();
  }
  
  return buildJobResult(job, ctx);
}

// 指标收集：从 TaskRouter 获取
export function getRerunMetrics(services: ServicesBundle) {
  return services.taskRouter.getRerunMetrics?.() || {
    totalReruns: 0,
    successfulReruns: 0,
    failedReruns: 0,
    timeoutReruns: 0,
    qualityImprovements: 0,
  };
}

export function getASRMetrics(services: ServicesBundle) {
  return services.taskRouter.getASRMetrics?.() || {
    totalProcessed: 0,
    averageLatency: 0,
    // ... 其他指标
  };
}
```

**实施要求**：
- 在 `runJobPipeline` 中支持 `callbacks` 参数
- 在每个步骤完成后调用 `onTaskProcessed` 回调
- 在任务开始和结束时调用 `onTaskStart` 和 `onTaskEnd` 回调
- 指标收集方法从 `TaskRouter` 获取（指标收集逻辑在 TaskRouter 中）

**工作量评估**：
- 实施时间：1天
- 测试时间：0.5天
- **总计：1.5天**

### 3.4 风险评估

- **实施风险**：低（逻辑简单，主要是传递回调函数）
- **遗漏风险**：中（如果遗漏某个回调，会导致监控数据不完整）
- **缓解措施**：代码审查、单元测试、集成测试、监控验证

---

## 四、流式 ASR 支持

### 4.1 问题背景

**当前架构中的实现**：
- 节点端支持流式 ASR（Streaming ASR）功能
- 流式 ASR 可以在识别过程中返回部分结果（Partial Results）
- 部分结果通过 `partialCallback` 回调函数传递给调度服务器
- 调度服务器可以将部分结果实时显示给用户，提高用户体验

**业务场景**：
- 用户说话时，系统可以实时显示识别结果
- 不需要等待完整识别完成，用户体验更好
- 适用于实时对话场景

**技术实现**：
- `JobProcessor` 创建 `partialCallback`，发送 `asr_partial` 消息
- `PipelineOrchestrator` 将 `partialCallback` 传递给 `TaskRouter.routeASRTask`
- `TaskRouter` 调用 ASR 服务，ASR 服务在识别过程中调用 `partialCallback`

### 4.2 如果不处理会有什么后果？

**风险等级：高** ⚠️

1. **功能失效**：
   - 流式 ASR 功能完全失效
   - 用户无法看到实时识别结果
   - 用户体验严重下降

2. **业务影响**：
   - 实时对话场景无法正常工作
   - 用户需要等待完整识别完成才能看到结果
   - 系统响应速度下降

3. **兼容性问题**：
   - 如果 web 端依赖流式 ASR 功能，可能导致功能异常
   - 可能需要修改 web 端代码

**实际影响**：
- 用户体验严重下降
- 实时对话场景无法使用
- 系统功能不完整

### 4.3 解决方案

**实施方式**：
```typescript
// 在 runAsrStep 中支持流式 ASR
export async function runAsrStep(
  job: JobAssignMessage,
  ctx: JobContext,
  services: ServicesBundle,
  options?: {
    partialCallback?: PartialResultCallback;
    asrCompletedCallback?: (done: boolean) => void;
  }
) {
  // 构建 ASR 任务
  const asrTask: ASRTask = {
    audio: ctx.audio,
    audio_format: ctx.audioFormat,
    sample_rate: job.sample_rate || 16000,
    src_lang: job.src_lang,
    enable_streaming: job.enable_streaming_asr,  // 启用流式 ASR
    context_text: ctx.contextText,
    job_id: job.job_id,
    utterance_index: job.utterance_index,
    // ... 其他字段
  };
  
  logger.info(
    {
      jobId: job.job_id,
      sessionId: job.session_id,
      utteranceIndex: job.utterance_index,
      enableStreaming: job.enable_streaming_asr,
    },
    'runAsrStep: Starting ASR processing (streaming enabled)'
  );
  
  // 调用 ASR 服务（支持流式回调）
  const asrResult = await services.taskRouter.routeASRTask(
    asrTask,
    options?.partialCallback  // 传递部分结果回调
  );
  
  // 更新 JobContext
  ctx.asrText = asrResult.text;
  ctx.asrResult = asrResult;
  
  // ASR 完成回调
  options?.asrCompletedCallback?.(true);
  
  logger.info(
    {
      jobId: job.job_id,
      sessionId: job.session_id,
      utteranceIndex: job.utterance_index,
      asrTextLength: ctx.asrText?.length || 0,
    },
    'runAsrStep: ASR processing completed'
  );
}
```

**实施要求**：
- `partialCallback` 需要传递给 `TaskRouter.routeASRTask`
- `asrCompletedCallback` 需要在 ASR 完成后调用
- 确保流式 ASR 功能正常工作

**工作量评估**：
- 实施时间：0.5天
- 测试时间：1天（需要测试流式 ASR 功能）
- **总计：1.5天**

### 4.4 风险评估

- **实施风险**：低（逻辑简单，主要是传递回调函数）
- **遗漏风险**：高（如果遗漏，流式 ASR 功能完全失效）
- **缓解措施**：代码审查、单元测试、集成测试、流式 ASR 功能测试

---

## 五、上下文重置（Gate-A）

### 5.1 问题背景

**当前架构中的实现**：
- 节点端实现了 "Gate-A" 功能：当检测到连续低质量 ASR 结果时，自动重置会话上下文
- 上下文重置包括：
  - 清空 ASR prompt/context buffer
  - 清空 translation context
  - 重置 consecutiveLowQualityCount
- 这个功能由 `SessionContextManager` 实现
- 在 `PipelineOrchestrator` 中，ASR 结果包含 `shouldResetContext` 标志时，触发上下文重置

**业务场景**：
- 用户说话质量差（环境噪音、口音等），导致 ASR 识别质量持续下降
- 连续低质量识别会导致上下文污染，影响后续识别
- 重置上下文可以清除污染，提高后续识别质量

**技术实现**：
- ASR 服务检测到连续低质量结果，在返回结果中设置 `shouldResetContext` 标志
- `PipelineOrchestrator` 检查这个标志，调用 `SessionContextManager.resetContext`
- 上下文重置是异步的，不阻塞主流程

### 5.2 如果不处理会有什么后果？

**风险等级：中** ⚠️

1. **功能失效**：
   - Gate-A 功能完全失效
   - 无法自动恢复低质量识别
   - 系统无法自动处理连续低质量场景

2. **识别质量下降**：
   - 连续低质量识别会导致上下文污染
   - 后续识别质量持续下降
   - 用户体验下降

3. **需要人工干预**：
   - 用户需要手动重启会话才能恢复正常
   - 增加用户操作成本

**实际影响**：
- 在低质量识别场景下，系统无法自动恢复
- 用户体验下降
- 系统智能化程度降低

### 5.3 解决方案

**实施方式**：
```typescript
// 在 runAsrStep 中检查是否需要重置上下文
export async function runAsrStep(
  job: JobAssignMessage,
  ctx: JobContext,
  services: ServicesBundle,
  options?: { partialCallback?: any; asrCompletedCallback?: any }
) {
  // ... ASR 处理逻辑 ...
  
  // 调用 ASR 服务
  const asrResult = await services.taskRouter.routeASRTask(
    asrTask,
    options?.partialCallback
  );
  
  // Gate-A: 检查是否需要重置上下文
  if ((asrResult as any).shouldResetContext) {
    const sessionId = job.session_id || job.job_id || 'unknown';
    const resetRequest: SessionContextResetRequest = {
      sessionId,
      reason: 'consecutive_low_quality',
      jobId: job.job_id,
    };
    
    logger.info(
      {
        sessionId,
        jobId: job.job_id,
        qualityScore: asrResult.badSegmentDetection?.qualityScore,
      },
      'Gate-A: Detected shouldResetContext flag, triggering context reset'
    );
    
    // 执行上下文重置（异步，不阻塞主流程）
    services.sessionContextManager.resetContext(resetRequest, services.taskRouter)
      .then((resetResult) => {
        logger.info(
          {
            sessionId,
            jobId: job.job_id,
            resetResult,
          },
          'Gate-A: Context reset completed'
        );
      })
      .catch((error) => {
        logger.error(
          {
            sessionId,
            jobId: job.job_id,
            error: error.message,
          },
          'Gate-A: Context reset failed'
        );
      });
  }
  
  // 更新 JobContext
  ctx.asrText = asrResult.text;
  ctx.asrResult = asrResult;
  
  // ASR 完成回调
  options?.asrCompletedCallback?.(true);
}
```

**实施要求**：
- 在 `runAsrStep` 中检查 `asrResult.shouldResetContext` 标志
- 如果标志为 true，调用 `SessionContextManager.resetContext`
- 上下文重置是异步的，不阻塞主流程
- 需要传递 `SessionContextManager` 到 `servicesBundle`

**工作量评估**：
- 实施时间：0.5天
- 测试时间：0.5天
- **总计：1天**

### 5.4 风险评估

- **实施风险**：低（逻辑简单，主要是检查标志和调用方法）
- **遗漏风险**：中（如果遗漏，Gate-A 功能失效）
- **缓解措施**：代码审查、单元测试、集成测试

---

## 六、总结与建议

### 6.1 高优先级注意点汇总

| 序号 | 注意点 | 风险等级 | 工作量 | 如果不处理的后果 |
|------|--------|---------|--------|----------------|
| 1 | Session 生命周期管理 | 高 | 1天 | 内存泄漏、数据污染、功能异常 |
| 2 | 动态依赖更新 | 中 | 1天 | 功能失效、初始化失败、测试困难 |
| 3 | 回调函数和指标收集 | 高 | 1.5天 | 监控失效、运维困难、调度失效 |
| 4 | 流式 ASR 支持 | 高 | 1.5天 | 功能失效、业务影响、兼容性问题 |
| 5 | 上下文重置（Gate-A） | 中 | 1天 | 功能失效、识别质量下降、需要人工干预 |

**总工作量：6天**

### 6.2 风险评估总结

**整体风险等级：中**

- **技术风险**：低（所有注意点都有明确的解决方案）
- **实施风险**：中（需要仔细实施，确保不遗漏）
- **遗漏风险**：中（如果遗漏某个注意点，可能导致功能失效）

### 6.3 缓解措施

1. **代码审查**：
   - 每个注意点实施后都进行代码审查
   - 确保所有功能都被正确实现

2. **测试覆盖**：
   - 单元测试：测试每个注意点的功能
   - 集成测试：测试完整流程
   - 功能测试：测试各种场景

3. **监控验证**：
   - 实施后验证监控功能是否正常
   - 验证指标收集是否完整

4. **回退机制**：
   - 通过 Feature Flag 控制新旧架构切换
   - 如果出现问题，可以快速回退

### 6.4 实施建议

**推荐实施顺序**：

1. **第一阶段（2天）**：基础功能
   - Session 生命周期管理（1天）
   - 动态依赖更新（1天）

2. **第二阶段（3天）**：核心功能
   - 回调函数和指标收集（1.5天）
   - 流式 ASR 支持（1.5天）

3. **第三阶段（1天）**：增强功能
   - 上下文重置（Gate-A）（1天）

**总预计时间：6天**

### 6.5 决策建议

**✅ 建议批准实施**

**理由**：
1. 所有高优先级注意点都有明确的解决方案
2. 技术风险低，实施难度适中
3. 工作量可控（6天）
4. 有完善的缓解措施

**但需要注意**：
1. 必须按照实施顺序逐步实施
2. 每个阶段都要进行充分测试
3. 保留回退机制，确保可以快速回退

---

## 附录：详细技术说明

如需了解更详细的技术实现，请参考：
- `docs/architecture/节点端简化架构方案.md`：完整方案说明
- `docs/architecture/节点端简化架构方案可行性分析.md`：可行性分析
- `docs/architecture/节点端简化架构方案注意事项补充.md`：详细注意事项
