# 按需服务选择架构调整 - 具体实现细节

## 方案1：路由层优化（推荐）

### 核心思想

在 `InferenceService.processJob()` 中，根据 `job.pipeline.use_asr` 的值，使用 **if/else** 决定是否调用 `PipelineOrchestrator`。

### 实现方式

#### 方式1.1：简单 if/else（推荐）

```typescript
// electron_node/electron-node/main/src/inference/inference-service.ts

async processJob(job: JobAssignMessage, partialCallback?: PartialResultCallback): Promise<JobResult> {
  const wasFirstJob = !this.hasProcessedFirstJob;
  this.currentJobs.add(job.job_id);

  // 如果是第一个任务，等待服务就绪
  if (wasFirstJob) {
    this.hasProcessedFirstJob = true;
    logger.info({ jobId: job.job_id }, 'First job detected, waiting for services to be ready');
    await this.waitForServicesReady();
  }

  // 如果是第一个任务，通知任务开始
  if (wasFirstJob && this.onTaskStartCallback) {
    this.onTaskStartCallback();
  }

  try {
    // 刷新服务端点列表（带缓存机制）
    await this.taskRouter.refreshServiceEndpoints();

    // ========== 方案1：路由层优化 ==========
    // 根据 pipeline.use_asr 决定是否调用 PipelineOrchestrator
    if (job.pipeline?.use_asr === false) {
      // ASR 被禁用，直接返回空结果，跳过 PipelineOrchestrator
      logger.info(
        { 
          jobId: job.job_id, 
          sessionId: job.session_id,
          pipeline: job.pipeline 
        },
        'InferenceService: ASR disabled by pipeline config, skipping PipelineOrchestrator'
      );
      
      // ASR 完成回调（立即触发，因为 ASR 被跳过）
      // 注意：这里需要立即从 currentJobs 中移除，释放 ASR 服务容量
      this.currentJobs.delete(job.job_id);
      if (this.currentJobs.size === 0 && this.onTaskStartCallback) {
        // 如果没有任务了，通知任务结束
        if (this.onTaskEndCallback) {
          this.onTaskEndCallback();
        }
      }
      
      // 返回空结果，让 PostProcessCoordinator 处理后续阶段（翻译、TTS等）
      return this.resultBuilder.buildEmptyResult();
    } else {
      // 正常流程：调用 PipelineOrchestrator 处理 ASR
      const result = await this.pipelineOrchestrator.processJob(
        job, 
        partialCallback, 
        (asrCompleted: boolean) => {
          // ASR 完成回调：从 currentJobs 中移除，释放 ASR 服务容量
          if (asrCompleted) {
            this.currentJobs.delete(job.job_id);
            logger.debug({ jobId: job.job_id }, 'ASR completed, removed from currentJobs to free ASR service capacity');

            // 如果这是最后一个任务，通知任务结束
            if (this.currentJobs.size === 0 && this.onTaskEndCallback) {
              this.onTaskEndCallback();
            }
          }
        }
      );

      // 记录任务调用
      if (this.onTaskProcessedCallback) {
        this.onTaskProcessedCallback('pipeline');
      }

      return result;
    }
  } catch (error) {
    logger.error({ error, jobId: job.job_id, traceId: job.trace_id }, 'Pipeline orchestration failed');
    throw error;
  } finally {
    // 确保任务从 currentJobs 中移除（如果 ASR 完成回调没有执行）
    if (this.currentJobs.has(job.job_id)) {
      this.currentJobs.delete(job.job_id);

      // 如果没有任务了，通知任务结束
      if (this.currentJobs.size === 0 && this.onTaskEndCallback) {
        this.onTaskEndCallback();
      }
    }
  }
}
```

#### 方式1.2：提取为独立方法（更清晰）

```typescript
// electron_node/electron-node/main/src/inference/inference-service.ts

async processJob(job: JobAssignMessage, partialCallback?: PartialResultCallback): Promise<JobResult> {
  const wasFirstJob = !this.hasProcessedFirstJob;
  this.currentJobs.add(job.job_id);

  // 如果是第一个任务，等待服务就绪
  if (wasFirstJob) {
    this.hasProcessedFirstJob = true;
    logger.info({ jobId: job.job_id }, 'First job detected, waiting for services to be ready');
    await this.waitForServicesReady();
  }

  // 如果是第一个任务，通知任务开始
  if (wasFirstJob && this.onTaskStartCallback) {
    this.onTaskStartCallback();
  }

  try {
    // 刷新服务端点列表
    await this.taskRouter.refreshServiceEndpoints();

    // 根据 pipeline 配置决定处理路径
    if (job.pipeline?.use_asr === false) {
      return await this.processJobWithoutASR(job);
    } else {
      return await this.processJobWithASR(job, partialCallback);
    }
  } catch (error) {
    logger.error({ error, jobId: job.job_id, traceId: job.trace_id }, 'Pipeline orchestration failed');
    throw error;
  } finally {
    // 确保任务从 currentJobs 中移除
    if (this.currentJobs.has(job.job_id)) {
      this.currentJobs.delete(job.job_id);
      if (this.currentJobs.size === 0 && this.onTaskEndCallback) {
        this.onTaskEndCallback();
      }
    }
  }
}

/**
 * 处理不需要 ASR 的任务（例如：只选择 NMT 的文本翻译模式）
 */
private async processJobWithoutASR(job: JobAssignMessage): Promise<JobResult> {
  logger.info(
    { 
      jobId: job.job_id, 
      sessionId: job.session_id,
      pipeline: job.pipeline 
    },
    'InferenceService: Processing job without ASR (pipeline.use_asr=false)'
  );
  
  // 立即从 currentJobs 中移除（因为没有 ASR 处理）
  this.currentJobs.delete(job.job_id);
  if (this.currentJobs.size === 0 && this.onTaskEndCallback) {
    this.onTaskEndCallback();
  }
  
  // 返回空结果，让 PostProcessCoordinator 处理后续阶段
  return this.resultBuilder.buildEmptyResult();
}

/**
 * 处理需要 ASR 的任务（正常流程）
 */
private async processJobWithASR(
  job: JobAssignMessage, 
  partialCallback?: PartialResultCallback
): Promise<JobResult> {
  const result = await this.pipelineOrchestrator.processJob(
    job, 
    partialCallback, 
    (asrCompleted: boolean) => {
      // ASR 完成回调
      if (asrCompleted) {
        this.currentJobs.delete(job.job_id);
        logger.debug({ jobId: job.job_id }, 'ASR completed, removed from currentJobs');

        if (this.currentJobs.size === 0 && this.onTaskEndCallback) {
          this.onTaskEndCallback();
        }
      }
    }
  );

  // 记录任务调用
  if (this.onTaskProcessedCallback) {
    this.onTaskProcessedCallback('pipeline');
  }

  return result;
}
```

### 优点

- ✅ **简单直接**：使用 if/else，代码清晰易懂
- ✅ **改动最小**：只需修改 `InferenceService.processJob()` 一个方法
- ✅ **向后兼容**：不影响现有功能，`use_asr` 默认为 `true` 时行为不变
- ✅ **性能优化**：`use_asr=false` 时完全跳过 `PipelineOrchestrator`，避免不必要的调用

### 注意事项

1. **ASR 完成回调**：`use_asr=false` 时，需要立即从 `currentJobs` 中移除，释放 ASR 服务容量
2. **任务结束回调**：确保在没有任务时正确调用 `onTaskEndCallback`
3. **保留 PipelineOrchestrator 的检查**：作为双重保险，即使路由层判断错误，`PipelineOrchestrator` 内部也会检查

---

## 方案2：统一编排器（更彻底的重构）

### 核心思想

创建一个统一的编排器（`UnifiedPipelineOrchestrator`），根据 `pipeline` 配置动态决定执行哪些阶段，而不是使用 if/else 硬编码。

### 实现方式

#### 架构设计

```
NodeAgent
  └─> JobProcessor.processJob()
       └─> UnifiedPipelineOrchestrator.processJob()
            ├─> Stage Router (根据 pipeline 配置决定执行哪些阶段)
            ├─> ASR Stage (if use_asr=true)
            ├─> Aggregation Stage (if use_asr=true)
            ├─> Semantic Repair Stage (if use_asr=true)
            ├─> Translation Stage (if use_nmt=true)
            ├─> TTS Stage (if use_tts=true)
            └─> TONE Stage (if use_tone=true)
```

#### 实现代码

##### 步骤1：定义阶段接口

```typescript
// electron_node/electron-node/main/src/pipeline-orchestrator/unified/stage.ts

export interface PipelineStage {
  /**
   * 阶段名称
   */
  name: string;

  /**
   * 检查是否应该执行此阶段
   */
  shouldExecute(job: JobAssignMessage, context: PipelineContext): boolean;

  /**
   * 执行阶段
   */
  execute(job: JobAssignMessage, context: PipelineContext): Promise<StageResult>;
}

export interface PipelineContext {
  // 输入数据
  audio?: string;
  audioFormat?: string;
  inputText?: string;
  
  // 中间结果
  asrText?: string;
  aggregatedText?: string;
  semanticRepairedText?: string;
  translatedText?: string;
  ttsAudio?: string;
  toneAudio?: string;
  
  // 元数据
  qualityScore?: number;
  semanticRepairApplied?: boolean;
  semanticRepairConfidence?: number;
}

export interface StageResult {
  // 更新 context 中的数据
  contextUpdates: Partial<PipelineContext>;
  
  // 是否继续执行下一个阶段
  shouldContinue: boolean;
  
  // 错误信息（如果有）
  error?: Error;
}
```

##### 步骤2：实现各个阶段

```typescript
// electron_node/electron-node/main/src/pipeline-orchestrator/unified/stages/asr-stage.ts

export class ASRStage implements PipelineStage {
  name = 'ASR';

  constructor(
    private asrHandler: ASRHandler,
    private taskRouter: TaskRouter
  ) {}

  shouldExecute(job: JobAssignMessage, context: PipelineContext): boolean {
    return job.pipeline?.use_asr !== false;
  }

  async execute(job: JobAssignMessage, context: PipelineContext): Promise<StageResult> {
    // 执行 ASR 处理
    const asrResult = await this.asrHandler.process(job, context.audio);
    
    return {
      contextUpdates: {
        asrText: asrResult.text,
        qualityScore: asrResult.quality_score,
      },
      shouldContinue: true,
    };
  }
}
```

```typescript
// electron_node/electron-node/main/src/pipeline-orchestrator/unified/stages/translation-stage.ts

export class TranslationStage implements PipelineStage {
  name = 'Translation';

  constructor(
    private translationHandler: TranslationHandler,
    private taskRouter: TaskRouter
  ) {}

  shouldExecute(job: JobAssignMessage, context: PipelineContext): boolean {
    return job.pipeline?.use_nmt !== false;
  }

  async execute(job: JobAssignMessage, context: PipelineContext): Promise<StageResult> {
    // 确定要翻译的文本
    const textToTranslate = context.semanticRepairedText || context.aggregatedText || context.asrText || context.inputText || '';
    
    if (!textToTranslate || textToTranslate.trim().length === 0) {
      return {
        contextUpdates: {},
        shouldContinue: true, // 继续执行，即使没有文本
      };
    }

    // 执行翻译
    const translationResult = await this.translationHandler.process(job, textToTranslate);
    
    return {
      contextUpdates: {
        translatedText: translationResult.text,
      },
      shouldContinue: true,
    };
  }
}
```

##### 步骤3：创建统一编排器

```typescript
// electron_node/electron-node/main/src/pipeline-orchestrator/unified/unified-pipeline-orchestrator.ts

export class UnifiedPipelineOrchestrator {
  private stages: PipelineStage[] = [];

  constructor(
    private asrHandler: ASRHandler,
    private translationHandler: TranslationHandler,
    private ttsHandler: TTSHandler,
    private toneHandler: TONEHandler,
    private aggregationHandler: AggregationHandler,
    private semanticRepairHandler: SemanticRepairHandler,
    private taskRouter: TaskRouter
  ) {
    // 注册所有阶段（按执行顺序）
    this.stages = [
      new ASRStage(asrHandler, taskRouter),
      new AggregationStage(aggregationHandler),
      new SemanticRepairStage(semanticRepairHandler, taskRouter),
      new TranslationStage(translationHandler, taskRouter),
      new TTSStage(ttsHandler, taskRouter),
      new TONEStage(toneHandler, taskRouter),
    ];
  }

  async processJob(
    job: JobAssignMessage,
    partialCallback?: PartialResultCallback,
    asrCompletedCallback?: (asrCompleted: boolean) => void
  ): Promise<JobResult> {
    const startTime = Date.now();
    
    // 初始化上下文
    const context: PipelineContext = {
      audio: job.audio,
      audioFormat: job.audio_format,
      inputText: (job as any).input_text || (job as any).text,
    };

    // 按顺序执行各个阶段
    for (const stage of this.stages) {
      // 检查是否应该执行此阶段
      if (!stage.shouldExecute(job, context)) {
        logger.debug(
          { 
            jobId: job.job_id, 
            stageName: stage.name,
            pipeline: job.pipeline 
          },
          `UnifiedPipelineOrchestrator: Skipping stage ${stage.name} (disabled by pipeline config)`
        );
        continue;
      }

      try {
        // 执行阶段
        logger.debug(
          { jobId: job.job_id, stageName: stage.name },
          `UnifiedPipelineOrchestrator: Executing stage ${stage.name}`
        );

        const stageResult = await stage.execute(job, context);

        // 更新上下文
        Object.assign(context, stageResult.contextUpdates);

        // 检查是否应该继续执行
        if (!stageResult.shouldContinue) {
          logger.info(
            { jobId: job.job_id, stageName: stage.name },
            `UnifiedPipelineOrchestrator: Stage ${stage.name} requested to stop pipeline`
          );
          break;
        }

        // 特殊处理：ASR 完成回调
        if (stage.name === 'ASR' && asrCompletedCallback) {
          asrCompletedCallback(true);
        }

        // 特殊处理：ASR 部分结果回调
        if (stage.name === 'ASR' && partialCallback && context.asrText) {
          partialCallback({
            text: context.asrText,
            is_final: true,
            confidence: context.qualityScore || 0,
          });
        }

      } catch (error) {
        logger.error(
          { 
            error, 
            jobId: job.job_id, 
            stageName: stage.name 
          },
          `UnifiedPipelineOrchestrator: Stage ${stage.name} failed`
        );
        
        // 根据阶段的重要性决定是否继续
        if (stage.name === 'ASR') {
          // ASR 失败，整个流程失败
          throw error;
        } else {
          // 其他阶段失败，记录错误但继续执行
          logger.warn(
            { jobId: job.job_id, stageName: stage.name },
            `UnifiedPipelineOrchestrator: Stage ${stage.name} failed, continuing with next stage`
          );
        }
      }
    }

    // 构建最终结果
    return this.buildResult(job, context, startTime);
  }

  private buildResult(job: JobAssignMessage, context: PipelineContext, startTime: number): JobResult {
    return {
      text_asr: context.asrText || context.aggregatedText || '',
      text_translated: context.translatedText || '',
      tts_audio: context.toneAudio || context.ttsAudio || '',
      tts_format: 'opus',
      quality_score: context.qualityScore || 0,
      semantic_repair_applied: context.semanticRepairApplied || false,
      semantic_repair_confidence: context.semanticRepairConfidence || 0,
      aggregation_applied: !!context.aggregatedText && context.aggregatedText !== context.asrText,
      aggregation_action: context.aggregation_applied ? 'MERGE' : 'NEW_STREAM',
      // ... 其他字段
    };
  }
}
```

##### 步骤4：在 InferenceService 中使用统一编排器

```typescript
// electron_node/electron-node/main/src/inference/inference-service.ts

async processJob(job: JobAssignMessage, partialCallback?: PartialResultCallback): Promise<JobResult> {
  // ... 现有代码（首次任务检查等）...

  try {
    await this.taskRouter.refreshServiceEndpoints();

    // 使用统一编排器（不再需要 if/else）
    const result = await this.unifiedPipelineOrchestrator.processJob(
      job, 
      partialCallback, 
      (asrCompleted: boolean) => {
        if (asrCompleted) {
          this.currentJobs.delete(job.job_id);
          if (this.currentJobs.size === 0 && this.onTaskEndCallback) {
            this.onTaskEndCallback();
          }
        }
      }
    );

    return result;
  } catch (error) {
    // ... 错误处理 ...
  }
}
```

### 优点

- ✅ **高度灵活**：支持任意服务组合，不需要硬编码 if/else
- ✅ **易于扩展**：添加新阶段只需实现 `PipelineStage` 接口
- ✅ **架构清晰**：所有阶段统一管理，职责明确
- ✅ **支持条件依赖**：可以在 `shouldExecute` 中定义复杂的依赖关系

### 缺点

- ❌ **改动巨大**：需要重构大量代码，影响现有功能
- ❌ **风险较高**：可能引入新的 bug，需要大量测试
- ❌ **复杂度增加**：需要维护阶段注册、上下文管理等额外逻辑

---

## 方案对比

| 特性 | 方案1：路由层优化 | 方案2：统一编排器 |
|------|------------------|------------------|
| **实现方式** | if/else 判断 | 阶段注册 + 动态执行 |
| **代码改动** | 小（1个文件，~50行） | 大（多个文件，~500行） |
| **风险** | 低 | 高 |
| **灵活性** | 中等（支持当前需求） | 高（支持任意组合） |
| **可维护性** | 高（代码简单） | 中（需要理解阶段系统） |
| **性能** | 高（直接跳过） | 中（需要遍历阶段） |
| **推荐度** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |

---

## 推荐实施

**推荐方案1（路由层优化）**，原因：

1. **满足当前需求**：支持所有已定义的服务组合场景
2. **改动最小**：只需修改 `InferenceService.processJob()` 一个方法
3. **风险最低**：向后兼容，不影响现有功能
4. **易于维护**：代码简单清晰，易于理解和调试

**如果未来需要更复杂的服务组合**（例如：条件依赖、并行执行等），再考虑迁移到方案2。
