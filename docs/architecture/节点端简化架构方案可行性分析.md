# 节点端简化架构方案可行性分析

## 方案概述

将 `PipelineOrchestrator` 和 `PostProcessCoordinator` 合并成一个 `JobPipeline`，所有步骤都是普通函数，使用统一的 `JobContext` 传递状态。

## 可行性评估

### ✅ 优点

1. **架构简化**：
   - 消除多层抽象（Stage/Orchestrator/Coordinator）
   - 所有逻辑集中在一个文件，易于理解
   - 减少代码跳转，提高可读性

2. **维护成本降低**：
   - 新开发人员可以快速理解整个流程
   - 修改逻辑只需要在一个地方
   - 减少类之间的依赖关系

3. **符合项目现状**：
   - 项目尚未上线，可以大胆重构
   - 不需要考虑向后兼容

### ⚠️ 潜在问题和挑战

#### 1. **状态管理复杂度**

**问题**：
- 当前各个 Stage 类有独立的状态管理（如 `AggregationStage` 维护 `AggregatorState`）
- 状态传递和更新需要仔细设计

**解决方案**：
```typescript
// JobContext 只包含数据状态，不包含业务逻辑状态
export interface JobContext {
  // ASR 相关
  audio?: Buffer;                      // 只在 ASR 步骤需要，之后可以清除
  asrText?: string;                    // ASR 结果
  asrResult?: ASRResult;               // ASR 完整结果（包含 segments 等）
  
  // 聚合相关
  aggregatedText?: string;             // 聚合后的文本（覆盖 asrText）
  aggregationAction?: 'MERGE' | 'NEW_STREAM' | 'COMMIT';
  aggregationChanged?: boolean;
  
  // 语义修复相关
  repairedText?: string;               // 修复后的文本（覆盖 aggregatedText）
  semanticDecision?: 'PASS' | 'REPAIR' | 'REJECT';
  semanticRepairApplied?: boolean;
  semanticRepairConfidence?: number;
  
  // 翻译相关
  translatedText?: string;
  
  // TTS/TONE 相关（音频数据存储在 JobContext 中）
  ttsAudio?: string;                   // base64 编码的 TTS 音频
  ttsFormat?: string;                  // 'opus' | 'wav' | 'pcm16'
  toneAudio?: string;                  // base64 编码的 TONE 音频
  toneFormat?: string;                 // 'opus' | 'wav' | 'pcm16'
  speakerId?: string;                  // TONE 音色ID
  
  // 控制流
  shouldSend?: boolean;
  dedupReason?: string;
  error?: string;
}
```

**建议**：
- `JobContext` 只包含**数据状态**，不包含**业务逻辑状态**
- 业务逻辑状态（如 `AggregatorState`）仍然由工具类（`AggregatorManager`）管理
- `JobContext` 作为数据传递的载体，音频数据也包含在其中（~25-35KB，可接受）
- 音频数据只在内存中存在很短时间（处理完成后立即发送），性能影响可接受

#### 2. **依赖注入和初始化**

**问题**：
- 当前各个 Stage 类在构造函数中初始化依赖（如 `TaskRouter`、`AggregatorManager`）
- 如果改为普通函数，需要将依赖作为参数传递

**解决方案**：
```typescript
// 方案A：通过 services 参数传递
export async function runAsrStep(
  job: JobAssignMessage,
  ctx: JobContext,
  services: {
    taskRouter: TaskRouter;
    audioAggregator: AudioAggregator;
    aggregatorManager: AggregatorManager;
    // ...
  },
  options?: { partialCallback?: any; asrCompletedCallback?: any }
) {
  // ...
}

// 方案B：使用依赖注入容器
export async function runAsrStep(
  job: JobAssignMessage,
  ctx: JobContext,
  di: DependencyContainer,  // 依赖注入容器
  options?: { partialCallback?: any; asrCompletedCallback?: any }
) {
  const taskRouter = di.get<TaskRouter>('taskRouter');
  const audioAggregator = di.get<AudioAggregator>('audioAggregator');
  // ...
}
```

**建议**：
- 使用**方案A**（services 参数），更简单直接
- 在 `InferenceService` 中构建 `servicesBundle`，传递给 `runJobPipeline`

#### 3. **错误处理和回退机制**

**问题**：
- 当前各个 Stage 类有独立的错误处理逻辑
- 如果某个步骤失败，需要决定是否继续执行后续步骤

**解决方案**：
```typescript
export async function runJobPipeline(options) {
  const ctx = initJobContext(job);
  
  try {
    if (job.pipeline?.use_asr !== false) {
      await runAsrStep(job, ctx, services, { partialCallback, asrCompletedCallback });
      // 如果 ASR 失败，ctx.asrText 可能为空，但继续执行后续步骤
    }
    
    // 聚合步骤：如果 ASR 失败，可能跳过
    if (ctx.asrText && ctx.asrText.trim().length > 0) {
      await runAggregationStep(job, ctx, services);
      await runSemanticRepairStep(job, ctx, services);
      await runDedupStep(job, ctx, services);
    }
    
    // 翻译步骤：即使 ASR 失败，如果 use_asr=false，仍然可以执行
    if (job.pipeline?.use_nmt !== false) {
      if (job.pipeline?.use_asr === false) {
        // 只选择 NMT 模式，使用 job.input_text
        ctx.textToTranslate = (job as any).input_text;
      } else {
        // 使用聚合和修复后的文本
        ctx.textToTranslate = ctx.repairedText || ctx.aggregatedText;
      }
      
      if (ctx.textToTranslate && ctx.textToTranslate.trim().length > 0) {
        await runTranslationStep(job, ctx, services);
      }
    }
    
    // TTS 和 TONE 步骤类似...
    
  } catch (error) {
    logger.error({ error, jobId: job.job_id }, 'JobPipeline: Error occurred');
    ctx.shouldSend = false;
    ctx.error = error.message;
  }
  
  return buildJobResult(job, ctx);
}
```

**建议**：
- 每个步骤内部处理自己的错误，不抛出异常（除非是致命错误）
- 通过 `ctx.shouldSend` 和 `ctx.error` 控制流程
- 在 `runJobPipeline` 中统一处理致命错误

#### 4. **SequentialExecutor 和 GpuArbiter 集成**

**问题**：
- 当前 `TTSStage` 和 `TONEStage` 使用 `SequentialExecutor` 确保顺序执行
- 使用 `withGpuLease` 管理 GPU 资源
- 如果改为普通函数，需要将这些逻辑集成到步骤中

**解决方案**：
```typescript
export async function runTtsStep(
  job: JobAssignMessage,
  ctx: JobContext,
  services: {
    taskRouter: TaskRouter;
    sequentialExecutor: SequentialExecutor;
    gpuArbiter: GpuArbiter;
  }
) {
  if (!ctx.translatedText || ctx.translatedText.trim().length === 0) {
    return;  // 跳过
  }
  
  // 使用 SequentialExecutor 确保顺序执行
  const executor = services.sequentialExecutor;
  await executor.execute(
    job.session_id,
    job.utterance_index,
    'TTS',
    async () => {
      // 使用 GPU 租约
      return await withGpuLease(
        'TTS',
        async () => {
          const ttsResult = await services.taskRouter.routeTTSTask({
            text: ctx.translatedText!,
            tgt_lang: job.tgt_lang,
            // ...
          });
          
          ctx.ttsAudio = ttsResult.audio;
          ctx.ttsFormat = ttsResult.format;
        }
      );
    }
  );
}
```

**建议**：
- 将 `SequentialExecutor` 和 `GpuArbiter` 作为 `services` 的一部分传递
- 在步骤函数内部使用，保持逻辑不变

#### 5. **测试复杂度**

**问题**：
- 当前各个 Stage 类可以独立测试
- 如果改为普通函数，需要 mock 更多的依赖

**解决方案**：
```typescript
// 测试示例
describe('runAsrStep', () => {
  it('should process ASR correctly', async () => {
    const job = createMockJob();
    const ctx = initJobContext(job);
    const services = {
      taskRouter: mockTaskRouter,
      audioAggregator: mockAudioAggregator,
      // ...
    };
    
    await runAsrStep(job, ctx, services);
    
    expect(ctx.asrText).toBeDefined();
    expect(ctx.asrResult).toBeDefined();
  });
});
```

**建议**：
- 每个步骤函数仍然可以独立测试
- 需要 mock 的依赖通过 `services` 参数传递，测试更容易

## 实施建议

### 阶段1：创建新架构（并行开发）

1. **创建 `pipeline/job-pipeline.ts`**：
   - 定义 `JobContext` 接口
   - 实现 `runJobPipeline` 主函数
   - 实现 `buildJobResult` 函数

2. **创建 `steps/` 目录**：
   - 逐个迁移步骤函数
   - 先从简单的开始（如 `runDedupStep`）
   - 再迁移复杂的（如 `runAsrStep`、`runAggregationStep`）

3. **保持旧架构运行**：
   - 新架构和旧架构并行存在
   - 通过 Feature Flag 控制使用哪个架构

### 阶段2：迁移和测试

1. **逐个迁移步骤**：
   - 每个步骤迁移后，进行单元测试
   - 确保功能一致

2. **集成测试**：
   - 测试完整的流水线
   - 测试各种配置组合（use_asr、use_nmt、use_tts、use_tone）

3. **性能测试**：
   - 对比新旧架构的性能
   - 确保没有性能回退

### 阶段3：清理旧代码

1. **删除旧架构**：
   - 删除 `PipelineOrchestrator`
   - 删除 `PostProcessCoordinator`
   - 删除所有 Stage 类

2. **更新文档**：
   - 更新架构文档
   - 更新开发指南

## 风险评估

### 高风险项

1. **状态管理**：
   - 状态传递和更新需要仔细设计
   - **缓解措施**：仔细设计 `JobContext`，只包含数据状态，业务逻辑状态由工具类管理
   - **注意**：音频数据存储在 JobContext 中是合理的（~25-35KB），性能影响可接受

2. **错误处理**：
   - 错误处理逻辑可能分散
   - **缓解措施**：统一错误处理策略，在 `runJobPipeline` 中集中处理

3. **测试覆盖**：
   - 需要大量测试确保功能一致
   - **缓解措施**：逐步迁移，每个步骤都进行测试

### 中风险项

1. **依赖注入**：
   - `services` 参数可能变得很大
   - **缓解措施**：使用 TypeScript 接口定义 `ServicesBundle`，类型安全

2. **代码迁移**：
   - 迁移过程中可能出现 bug
   - **缓解措施**：并行开发，逐步切换，保留回退机制

## 结论

### ✅ 方案可行，但需要注意以下几点：

1. **状态管理**：
   - `JobContext` 只包含数据状态，业务逻辑状态由工具类管理
   - 音频数据存储在 JobContext 中是合理的（~25-35KB），性能影响可接受
   - 不需要担心 JobContext 大小问题

2. **依赖注入**：
   - 使用 `services` 参数传递依赖，保持简单
   - 使用 TypeScript 接口确保类型安全

3. **错误处理**：
   - 统一错误处理策略
   - 每个步骤内部处理自己的错误，不抛出异常（除非致命）

4. **测试策略**：
   - 逐步迁移，每个步骤都进行测试
   - 保留旧架构作为回退机制

5. **实施计划**：
   - 分阶段实施，降低风险
   - 并行开发，逐步切换

### 推荐实施顺序

1. **先实施简单步骤**（1-2天）：
   - `runDedupStep`
   - `runTranslationStep`
   - `runTtsStep`
   - `runToneStep`

2. **再实施复杂步骤**（3-5天）：
   - `runAsrStep`
   - `runAggregationStep`
   - `runSemanticRepairStep`

3. **集成和测试**（2-3天）：
   - 完整流水线测试
   - 性能测试
   - 错误场景测试

4. **清理旧代码**（1天）：
   - 删除旧架构
   - 更新文档

**总预计时间：7-11天**

## 最终建议

**✅ 方案可行，建议实施**

但需要注意：
- 仔细设计 `JobContext`，只包含数据状态，业务逻辑状态由工具类管理
- 音频数据存储在 JobContext 中是合理的，不需要担心大小问题
- 统一错误处理策略
- 逐步迁移，充分测试
- 保留回退机制

如果实施得当，这个方案可以显著简化架构，提高可维护性。

---

## 补充注意事项

除了上述提到的问题，还需要注意以下关键点：

### 1. **Session 生命周期管理**
- 当前 `PostProcessCoordinator` 和 `DedupStage` 都有 `removeSession` 方法
- 新架构需要提供统一的 session 清理接口
- 确保所有需要 session 状态管理的组件都被清理

### 2. **动态依赖更新**
- 当前 `InferenceService` 有 `setAggregatorManager`、`setServicesHandler` 等方法
- 新架构中 `runJobPipeline` 是函数，不需要重新创建
- 只需要更新 `servicesBundle` 中的依赖即可

### 3. **回调函数和指标收集**
- 需要支持 `onTaskProcessedCallback`、`onTaskStartCallback`、`onTaskEndCallback`
- 需要支持 `getRerunMetrics()`、`getASRMetrics()` 等指标收集方法
- 回调函数通过 `options.callbacks` 传递，指标从 `TaskRouter` 获取

### 4. **服务就绪检查**
- 保留 `waitForServicesReady(job)` 逻辑
- 在调用 `runJobPipeline` 之前执行

### 5. **流式 ASR 支持**
- 需要支持 `partialCallback`（部分结果回调）
- 需要支持 `asrCompletedCallback`（ASR 完成回调）
- 这些回调需要传递给 `TaskRouter.routeASRTask`

### 6. **上下文重置（Gate-A）**
- 需要支持 `SessionContextManager.resetContext`
- 上下文重置是异步的，不阻塞主流程
- 需要在 `runAsrStep` 中检查 `shouldResetContext` 标志

### 7. **日志和监控**
- 保持与当前架构相同的日志格式和内容
- 每个步骤都应该记录处理时间
- 确保日志包含足够的调试信息

### 8. **错误恢复和重试机制**
- 保留 ASR 重试机制（`rerun_count`）
- 重试逻辑主要在 `TaskRouter` 中处理
- `JobContext` 只需要记录重试次数

### 9. **数据验证和边界检查**
- 每个步骤都需要验证输入数据
- 验证失败时应该跳过步骤，而不是抛出异常

### 10. **类型安全和接口一致性**
- 确保 `buildJobResult` 返回的 `JobResult` 与现有接口完全一致
- 确保所有字段都正确映射

**详细说明请参考**：`docs/architecture/节点端简化架构方案注意事项补充.md`
