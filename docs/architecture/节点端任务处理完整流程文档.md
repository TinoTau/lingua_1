# 节点端任务处理完整流程文档

**版本：v1.0**  
**日期：2024年**  
**状态：✅ 基于实际代码生成**

## 概述

本文档详细描述节点端任务处理的完整流程，包括每一步调用的具体方法和数据流转。所有内容基于实际代码生成，确保准确性。

## 整体流程架构

```
调度服务器 (WebSocket)
  ↓ job_assign
NodeAgent.handleJobAssign()
  ↓
JobProcessor.processJob()
  ↓
InferenceService.processJob()
  ↓
runJobPipeline() [唯一编排器]
  ├─ runAsrStep()
  ├─ runAggregationStep()
  ├─ runSemanticRepairStep()
  ├─ runDedupStep()
  ├─ runTranslationStep()
  ├─ runTtsStep()
  └─ runToneStep()
  ↓
buildJobResult()
  ↓
JobProcessor (TTS格式转换)
  ↓
ResultSender.sendJobResult()
  ↓ job_result
调度服务器 (WebSocket)
```

## 详细流程说明

### 1. NodeAgent.handleJobAssign()

**文件位置：** `electron_node/electron-node/main/src/agent/node-agent.ts`

**调用方法：**
- `JobProcessor.processJob(job, startTime)`

**功能：**
- 接收来自调度服务器的 `job_assign` 消息
- 调用 JobProcessor 处理任务

---

### 2. JobProcessor.processJob()

**文件位置：** `electron_node/electron-node/main/src/agent/node-agent-job-processor.ts`

**调用方法：**
1. `pythonServiceManager.startService('speaker_embedding')` - 如果启用 speaker_identification 功能
2. 创建 `partialCallback`（如果启用流式 ASR）
3. `inferenceService.processJob(job, partialCallback)` - 调用推理服务
4. `convertWavToOpus()` - 如果 TTS 音频是 WAV 格式，转换为 Opus

**功能：**
- 根据 features 启动所需服务
- 设置流式 ASR 部分结果回调
- 调用 InferenceService 处理任务
- 处理 TTS 音频格式转换（WAV → Opus）

**返回：**
- `{ finalResult: JobResult, shouldSend: boolean, reason?: string }`

---

### 3. InferenceService.processJob()

**文件位置：** `electron_node/electron-node/main/src/inference/inference-service.ts`

**调用方法：**
1. `waitForServicesReady()` - 如果是第一个任务，等待服务就绪
2. `onTaskStartCallback?.()` - 任务开始回调（GPU跟踪）
3. `taskRouter.refreshServiceEndpoints()` - 刷新服务端点列表
4. `runJobPipeline(options)` - 调用 JobPipeline（唯一编排器）
5. `onTaskEndCallback?.()` - 任务结束回调（GPU跟踪）

**功能：**
- 服务就绪检查（首次任务）
- 服务端点刷新
- 调用 JobPipeline 处理任务
- 管理 currentJobs 集合（ASR 完成后移除）

**返回：**
- `JobResult`

---

### 4. runJobPipeline() [唯一编排器]

**文件位置：** `electron_node/electron-node/main/src/pipeline/job-pipeline.ts`

**调用方法：**
1. `initJobContext(job)` - 初始化 JobContext
2. `callbacks?.onTaskStart?.()` - 任务开始回调
3. `runAsrStep()` - ASR 步骤（如果 `use_asr !== false`）
4. `callbacks?.onTaskProcessed?.('ASR')` - ASR 完成回调
5. `runAggregationStep()` - 聚合步骤
6. `callbacks?.onTaskProcessed?.('AGGREGATION')` - 聚合完成回调
7. `runSemanticRepairStep()` - 语义修复步骤
8. `callbacks?.onTaskProcessed?.('SEMANTIC_REPAIR')` - 语义修复完成回调
9. `runDedupStep()` - 去重步骤
10. `runTranslationStep()` - 翻译步骤（如果 `use_nmt !== false`）
11. `callbacks?.onTaskProcessed?.('NMT')` - 翻译完成回调
12. `runTtsStep()` - TTS 步骤（如果 `use_tts !== false`）
13. `callbacks?.onTaskProcessed?.('TTS')` - TTS 完成回调
14. `runToneStep()` - TONE 步骤（如果 `use_tone === true`）
15. `callbacks?.onTaskProcessed?.('TONE')` - TONE 完成回调
16. `callbacks?.onTaskEnd?.()` - 任务结束回调
17. `buildJobResult(job, ctx)` - 构建最终结果

**功能：**
- 按顺序执行所有步骤
- 管理回调函数（任务开始/结束/步骤完成）
- 构建最终 JobResult

**返回：**
- `JobResult`

---

### 5. runAsrStep() - ASR 步骤

**文件位置：** `electron_node/electron-node/main/src/pipeline/steps/asr-step.ts`

**调用方法：**
1. `new AudioAggregator()` - 创建音频聚合器
2. `new PipelineOrchestratorAudioProcessor(audioAggregator)` - 创建音频处理器
3. `new PipelineOrchestratorASRResultProcessor()` - 创建 ASR 结果处理器
4. `new PipelineOrchestratorASRHandler(taskRouter, aggregatorManager)` - 创建 ASR 处理器
5. `asrHandler.buildPrompt(job)` - 构建 prompt（如果启用 S1）
6. `audioProcessor.processAudio(job)` - 处理音频（聚合和格式转换）
7. `asrHandler.processASRStreaming()` 或 `withGpuLease()` + `taskRouter.routeASRTask()` - 调用 ASR 服务
8. `asrResultProcessor.processASRResult(job, asrResult)` - 处理 ASR 结果（空文本检查）
9. `sessionContextManager.resetContext()` - Gate-A：如果检测到需要重置上下文（异步）

**更新 JobContext：**
- `ctx.asrText = asrResult.text`
- `ctx.asrResult = asrResult`
- `ctx.asrSegments = asrResult.segments`
- `ctx.languageProbabilities = asrResult.language_probabilities`
- `ctx.qualityScore = asrResult.badSegmentDetection?.qualityScore`
- `ctx.rerunCount = job.rerun_count`

**功能：**
- 音频聚合和格式转换
- ASR 识别（支持流式和非流式）
- Gate-A 上下文重置（如果检测到连续低质量）
- 空文本和无意义文本检查

**跳过条件：**
- `job.pipeline?.use_asr === false` - 在 runJobPipeline 中检查

---

### 6. runAggregationStep() - 聚合步骤

**文件位置：** `electron_node/electron-node/main/src/pipeline/steps/aggregation-step.ts`

**调用方法：**
1. `new AggregationStage(aggregatorManager, aggregatorMiddleware, deduplicationHandler)` - 创建聚合 Stage
2. `aggregationStage.process(job, tempResult)` - 执行聚合

**更新 JobContext：**
- `ctx.aggregatedText = aggregationResult.aggregatedText`
- `ctx.aggregationAction = aggregationResult.action`
- `ctx.aggregationChanged = aggregationResult.aggregationChanged`
- `ctx.isLastInMergedGroup = aggregationResult.isLastInMergedGroup`
- `ctx.aggregationMetrics = aggregationResult.metrics`

**功能：**
- 文本聚合（MERGE / NEW_STREAM / COMMIT）
- 去重和向前合并
- 边界重叠裁剪

**跳过条件：**
- `ctx.asrText` 为空 - 在步骤内部检查
- `services.aggregatorManager` 不存在 - 在步骤内部检查

---

### 7. runSemanticRepairStep() - 语义修复步骤

**文件位置：** `electron_node/electron-node/main/src/pipeline/steps/semantic-repair-step.ts`

**调用方法：**
1. `new SemanticRepairInitializer(servicesHandler, taskRouter)` - 创建语义修复初始化器
2. `semanticRepairInitializer.initialize()` - 初始化语义修复（如果尚未初始化）
3. `semanticRepairInitializer.getSemanticRepairStage()` - 获取语义修复 Stage
4. `aggregatorManager.getLastCommittedText(sessionId, textToRepair)` - 获取微上下文
5. `semanticRepairStage.process(job, textToRepair, qualityScore, meta)` - 执行语义修复

**更新 JobContext：**
- `ctx.repairedText = repairResult.textOut`
- `ctx.semanticDecision = repairResult.decision`
- `ctx.semanticRepairApplied = repairResult.semanticRepairApplied`
- `ctx.semanticRepairConfidence = repairResult.confidence`

**功能：**
- 语义修复（PASS / REPAIR / REJECT）
- 使用微上下文（上一句尾部）提高修复质量

**跳过条件：**
- `job.pipeline?.use_asr === false` - 在步骤内部检查
- 文本为空 - 在步骤内部检查
- `services.servicesHandler` 不存在 - 在步骤内部检查

---

### 8. runDedupStep() - 去重步骤

**文件位置：** `electron_node/electron-node/main/src/pipeline/steps/dedup-step.ts`

**调用方法：**
1. 使用全局 `services.dedupStage` 实例（在 InferenceService 中初始化）
2. `dedupStage.process(job, finalText, translatedText)` - 执行去重检查

**更新 JobContext：**
- `ctx.shouldSend = dedupResult.shouldSend`
- `ctx.dedupReason = dedupResult.reason`

**功能：**
- 基于 `job_id` 进行去重检查（30秒 TTL）
- 防止重复发送相同 job

**注意：**
- 使用全局 DedupStage 实例，维护 `lastSentJobIds` 状态
- 在 ResultSender 成功发送后调用 `markJobIdAsSent()` 记录 job_id

---

### 9. runTranslationStep() - 翻译步骤

**文件位置：** `electron_node/electron-node/main/src/pipeline/steps/translation-step.ts`

**调用方法：**
1. `new TranslationStage(taskRouter, aggregatorManager, config)` - 创建翻译 Stage
2. `translationStage.process(job, textToTranslate, qualityScore, dedupCharsRemoved, semanticRepairContext)` - 执行翻译

**更新 JobContext：**
- `ctx.translatedText = translationResult.translatedText`

**功能：**
- 翻译缓存查询
- NMT 服务调用
- 异步重新翻译（长文本）

**跳过条件：**
- `ctx.shouldSend === false` - 在步骤内部检查
- 文本为空 - 在步骤内部检查
- `job.pipeline?.use_nmt === false` - 在步骤内部检查
- `services.taskRouter` 不存在 - 在步骤内部检查

---

### 10. runTtsStep() - TTS 步骤

**文件位置：** `electron_node/electron-node/main/src/pipeline/steps/tts-step.ts`

**调用方法：**
1. `new TTSStage(taskRouter)` - 创建 TTS Stage
2. `ttsStage.process(job, textToTts)` - 执行 TTS

**更新 JobContext：**
- `ctx.ttsAudio = ttsResult.ttsAudio`
- `ctx.ttsFormat = ttsResult.ttsFormat`

**功能：**
- TTS 音频生成
- 顺序执行（使用 SequentialExecutor）

**跳过条件：**
- `ctx.shouldSend === false` - 在步骤内部检查
- 翻译文本为空 - 在步骤内部检查
- `job.pipeline?.use_tts === false` - 在步骤内部检查
- `services.taskRouter` 不存在 - 在步骤内部检查

---

### 11. runToneStep() - TONE 步骤

**文件位置：** `electron_node/electron-node/main/src/pipeline/steps/tone-step.ts`

**调用方法：**
1. `new TONEStage(taskRouter)` - 创建 TONE Stage
2. `toneStage.process(job, ttsAudio, ttsFormat, speakerId)` - 执行 TONE

**更新 JobContext：**
- `ctx.toneAudio = toneResult.toneAudio`
- `ctx.toneFormat = toneResult.toneFormat`

**功能：**
- TONE 音色配音生成
- 顺序执行（使用 SequentialExecutor）

**跳过条件：**
- `ctx.shouldSend === false` - 在步骤内部检查
- TTS 音频为空 - 在步骤内部检查
- `job.pipeline?.use_tone !== true` - 在步骤内部检查
- `services.taskRouter` 不存在 - 在步骤内部检查

---

### 12. buildJobResult() - 结果构建

**文件位置：** `electron_node/electron-node/main/src/pipeline/result-builder.ts`

**调用方法：**
1. `calculateMaxGap(segments)` - 计算最大间隔
2. `calculateAvgDuration(segments)` - 计算平均时长

**功能：**
- 将 JobContext 转换为 JobResult
- 确定最终 ASR 文本（优先使用修复后的文本，然后是聚合后的文本，最后是原始 ASR 文本）
- 确定最终 TTS 音频（优先使用 TONE 音频，然后是 TTS 音频）

**返回：**
- `JobResult` - 符合协议规范的结果对象

---

### 13. ResultSender.sendJobResult() - 结果发送

**文件位置：** `electron_node/electron-node/main/src/agent/node-agent-result-sender.ts`

**调用方法：**
1. `aggregatorMiddleware.getLastSentText(sessionId)` - 获取最后发送的文本（去重检查）
2. `dedupStage.markJobIdAsSent(sessionId, jobId)` - 标记 job_id 为已发送（成功发送后）
3. `aggregatorMiddleware.setLastSentText(sessionId, text)` - 更新最后发送的文本（成功发送后）
4. `ws.send(JSON.stringify(response))` - 发送 job_result 消息

**功能：**
- 检查 WebSocket 连接状态
- 检查文本重复（与上次发送的文本比较）
- 发送 job_result 消息到调度服务器
- 记录最后发送的文本和 job_id

---

## 数据流转

### JobContext 字段更新顺序

1. **runAsrStep 后：**
   - `asrText`, `asrResult`, `asrSegments`, `languageProbabilities`, `qualityScore`, `rerunCount`

2. **runAggregationStep 后：**
   - `aggregatedText`, `aggregationAction`, `aggregationChanged`, `isLastInMergedGroup`, `aggregationMetrics`

3. **runSemanticRepairStep 后：**
   - `repairedText`, `semanticDecision`, `semanticRepairApplied`, `semanticRepairConfidence`

4. **runDedupStep 后：**
   - `shouldSend`, `dedupReason`

5. **runTranslationStep 后：**
   - `translatedText`

6. **runTtsStep 后：**
   - `ttsAudio`, `ttsFormat`

7. **runToneStep 后：**
   - `toneAudio`, `toneFormat`

### 文本选择优先级

- **ASR 文本：** `ctx.repairedText || ctx.aggregatedText || ctx.asrText`
- **翻译文本：** `ctx.repairedText || ctx.aggregatedText || ctx.asrText`（用于翻译）
- **TTS 文本：** `ctx.translatedText`（用于 TTS）
- **最终 TTS 音频：** `ctx.toneAudio || ctx.ttsAudio`

---

## 回调函数流程

### 任务级回调

1. **onTaskStart()** - 在 `runJobPipeline` 开始时调用
2. **onTaskProcessed(serviceName)** - 在每个步骤完成后调用
   - `'ASR'` - ASR 步骤完成
   - `'AGGREGATION'` - 聚合步骤完成
   - `'SEMANTIC_REPAIR'` - 语义修复步骤完成
   - `'NMT'` - 翻译步骤完成
   - `'TTS'` - TTS 步骤完成
   - `'TONE'` - TONE 步骤完成
3. **onTaskEnd()** - 在 `runJobPipeline` 结束时调用（finally 块）

### ASR 特定回调

1. **partialCallback** - 流式 ASR 部分结果回调（在 `runAsrStep` 中传递给 ASR 服务）
2. **asrCompletedCallback** - ASR 完成回调（在 `runAsrStep` 中调用）

---

## 配置开关

### Pipeline 配置

- `job.pipeline.use_asr` - 是否使用 ASR（默认 true，false 时跳过 ASR 和语义修复）
- `job.pipeline.use_nmt` - 是否使用翻译（默认 true，false 时跳过翻译）
- `job.pipeline.use_tts` - 是否使用 TTS（默认 true，false 时跳过 TTS）
- `job.pipeline.use_tone` - 是否使用 TONE（默认 false，true 时才执行 TONE）

---

## 错误处理

### 各步骤的错误处理策略

1. **runAsrStep：**
   - 音频处理失败：抛出异常
   - ASR 服务失败：抛出异常（由 withGpuLease 处理）
   - Gate-A 上下文重置失败：异步处理，不阻塞主流程

2. **runAggregationStep：**
   - AggregationStage 处理失败：返回空文本或原始文本

3. **runSemanticRepairStep：**
   - 初始化失败：使用原始文本
   - 修复服务失败：使用原始文本（不抛出异常）

4. **runDedupStep：**
   - 无错误处理（纯检查逻辑）

5. **runTranslationStep：**
   - 翻译失败：设置 `ctx.translatedText = ''`（不抛出异常）

6. **runTtsStep：**
   - TTS 失败：设置 `ctx.ttsAudio = ''`（不抛出异常）

7. **runToneStep：**
   - TONE 失败：不更新 ctx（不抛出异常）

---

## 检查清单：重复调用和错误调用

### ✅ 已确认无重复调用

1. **ASR 步骤：** 只调用一次 `taskRouter.routeASRTask()`
2. **聚合步骤：** 只调用一次 `aggregationStage.process()`
3. **语义修复步骤：** 只调用一次 `semanticRepairStage.process()`
4. **去重步骤：** 只调用一次 `dedupStage.process()`
5. **翻译步骤：** 只调用一次 `translationStage.process()`
6. **TTS 步骤：** 只调用一次 `ttsStage.process()`
7. **TONE 步骤：** 只调用一次 `toneStage.process()`

### ✅ 已确认无错误调用

1. **步骤顺序正确：** ASR → 聚合 → 语义修复 → 去重 → 翻译 → TTS → TONE
2. **条件检查正确：** 每个步骤都有适当的跳过条件
3. **数据依赖正确：** 每个步骤都使用前一步骤的输出
4. **回调调用正确：** 所有回调都在正确的时机调用

### ⚠️ 潜在问题

1. **Stage 实例创建：** 每个步骤都创建新的 Stage 实例
   - **影响：** 如果 Stage 有状态（如缓存），每次创建会丢失状态
   - **当前状态：** 大部分 Stage 使用外部依赖（如 TaskRouter、AggregatorManager）管理状态，每次创建是安全的
   - **建议：** 保持当前实现，符合"代码简洁"的要求

2. **SemanticRepairInitializer 每次创建：**
   - **影响：** 每次任务都重新初始化语义修复服务
   - **当前状态：** 初始化有缓存机制，不会重复初始化
   - **建议：** 保持当前实现

---

## 关键方法调用链

### ASR 流程

```
runAsrStep()
  → AudioAggregator.processAudioChunk()
  → PipelineOrchestratorAudioProcessor.processAudio()
  → PipelineOrchestratorASRHandler.buildPrompt()
  → withGpuLease() / processASRStreaming()
    → TaskRouter.routeASRTask()
  → PipelineOrchestratorASRResultProcessor.processASRResult()
  → SessionContextManager.resetContext() [Gate-A, 异步]
```

### 聚合流程

```
runAggregationStep()
  → AggregationStage.process()
    → AggregatorManager.processUtterance()
    → DeduplicationHandler.isDuplicate()
    → TextForwardMergeManager.processText()
```

### 语义修复流程

```
runSemanticRepairStep()
  → SemanticRepairInitializer.initialize()
  → SemanticRepairInitializer.getSemanticRepairStage()
  → AggregatorManager.getLastCommittedText()
  → SemanticRepairStage.process()
    → TaskRouter.routeSemanticRepairTask()
```

### 翻译流程

```
runTranslationStep()
  → TranslationStage.process()
    → TranslationCache.get() [缓存查询]
    → TaskRouter.routeNMTTask() [如果缓存未命中]
    → TranslationCache.set() [缓存写入]
```

### TTS 流程

```
runTtsStep()
  → TTSStage.process()
    → SequentialExecutor.execute()
      → TaskRouter.routeTTSTask()
```

### TONE 流程

```
runToneStep()
  → TONEStage.process()
    → SequentialExecutor.execute()
      → TaskRouter.routeTONETask()
```

---

## Session 生命周期管理

### removeSession() 调用链

```
NodeAgent.removeSession(sessionId)
  → InferenceService.removeSession(sessionId)
    → servicesBundle.aggregatorManager?.removeSession(sessionId)
    → servicesBundle.deduplicationHandler?.removeSession(sessionId)
    → servicesBundle.servicesHandler?.removeSession?.(sessionId)
    → servicesBundle.sessionContextManager?.removeSession?.(sessionId)
    → servicesBundle.dedupStage?.removeSession?.(sessionId)
```

---

## 总结

### 流程特点

1. **单一编排器：** 只有 `runJobPipeline()` 一个编排函数
2. **直线流程：** 所有步骤按顺序执行，无分支
3. **统一上下文：** 所有中间状态存储在 `JobContext` 中
4. **简单易懂：** 每个步骤都是独立函数，逻辑清晰

### 无重复调用

✅ 所有步骤都只调用一次，无重复执行

### 无错误调用

✅ 所有方法调用顺序正确，数据依赖关系正确

### 代码简洁性

✅ 符合"代码简洁"的要求，没有添加过多的保险措施

---

## 附录：文件清单

### 核心文件（新架构）

- `pipeline/job-pipeline.ts` - 唯一编排器
- `pipeline/result-builder.ts` - 结果构建器
- `pipeline/context/job-context.ts` - 上下文定义
- `pipeline/steps/asr-step.ts` - ASR 步骤
- `pipeline/steps/aggregation-step.ts` - 聚合步骤
- `pipeline/steps/semantic-repair-step.ts` - 语义修复步骤
- `pipeline/steps/dedup-step.ts` - 去重步骤
- `pipeline/steps/translation-step.ts` - 翻译步骤
- `pipeline/steps/tts-step.ts` - TTS 步骤
- `pipeline/steps/tone-step.ts` - TONE 步骤

### 服务层

- `inference/inference-service.ts` - 推理服务（调用 JobPipeline）
- `agent/node-agent.ts` - 节点代理（入口）
- `agent/node-agent-job-processor.ts` - 任务处理器
- `agent/node-agent-result-sender.ts` - 结果发送器

### 已删除的旧架构文件

- ❌ `pipeline-orchestrator/pipeline-orchestrator.ts` - 已删除
- ❌ `agent/postprocess/postprocess-coordinator.ts` - 已删除
- ❌ `pipeline-orchestrator/index.ts` - 已删除

### 保留的工具类（不属于架构实体）

- ✅ `pipeline-orchestrator/audio-aggregator.ts` - 音频聚合器（工具类）
- ✅ `pipeline-orchestrator/pipeline-orchestrator-audio-processor.ts` - 音频处理器（工具类）
- ✅ `pipeline-orchestrator/pipeline-orchestrator-asr-result-processor.ts` - ASR 结果处理器（工具类）
- ✅ `pipeline-orchestrator/pipeline-orchestrator-asr.ts` - ASR 处理器（工具类）
- ✅ `pipeline-orchestrator/session-context-manager.ts` - Session 上下文管理器（工具类）
- ✅ `agent/postprocess/aggregation-stage.ts` - 聚合 Stage（工具类，被 runAggregationStep 使用）
- ✅ `agent/postprocess/translation-stage.ts` - 翻译 Stage（工具类，被 runTranslationStep 使用）
- ✅ `agent/postprocess/tts-stage.ts` - TTS Stage（工具类，被 runTtsStep 使用）
- ✅ `agent/postprocess/tone-stage.ts` - TONE Stage（工具类，被 runToneStep 使用）
- ✅ `agent/postprocess/dedup-stage.ts` - 去重 Stage（工具类，被 runDedupStep 使用）
- ✅ `agent/postprocess/semantic-repair-stage.ts` - 语义修复 Stage（工具类，被 runSemanticRepairStep 使用）

**说明：** 这些工具类保留，因为它们不属于架构实体，而是业务工具。新架构中通过函数调用使用这些工具类，而不是通过 Stage/Orchestrator/Coordinator 抽象层。
