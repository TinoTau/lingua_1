# 按需服务选择架构调整分析

## 当前架构分析

### 当前流程

```
NodeAgent
  └─> JobProcessor.processJob()
       └─> InferenceService.processJob()
            └─> PipelineOrchestrator.processJob()  [ASR处理]
                 └─> 返回 JobResult
       └─> PostProcessCoordinator.process()  [翻译、TTS、TONE]
            └─> 返回最终结果
```

### 当前实现的问题

1. **固定流程路径**：
   - 即使 `use_asr=false`，仍然会调用 `PipelineOrchestrator`（虽然它返回空结果）
   - 流程是线性的：必须先经过 `PipelineOrchestrator`，才能到 `PostProcessCoordinator`
   - 无法直接从 `PostProcessCoordinator` 开始处理（例如：只选择 NMT 模式）

2. **不必要的调用**：
   - `use_asr=false` 时，`PipelineOrchestrator` 仍然被调用，只是返回空结果
   - 这增加了不必要的函数调用开销和日志噪音

3. **语义不清晰**：
   - `PipelineOrchestrator` 的名称暗示它负责整个流程编排，但实际上它只处理 ASR
   - `PostProcessCoordinator` 的名称暗示它是"后处理"，但实际上它处理翻译、TTS、TONE 等核心功能

## 架构调整方案

### 方案1：路由层优化（推荐）⭐

**核心思想**：在 `InferenceService` 或 `JobProcessor` 层面，根据 `pipeline` 配置决定调用哪些服务。

#### 实现方式

```typescript
// InferenceService.processJob()
async processJob(job: JobAssignMessage, ...): Promise<JobResult> {
  // 根据 pipeline 配置决定处理路径
  if (job.pipeline?.use_asr === false) {
    // 跳过 ASR，直接返回空结果，让 PostProcessCoordinator 处理
    return this.resultBuilder.buildEmptyResult();
  }
  
  // 正常流程：调用 PipelineOrchestrator
  return await this.pipelineOrchestrator.processJob(job, ...);
}
```

**优点**：
- ✅ 改动最小，只需在 `InferenceService` 中添加路由逻辑
- ✅ 向后兼容，不影响现有功能
- ✅ 避免不必要的 `PipelineOrchestrator` 调用
- ✅ 语义清晰：`use_asr=false` 时直接跳过 ASR 处理

**缺点**：
- ⚠️ 仍然需要 `PostProcessCoordinator` 处理所有后续阶段
- ⚠️ 如果未来需要支持更复杂的服务组合，可能需要进一步调整

#### 代码改动

**文件**：`electron_node/electron-node/main/src/inference/inference-service.ts`

```typescript
async processJob(job: JobAssignMessage, partialCallback?: PartialResultCallback): Promise<JobResult> {
  // ... 现有代码（首次任务检查等）...

  // 优化：如果 use_asr=false，直接返回空结果，跳过 PipelineOrchestrator
  if (job.pipeline?.use_asr === false) {
    logger.info(
      { jobId: job.job_id, sessionId: job.session_id },
      'InferenceService: ASR disabled by pipeline config, skipping PipelineOrchestrator'
    );
    // ASR 完成回调（立即触发，因为 ASR 被跳过）
    if (asrCompletedCallback) {
      asrCompletedCallback(true);
    }
    // 返回空结果，让 PostProcessCoordinator 处理后续阶段
    return this.resultBuilder.buildEmptyResult();
  }

  // 正常流程：调用 PipelineOrchestrator
  const result = await this.pipelineOrchestrator.processJob(job, partialCallback, asrCompletedCallback);
  return result;
}
```

---

### 方案2：统一编排器（更彻底的重构）

**核心思想**：创建一个统一的编排器，根据 `pipeline` 配置动态决定执行哪些阶段。

#### 架构设计

```
NodeAgent
  └─> JobProcessor.processJob()
       └─> UnifiedPipelineOrchestrator.processJob()
            ├─> ASR Stage (if use_asr=true)
            ├─> Aggregation Stage (if use_asr=true)
            ├─> Semantic Repair Stage (if use_asr=true)
            ├─> Translation Stage (if use_nmt=true)
            ├─> TTS Stage (if use_tts=true)
            └─> TONE Stage (if use_tone=true)
```

**优点**：
- ✅ 架构更清晰，所有阶段在一个编排器中统一管理
- ✅ 支持从任意阶段开始处理
- ✅ 支持在任意阶段结束处理
- ✅ 更容易扩展新的服务组合

**缺点**：
- ❌ 需要大量重构，影响现有代码
- ❌ 风险较高，可能引入新的 bug
- ❌ 需要重新设计阶段间的数据传递

---

### 方案3：保持当前架构但优化（最小改动）

**核心思想**：保持当前架构不变，但优化 `PipelineOrchestrator` 和 `PostProcessCoordinator` 的实现。

#### 实现方式

1. **PipelineOrchestrator**：在方法开始处立即返回，避免不必要的初始化
2. **PostProcessCoordinator**：支持从不同阶段开始处理（例如：如果 `use_asr=false`，直接从翻译阶段开始）

**优点**：
- ✅ 改动最小，只需优化现有代码
- ✅ 向后兼容，不影响现有功能
- ✅ 风险低

**缺点**：
- ⚠️ 仍然需要调用 `PipelineOrchestrator`（虽然它立即返回）
- ⚠️ 架构语义不够清晰

---

## 推荐方案

### 推荐：方案1（路由层优化）

**理由**：
1. **改动最小**：只需在 `InferenceService.processJob()` 中添加路由逻辑
2. **效果明显**：避免不必要的 `PipelineOrchestrator` 调用
3. **向后兼容**：不影响现有功能
4. **易于维护**：代码逻辑清晰，易于理解

### 实施步骤

1. **步骤1**：在 `InferenceService.processJob()` 中添加路由逻辑
   - 检查 `job.pipeline?.use_asr`
   - 如果 `false`，直接返回空结果，跳过 `PipelineOrchestrator`

2. **步骤2**：优化 `PipelineOrchestrator.processJob()`
   - 保留现有的 `use_asr` 检查（作为双重保险）
   - 添加更详细的日志

3. **步骤3**：测试各种服务组合
   - `use_asr=false, use_nmt=true`：文本翻译模式
   - `use_asr=true, use_nmt=false, use_tts=false`：只执行 ASR
   - `use_asr=true, use_nmt=true, use_tts=false`：字幕模式

---

## 未来扩展性考虑

### 如果未来需要支持更复杂的服务组合

例如：
- 支持从任意服务开始（不仅仅是 ASR）
- 支持服务间的条件依赖（例如：TONE 依赖 TTS）
- 支持并行执行多个服务

可以考虑：
1. **引入服务依赖图**：定义服务之间的依赖关系
2. **动态编排器**：根据依赖图动态决定执行顺序
3. **服务编排 DSL**：使用领域特定语言描述服务组合

但目前的方案1已经足够满足当前需求，未来可以根据实际需求逐步演进。

---

## 总结

**当前架构的问题**：
- 固定流程路径，无法灵活选择服务
- 不必要的函数调用（`use_asr=false` 时仍调用 `PipelineOrchestrator`）

**推荐方案**：
- **方案1：路由层优化**（推荐）
  - 在 `InferenceService` 层面根据 `pipeline` 配置决定是否调用 `PipelineOrchestrator`
  - 改动最小，效果明显，向后兼容

**实施优先级**：
- 🟢 **高优先级**：方案1（路由层优化）
- 🟡 **中优先级**：优化日志和错误处理
- 🔵 **低优先级**：方案2（统一编排器）- 仅在需要更复杂服务组合时考虑
