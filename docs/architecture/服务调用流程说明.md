# 服务调用流程说明

## 当前架构

### 统一入口：NodeAgent

所有服务调用都在 **`NodeAgent`** 中统一管理，通过以下调用链：

```
NodeAgent.handleMessage() 
  → NodeAgent.handleJob() 
    → JobProcessor.processJob()
      → InferenceService.processJob() [ASR]
      → PostProcessCoordinator.process() [NMT, TTS, TONE, 语义修复]
```

---

## 详细调用流程

### 1. NodeAgent.handleMessage() - 消息接收

**文件**：`electron_node/electron-node/main/src/agent/node-agent.ts`

**位置**：第 286-346 行

```typescript
private async handleMessage(data: string): Promise<void> {
  const message = JSON.parse(data);
  
  switch (message.type) {
    case 'job_assign': {
      const job = message as JobAssignMessage;
      await this.handleJob(job);  // 统一入口
      break;
    }
  }
}
```

**职责**：
- 接收 WebSocket 消息
- 解析 `job_assign` 消息
- 调用 `handleJob()` 处理任务

---

### 2. NodeAgent.handleJob() - 任务分发

**文件**：`electron_node/electron-node/main/src/agent/node-agent.ts`

**位置**：第 348-448 行

```typescript
private async handleJob(job: JobAssignMessage): Promise<void> {
  const startTime = Date.now();
  
  // 统一调用 JobProcessor
  const processResult = await this.jobProcessor.processJob(job, startTime);
  
  // 发送结果
  if (processResult.shouldSend) {
    await this.resultSender.sendResult(job, processResult.finalResult);
  }
}
```

**职责**：
- 统一调用 `JobProcessor.processJob()`
- 统一调用 `ResultSender.sendResult()` 发送结果

---

### 3. JobProcessor.processJob() - 服务调用统一入口

**文件**：`electron_node/electron-node/main/src/agent/node-agent-job-processor.ts`

**位置**：第 36-186 行

```typescript
async processJob(
  job: JobAssignMessage,
  startTime: number
): Promise<{ finalResult: JobResult; shouldSend: boolean; reason?: string }> {
  
  // ========== 1. ASR 阶段 ==========
  // 调用 InferenceService（内部调用 PipelineOrchestrator）
  const result = await this.inferenceService.processJob(job, partialCallback);
  
  // ========== 2. 后处理阶段 ==========
  // 调用 PostProcessCoordinator（内部调用 NMT, TTS, TONE, 语义修复）
  if (enablePostProcessTranslation && this.postProcessCoordinator) {
    const postProcessResult = await this.postProcessCoordinator.process(job, result);
    
    // 处理 TTS Opus 编码
    // ...
    
    // 构建最终结果
    finalResult = {
      ...result,
      text_asr: postProcessResult.aggregatedText,
      text_translated: postProcessResult.translatedText,
      tts_audio: ttsAudio,
      tts_format: ttsFormat,
    };
  }
  
  return { finalResult, shouldSend, reason };
}
```

**职责**：
- ✅ **统一管理所有服务调用**
- ✅ **ASR 阶段**：调用 `InferenceService.processJob()`
- ✅ **后处理阶段**：调用 `PostProcessCoordinator.process()`
- ✅ **结果处理**：统一处理 TTS Opus 编码

---

### 4. InferenceService.processJob() - ASR 服务调用

**文件**：`electron_node/electron-node/main/src/inference/inference-service.ts`

**位置**：第 188-244 行

```typescript
async processJob(
  job: JobAssignMessage,
  partialCallback?: PartialResultCallback
): Promise<JobResult> {
  
  // 检查 use_asr
  if (job.pipeline?.use_asr === false) {
    return emptyResult;
  }
  
  // 调用 PipelineOrchestrator（ASR）
  const result = await this.pipelineOrchestrator.processJob(job, partialCallback);
  
  return result;
}
```

**职责**：
- 检查 `pipeline.use_asr`
- 调用 `PipelineOrchestrator.processJob()` 执行 ASR

---

### 5. PostProcessCoordinator.process() - 后处理服务调用

**文件**：`electron_node/electron-node/main/src/agent/postprocess/postprocess-coordinator.ts`

**位置**：第 167-661 行

```typescript
async process(
  job: JobAssignMessage,
  result: JobResult
): Promise<PostProcessResult> {
  
  // ========== Stage 1: 文本聚合 ==========
  const aggregationResult = this.aggregationStage.process(job, result);
  
  // ========== Stage 2: 语义修复（如果 use_asr === true）==========
  if (job.pipeline?.use_asr !== false) {
    const semanticRepairResult = await semanticRepairHandler.process(...);
    textForTranslation = semanticRepairResult.textForTranslation;
  }
  
  // ========== Stage 3: 翻译（如果 use_nmt !== false）==========
  if (job.pipeline?.use_nmt !== false) {
    // 支持只选择 NMT（文本翻译模式）
    if (job.pipeline?.use_asr === false) {
      textToTranslate = job.input_text;  // 使用输入文本
    }
    translationResult = await this.translationStage.process(...);
  }
  
  // ========== Stage 4: TTS（如果 use_tts !== false）==========
  if (job.pipeline?.use_tts !== false) {
    ttsResult = await this.ttsStage.process(...);
  }
  
  // ========== Stage 5: TONE（如果 use_tone === true）==========
  if (job.pipeline?.use_tone === true) {
    toneResult = await this.toneStage.process(...);
  }
  
  return {
    aggregatedText,
    translatedText,
    ttsAudio: toneResult.toneAudio || ttsResult.ttsAudio,
    toneAudio: toneResult.toneAudio,
    speakerId: toneResult.speakerId,
  };
}
```

**职责**：
- ✅ **语义修复**：如果 `use_asr === true`，必须执行
- ✅ **翻译（NMT）**：如果 `use_nmt !== false`，执行翻译
- ✅ **TTS**：如果 `use_tts !== false`，生成 TTS 音频
- ✅ **TONE**：如果 `use_tone === true`，生成音色配音

---

## 各场景的服务调用流程

### 场景1：ASR+NMT+TTS+TONE（个人专属语音处理）

```
NodeAgent.handleJob()
  → JobProcessor.processJob()
    → InferenceService.processJob() [ASR]
      → PipelineOrchestrator.processJob()
        → TaskRouter.routeASRTask() [ASR 服务调用]
    → PostProcessCoordinator.process()
      → SemanticRepairHandler.process() [语义修复服务调用]
      → TranslationStage.process() [NMT 服务调用]
        → TaskRouter.routeNMTTask()
      → TTSStage.process() [TTS 服务调用]
        → TaskRouter.routeTTSTask()
      → TONEStage.process() [TONE 服务调用]
        → TaskRouter.routeTONETask()
```

**服务调用位置**：
- ✅ ASR：`InferenceService.processJob()` → `PipelineOrchestrator.processJob()`
- ✅ 语义修复：`PostProcessCoordinator.process()` → `SemanticRepairHandler.process()`
- ✅ NMT：`PostProcessCoordinator.process()` → `TranslationStage.process()`
- ✅ TTS：`PostProcessCoordinator.process()` → `TTSStage.process()`
- ✅ TONE：`PostProcessCoordinator.process()` → `TONEStage.process()`

---

### 场景2：ASR+NMT+TTS（语音转译）

```
NodeAgent.handleJob()
  → JobProcessor.processJob()
    → InferenceService.processJob() [ASR]
    → PostProcessCoordinator.process()
      → SemanticRepairHandler.process() [语义修复]
      → TranslationStage.process() [NMT]
      → TTSStage.process() [TTS]
      → TONEStage.process() [跳过，use_tone !== true]
```

**服务调用位置**：
- ✅ ASR：`InferenceService.processJob()`
- ✅ 语义修复：`PostProcessCoordinator.process()`
- ✅ NMT：`PostProcessCoordinator.process()`
- ✅ TTS：`PostProcessCoordinator.process()`
- ❌ TONE：跳过

---

### 场景3：ASR+NMT（字幕模式）

```
NodeAgent.handleJob()
  → JobProcessor.processJob()
    → InferenceService.processJob() [ASR]
    → PostProcessCoordinator.process()
      → SemanticRepairHandler.process() [语义修复]
      → TranslationStage.process() [NMT]
      → TTSStage.process() [跳过，use_tts === false]
      → TONEStage.process() [跳过，use_tone !== true]
```

**服务调用位置**：
- ✅ ASR：`InferenceService.processJob()`
- ✅ 语义修复：`PostProcessCoordinator.process()`
- ✅ NMT：`PostProcessCoordinator.process()`
- ❌ TTS：跳过
- ❌ TONE：跳过

---

### 场景4：只选择 NMT（文本翻译）

```
NodeAgent.handleJob()
  → JobProcessor.processJob()
    → InferenceService.processJob() [跳过，use_asr === false]
      → PipelineOrchestrator.processJob() [返回空结果]
    → PostProcessCoordinator.process()
      → SemanticRepairHandler.process() [跳过，use_asr === false]
      → TranslationStage.process() [NMT，使用 job.input_text]
        → TaskRouter.routeNMTTask()
      → TTSStage.process() [跳过，use_tts === false]
      → TONEStage.process() [跳过，use_tone !== true]
```

**服务调用位置**：
- ❌ ASR：跳过
- ❌ 语义修复：跳过（因为 `use_asr === false`）
- ✅ NMT：`PostProcessCoordinator.process()` → `TranslationStage.process()`（使用 `job.input_text`）
- ❌ TTS：跳过
- ❌ TONE：跳过

**注意**：需要 web 端在 `JobAssignMessage` 中提供 `input_text` 字段。

---

### 场景5：只选择 ASR

```
NodeAgent.handleJob()
  → JobProcessor.processJob()
    → InferenceService.processJob() [ASR]
      → PipelineOrchestrator.processJob()
        → TaskRouter.routeASRTask() [ASR 服务调用]
    → PostProcessCoordinator.process()
      → SemanticRepairHandler.process() [语义修复]
      → TranslationStage.process() [跳过，use_nmt === false]
      → TTSStage.process() [跳过，use_tts === false]
      → TONEStage.process() [跳过，use_tone !== true]
```

**服务调用位置**：
- ✅ ASR：`InferenceService.processJob()`
- ✅ 语义修复：`PostProcessCoordinator.process()`（因为 `use_asr === true`）
- ❌ NMT：跳过
- ❌ TTS：跳过
- ❌ TONE：跳过

---

## 服务调用统一管理位置

### ✅ 当前架构：JobProcessor.processJob()

**文件**：`electron_node/electron-node/main/src/agent/node-agent-job-processor.ts`

**优势**：
- ✅ 所有服务调用都在一个方法中统一管理
- ✅ 清晰的调用顺序：ASR → 后处理（NMT, TTS, TONE）
- ✅ 统一的错误处理和结果处理
- ✅ 统一的 TTS Opus 编码处理

**调用链**：
```
NodeAgent.handleJob()
  └─> JobProcessor.processJob()  ← 统一入口
      ├─> InferenceService.processJob() [ASR]
      └─> PostProcessCoordinator.process() [NMT, TTS, TONE, 语义修复]
```

---

## 总结

### 服务调用统一位置

**✅ 当前架构已经统一在 `JobProcessor.processJob()` 中**

所有服务调用都通过以下路径：

1. **NodeAgent.handleJob()** - 任务接收和分发
2. **JobProcessor.processJob()** - 服务调用统一入口
   - `InferenceService.processJob()` - ASR 服务调用
   - `PostProcessCoordinator.process()` - 后处理服务调用（NMT, TTS, TONE, 语义修复）

### 各场景的服务调用

| 场景 | ASR | 语义修复 | NMT | TTS | TONE |
|------|-----|---------|-----|-----|------|
| ASR+NMT+TTS+TONE | ✅ | ✅ | ✅ | ✅ | ✅ |
| ASR+NMT+TTS | ✅ | ✅ | ✅ | ✅ | ❌ |
| ASR+NMT | ✅ | ✅ | ✅ | ❌ | ❌ |
| 只选择 NMT | ❌ | ❌ | ✅ | ❌ | ❌ |
| 只选择 ASR | ✅ | ✅ | ❌ | ❌ | ❌ |

### 关键点

1. **语义修复与 ASR 绑定**：
   - 如果 `use_asr === true`，必须执行语义修复
   - 如果 `use_asr === false`，跳过语义修复

2. **只选择 NMT 模式**：
   - 如果 `use_asr === false` 且 `use_nmt === true`，使用 `job.input_text` 作为输入
   - 需要 web 端提供 `input_text` 字段

3. **TONE 音色配音**：
   - 在 TTS 之后执行
   - 从 `job.speaker_id` 或 `job.voice_id` 提取音色ID

---

## 建议

当前架构已经很好地统一了服务调用，所有调用都在 `JobProcessor.processJob()` 中管理。如果需要进一步优化，可以考虑：

1. **添加服务调用日志**：在 `JobProcessor.processJob()` 中记录每个服务的调用情况
2. **添加服务调用监控**：在 `JobProcessor.processJob()` 中记录每个服务的耗时
3. **添加服务调用配置**：在 `JobProcessor.processJob()` 中根据 `pipeline` 字段动态决定调用哪些服务
