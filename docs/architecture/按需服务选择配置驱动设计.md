# 按需服务选择 - 配置驱动设计

## 设计目标

实现一个优雅的按需服务选择机制，避免硬编码的 if/else，支持：
- 个人特色语音转译（ASR + NMT + TTS + TONE）
- 通用语音转译（ASR + NMT + TTS）
- 字幕模式（ASR + NMT）
- 只执行 ASR
- 文本翻译模式（只 NMT）

## 核心设计

### 1. 配置驱动架构

使用**配置驱动 + 步骤注册表**的方式，将服务选择逻辑从代码中分离出来：

```
JobPipeline
    ↓
inferPipelineMode()  // 根据 job.pipeline 推断模式
    ↓
PipelineMode (配置对象)
    ├─ name: 模式名称
    ├─ steps: 步骤序列
    └─ conditions: 执行条件
    ↓
executeStep() (通过注册表查找执行函数)
    ↓
实际执行步骤
```

### 2. 三个核心组件

#### 2.1 PipelineMode 配置（`pipeline-mode-config.ts`）

定义不同的 Pipeline 模式：

```typescript
export const PIPELINE_MODES: Record<string, PipelineMode> = {
  PERSONAL_VOICE_TRANSLATION: {
    name: '个人特色语音转译',
    steps: ['ASR', 'AGGREGATION', 'SEMANTIC_REPAIR', 'DEDUP', 'TRANSLATION', 'TTS', 'TONE'],
    conditions: {
      TONE: (job) => job.pipeline?.use_tone === true && !!(job as any).speaker_id,
    },
  },
  // ... 其他模式
};
```

**优点**：
- 模式定义清晰，易于理解
- 支持条件判断（如 TONE 需要 speaker_id）
- 易于扩展新模式

#### 2.2 步骤注册表（`pipeline-step-registry.ts`）

将步骤类型映射到执行函数：

```typescript
export const STEP_REGISTRY: Record<PipelineStepType, StepExecutor> = {
  ASR: async (job, ctx, services, options) => {
    await runAsrStep(job, ctx, services, options);
  },
  TRANSLATION: async (job, ctx, services) => {
    await runTranslationStep(job, ctx, services);
  },
  // ... 其他步骤
};
```

**优点**：
- 解耦步骤类型和执行函数
- 易于替换或扩展步骤实现
- 统一错误处理

#### 2.3 动态模式推断（`inferPipelineMode`）

根据 `job.pipeline` 配置自动推断模式：

```typescript
export function inferPipelineMode(job: JobAssignMessage): PipelineMode {
  const { use_asr, use_nmt, use_tts, use_tone } = job.pipeline || {};
  
  // 个人特色语音转译
  if (use_asr && use_nmt && use_tts && use_tone && speaker_id) {
    return PIPELINE_MODES.PERSONAL_VOICE_TRANSLATION;
  }
  
  // ... 其他模式判断
  
  // 未预定义的组合：动态构建
  return buildDynamicMode(job);
}
```

**优点**：
- 自动匹配预定义模式
- 支持动态构建未预定义的组合
- 向后兼容（默认行为）

### 3. 执行流程

```typescript
export async function runJobPipeline(options: JobPipelineOptions): Promise<JobResult> {
  const ctx = initJobContext(job);
  
  // 1. 推断 Pipeline 模式
  const mode = inferPipelineMode(job);
  
  // 2. 按模式配置的步骤序列执行
  for (const step of mode.steps) {
    // 检查是否应该执行
    if (!shouldExecuteStep(step, mode, job)) {
      continue;
    }
    
    // 执行步骤（通过注册表查找执行函数）
    await executeStep(step, job, ctx, services, options);
  }
  
  return buildJobResult(job, ctx);
}
```

## 设计优势

### 1. 避免硬编码 if/else

**之前**（硬编码）：
```typescript
if (job.pipeline?.use_asr !== false) {
  await runAsrStep(...);
}
if (job.pipeline?.use_nmt !== false) {
  await runTranslationStep(...);
}
// ... 更多 if/else
```

**现在**（配置驱动）：
```typescript
const mode = inferPipelineMode(job);
for (const step of mode.steps) {
  if (shouldExecuteStep(step, mode, job)) {
    await executeStep(step, job, ctx, services);
  }
}
```

### 2. 易于扩展

**添加新模式**：
```typescript
// 只需在 PIPELINE_MODES 中添加配置
CUSTOM_MODE: {
  name: '自定义模式',
  steps: ['ASR', 'TRANSLATION', 'TTS'],
}
```

**添加新步骤**：
```typescript
// 1. 在 PipelineStepType 中添加类型
// 2. 在 STEP_REGISTRY 中注册执行函数
// 3. 在模式配置中使用
```

### 3. 配置清晰

所有模式定义集中在一个文件中，易于查看和维护：

```typescript
PERSONAL_VOICE_TRANSLATION: {
  name: '个人特色语音转译',
  steps: ['ASR', 'AGGREGATION', 'SEMANTIC_REPAIR', 'DEDUP', 'TRANSLATION', 'TTS', 'TONE'],
}
```

### 4. 支持动态组合

对于未预定义的组合，自动构建动态模式：

```typescript
// 例如：use_asr=true, use_nmt=false, use_tts=true
// 自动构建：['ASR', 'AGGREGATION', 'SEMANTIC_REPAIR', 'DEDUP', 'TTS']
```

## 使用示例

### Web 端发送配置

```json
{
  "pipeline": {
    "use_asr": true,
    "use_nmt": true,
    "use_tts": true,
    "use_tone": true
  },
  "speaker_id": "user-123"
}
```

### 节点端自动推断

```typescript
// 自动推断为 PERSONAL_VOICE_TRANSLATION 模式
// 执行步骤：ASR → Aggregation → Semantic Repair → Dedup → Translation → TTS → TONE
```

## 预定义模式

| 模式 | 步骤序列 | 使用场景 |
|------|---------|---------|
| **PERSONAL_VOICE_TRANSLATION** | ASR → Aggregation → Semantic Repair → Dedup → Translation → TTS → TONE | 个人特色语音转译（音色克隆） |
| **GENERAL_VOICE_TRANSLATION** | ASR → Aggregation → Semantic Repair → Dedup → Translation → TTS | 通用语音转译 |
| **SUBTITLE_MODE** | ASR → Aggregation → Semantic Repair → Dedup → Translation | 字幕模式 |
| **ASR_ONLY** | ASR → Aggregation → Semantic Repair → Dedup | 只执行 ASR |
| **TEXT_TRANSLATION** | Translation | 文本翻译模式 |

## 扩展性

### 添加新模式

1. 在 `PIPELINE_MODES` 中定义新模式
2. 在 `inferPipelineMode` 中添加判断逻辑（可选，支持动态构建）

### 添加新步骤

1. 在 `PipelineStepType` 中添加步骤类型
2. 在 `STEP_REGISTRY` 中注册执行函数
3. 在模式配置中使用新步骤

### 添加条件判断

在模式的 `conditions` 中定义：

```typescript
conditions: {
  TONE: (job) => job.pipeline?.use_tone === true && !!(job as any).speaker_id,
}
```

## 总结

这个设计通过**配置驱动 + 步骤注册表**的方式，实现了：

✅ **避免硬编码 if/else**：所有逻辑通过配置和注册表管理  
✅ **易于扩展**：添加新模式或新步骤只需修改配置  
✅ **配置清晰**：所有模式定义集中管理，易于理解  
✅ **向后兼容**：支持动态构建未预定义的组合  
✅ **类型安全**：使用 TypeScript 类型系统保证类型安全
