# 节点端简化架构方案注意事项补充

## 概述

本文档补充节点端简化架构方案中需要注意的细节问题，确保迁移过程中不遗漏重要功能。

## 需要注意的关键点

### 1. **Session 生命周期管理** ⚠️

**问题**：
- 当前 `PostProcessCoordinator` 有 `removeSession(sessionId)` 方法
- `DedupStage` 也有 `removeSession` 方法
- 需要确保新架构也支持 session 清理

**解决方案**：
```typescript
// 在 InferenceService 或 JobPipeline 中提供 session 清理接口
export function removeSession(sessionId: string, services: ServicesBundle): void {
  // 清理 AggregatorManager 的 session 状态
  services.aggregatorManager?.removeSession(sessionId);
  
  // 清理 DedupStage 的 session 状态
  services.dedupStage?.removeSession(sessionId);
  
  // 清理 DeduplicationHandler 的 session 状态
  services.deduplicationHandler?.removeSession(sessionId);
  
  // 清理其他需要 session 状态管理的组件
}
```

**注意**：
- Session 清理应该在 `NodeAgent` 的 `removeSession` 方法中调用
- 确保所有需要 session 状态管理的组件都被清理

---

### 2. **动态依赖更新** ⚠️

**问题**：
- 当前 `InferenceService` 有 `setAggregatorManager`、`setServicesHandler`、`setDeduplicationHandler` 等方法
- 这些方法会重新创建 `PipelineOrchestrator`
- 新架构需要支持动态更新依赖

**解决方案**：
```typescript
// 方案A：在 InferenceService 中维护 servicesBundle，动态更新
export class InferenceService {
  private servicesBundle: ServicesBundle;
  
  setAggregatorManager(aggregatorManager: AggregatorManager): void {
    this.servicesBundle.aggregatorManager = aggregatorManager;
    // 不需要重新创建 JobPipeline，因为它是函数，不是类
  }
  
  setServicesHandler(servicesHandler: ServicesHandler): void {
    this.servicesBundle.servicesHandler = servicesHandler;
  }
  
  setDeduplicationHandler(deduplicationHandler: DeduplicationHandler): void {
    this.servicesBundle.deduplicationHandler = deduplicationHandler;
  }
}
```

**注意**：
- 新架构中 `runJobPipeline` 是函数，不需要重新创建
- 只需要更新 `servicesBundle` 中的依赖即可

---

### 3. **回调函数和指标收集** ⚠️

**问题**：
- 当前 `InferenceService` 有多个回调函数：
  - `onTaskProcessedCallback`
  - `onTaskStartCallback`
  - `onTaskEndCallback`
- 有指标收集方法：
  - `getRerunMetrics()`
  - `getASRMetrics()`
- 需要确保新架构也支持这些功能

**解决方案**：
```typescript
// 在 runJobPipeline 中支持回调函数
export async function runJobPipeline(options: {
  job: JobAssignMessage;
  partialCallback?: PartialResultCallback;
  asrCompletedCallback?: (done: boolean) => void;
  services: ServicesBundle;
  callbacks?: {
    onTaskStart?: () => void;
    onTaskEnd?: () => void;
    onTaskProcessed?: (serviceName: string) => void;
  };
}) {
  const ctx = initJobContext(job);
  
  // 任务开始回调
  options.callbacks?.onTaskStart?.();
  
  try {
    // ASR 步骤
    if (job.pipeline?.use_asr !== false) {
      await runAsrStep(job, ctx, services, {
        partialCallback: options.partialCallback,
        asrCompletedCallback: options.asrCompletedCallback,
      });
      options.callbacks?.onTaskProcessed?.('ASR');
    }
    
    // ... 其他步骤 ...
    
    // 翻译步骤
    if (job.pipeline?.use_nmt !== false) {
      await runTranslationStep(job, ctx, services);
      options.callbacks?.onTaskProcessed?.('NMT');
    }
    
    // TTS 步骤
    if (job.pipeline?.use_tts !== false) {
      await runTtsStep(job, ctx, services);
      options.callbacks?.onTaskProcessed?.('TTS');
    }
    
  } finally {
    // 任务结束回调
    options.callbacks?.onTaskEnd?.();
  }
  
  return buildJobResult(job, ctx);
}

// 指标收集：从 TaskRouter 获取
export function getRerunMetrics(services: ServicesBundle) {
  return services.taskRouter.getRerunMetrics?.() || {
    totalReruns: 0,
    successfulReruns: 0,
    failedReruns: 0,
    timeoutReruns: 0,
    qualityImprovements: 0,
  };
}

export function getASRMetrics(services: ServicesBundle) {
  return services.taskRouter.getASRMetrics?.() || {
    totalProcessed: 0,
    averageLatency: 0,
    // ... 其他指标
  };
}
```

**注意**：
- 回调函数通过 `options.callbacks` 传递
- 指标收集从 `TaskRouter` 获取（指标收集逻辑在 TaskRouter 中）

---

### 4. **服务就绪检查** ⚠️

**问题**：
- 当前 `InferenceService.processJob` 会调用 `waitForServicesReady(job)`
- 需要确保新架构也支持服务就绪检查

**解决方案**：
```typescript
// 在 InferenceService 中保留服务就绪检查
export class InferenceService {
  async processJob(job: JobAssignMessage, partialCallback?: PartialResultCallback): Promise<JobResult> {
    // 首次任务检查：等待服务就绪
    if (!this.hasProcessedFirstJob) {
      await this.waitForServicesReady(job);
      this.hasProcessedFirstJob = true;
    }
    
    // 调用 JobPipeline
    return await runJobPipeline({
      job,
      partialCallback,
      asrCompletedCallback: (done) => this.onAsrCompleted(job, done),
      services: this.servicesBundle,
      callbacks: {
        onTaskStart: this.onTaskStartCallback || undefined,
        onTaskEnd: this.onTaskEndCallback || undefined,
        onTaskProcessed: this.onTaskProcessedCallback || undefined,
      },
    });
  }
}
```

**注意**：
- 服务就绪检查逻辑保持不变
- 在调用 `runJobPipeline` 之前执行

---

### 5. **部分结果回调（流式 ASR）** ⚠️

**问题**：
- 当前支持流式 ASR 的部分结果回调（`partialCallback`）
- 需要在 `runAsrStep` 中支持这个功能

**解决方案**：
```typescript
export async function runAsrStep(
  job: JobAssignMessage,
  ctx: JobContext,
  services: ServicesBundle,
  options?: {
    partialCallback?: PartialResultCallback;
    asrCompletedCallback?: (done: boolean) => void;
  }
) {
  // 构建 ASR 任务
  const asrTask: ASRTask = {
    audio: ctx.audio,
    audio_format: ctx.audioFormat,
    // ...
    enable_streaming: job.enable_streaming_asr,
  };
  
  // 调用 ASR 服务（支持流式回调）
  const asrResult = await services.taskRouter.routeASRTask(
    asrTask,
    options?.partialCallback  // 传递部分结果回调
  );
  
  // 更新 JobContext
  ctx.asrText = asrResult.text;
  ctx.asrResult = asrResult;
  
  // ASR 完成回调
  options?.asrCompletedCallback?.(true);
}
```

**注意**：
- `partialCallback` 需要传递给 `TaskRouter.routeASRTask`
- 确保流式 ASR 功能正常工作

---

### 6. **上下文重置（Gate-A）** ⚠️

**问题**：
- 当前 `PipelineOrchestrator` 中有 `SessionContextManager` 的上下文重置逻辑
- 需要确保新架构也支持上下文重置

**解决方案**：
```typescript
// 在 runAsrStep 中检查是否需要重置上下文
export async function runAsrStep(
  job: JobAssignMessage,
  ctx: JobContext,
  services: ServicesBundle,
  options?: { partialCallback?: any; asrCompletedCallback?: any }
) {
  // Gate-A: 检查是否需要重置上下文
  if ((job as any).shouldResetContext) {
    const resetRequest: SessionContextResetRequest = {
      sessionId: job.session_id,
      reason: 'user_requested',
    };
    
    // 异步重置上下文（不阻塞主流程）
    services.sessionContextManager.resetContext(resetRequest, services.taskRouter)
      .then((resetResult) => {
        logger.info({ sessionId: job.session_id, resetResult }, 'Context reset completed');
      })
      .catch((error) => {
        logger.error({ sessionId: job.session_id, error }, 'Context reset failed');
      });
  }
  
  // ... 继续 ASR 处理 ...
}
```

**注意**：
- 上下文重置是异步的，不阻塞主流程
- 需要传递 `SessionContextManager` 到 `servicesBundle`

---

### 7. **日志和监控** ⚠️

**问题**：
- 当前各个 Stage 类有详细的日志记录
- 需要确保新架构也保持相同的日志级别和内容

**解决方案**：
```typescript
// 在每个步骤函数中保持详细的日志
export async function runAsrStep(
  job: JobAssignMessage,
  ctx: JobContext,
  services: ServicesBundle,
  options?: { partialCallback?: any; asrCompletedCallback?: any }
) {
  logger.info(
    {
      jobId: job.job_id,
      sessionId: job.session_id,
      utteranceIndex: job.utterance_index,
      audioLength: ctx.audio?.length || 0,
    },
    'runAsrStep: Starting ASR processing'
  );
  
  // ... 处理逻辑 ...
  
  logger.info(
    {
      jobId: job.job_id,
      sessionId: job.session_id,
      utteranceIndex: job.utterance_index,
      asrTextLength: ctx.asrText?.length || 0,
      qualityScore: ctx.asrResult?.quality_score,
    },
    'runAsrStep: ASR processing completed'
  );
}
```

**注意**：
- 保持与当前架构相同的日志格式和内容
- 确保日志包含足够的调试信息

---

### 8. **并发处理和资源管理** ⚠️

**问题**：
- 多个 job 可能同时处理
- 需要确保 `JobContext` 不会在并发场景下出现问题

**解决方案**：
```typescript
// JobContext 是每个 job 独立的，不会有并发问题
export async function runJobPipeline(options: {
  job: JobAssignMessage;
  // ...
}) {
  // 每个 job 都有自己独立的 JobContext
  const ctx = initJobContext(job);
  
  // ... 处理逻辑 ...
  
  // JobContext 在处理完成后会被垃圾回收
  return buildJobResult(job, ctx);
}
```

**注意**：
- `JobContext` 是每个 job 独立的，不会有并发问题
- 业务逻辑状态（如 `AggregatorState`）由工具类管理，支持并发

---

### 9. **错误恢复和重试机制** ⚠️

**问题**：
- 当前 `PipelineOrchestrator` 有 ASR 重试机制（`rerun_count`）
- 需要确保新架构也支持重试

**解决方案**：
```typescript
export async function runAsrStep(
  job: JobAssignMessage,
  ctx: JobContext,
  services: ServicesBundle,
  options?: { partialCallback?: any; asrCompletedCallback?: any }
) {
  // 构建 ASR 任务（包含重试信息）
  const asrTask: ASRTask = {
    audio: ctx.audio,
    audio_format: ctx.audioFormat,
    rerun_count: ctx.rerunCount || 0,
    max_rerun_count: 2,
    rerun_timeout_ms: 5000,
    // ...
  };
  
  // 调用 ASR 服务（TaskRouter 内部处理重试逻辑）
  const asrResult = await services.taskRouter.routeASRTask(asrTask, options?.partialCallback);
  
  // 更新 JobContext
  ctx.asrText = asrResult.text;
  ctx.asrResult = asrResult;
  ctx.rerunCount = asrResult.rerun_count || 0;
}
```

**注意**：
- 重试逻辑主要在 `TaskRouter` 中处理
- `JobContext` 只需要记录重试次数

---

### 10. **数据验证和边界检查** ⚠️

**问题**：
- 每个步骤都需要验证输入数据
- 需要确保数据验证逻辑不丢失

**解决方案**：
```typescript
export async function runTranslationStep(
  job: JobAssignMessage,
  ctx: JobContext,
  services: ServicesBundle
) {
  // 数据验证
  if (!ctx.repairedText && !ctx.aggregatedText) {
    logger.warn({ jobId: job.job_id }, 'runTranslationStep: No text to translate');
    return;  // 跳过
  }
  
  const textToTranslate = ctx.repairedText || ctx.aggregatedText || '';
  
  if (textToTranslate.trim().length === 0) {
    logger.warn({ jobId: job.job_id }, 'runTranslationStep: Text is empty');
    return;  // 跳过
  }
  
  // 检查服务是否可用
  if (!services.taskRouter) {
    logger.error({ jobId: job.job_id }, 'runTranslationStep: TaskRouter not available');
    return;  // 跳过
  }
  
  // ... 处理逻辑 ...
}
```

**注意**：
- 每个步骤都需要验证输入数据
- 验证失败时应该跳过步骤，而不是抛出异常

---

### 11. **性能监控和指标** ⚠️

**问题**：
- 当前各个 Stage 有性能监控（处理时间等）
- 需要确保新架构也支持性能监控

**解决方案**：
```typescript
export async function runTranslationStep(
  job: JobAssignMessage,
  ctx: JobContext,
  services: ServicesBundle
) {
  const startTime = Date.now();
  
  try {
    // ... 处理逻辑 ...
    
    const duration = Date.now() - startTime;
    logger.info(
      {
        jobId: job.job_id,
        sessionId: job.session_id,
        utteranceIndex: job.utterance_index,
        durationMs: duration,
        textLength: ctx.translatedText?.length || 0,
      },
      'runTranslationStep: Translation completed'
    );
    
    // 记录到指标收集器（如果需要）
    services.metricsCollector?.recordTranslationTime(duration);
    
  } catch (error) {
    const duration = Date.now() - startTime;
    logger.error(
      {
        jobId: job.job_id,
        error,
        durationMs: duration,
      },
      'runTranslationStep: Translation failed'
    );
    throw error;
  }
}
```

**注意**：
- 每个步骤都应该记录处理时间
- 可以集成到现有的指标收集系统

---

### 12. **类型安全和接口一致性** ⚠️

**问题**：
- 需要确保 `JobResult` 接口与现有协议一致
- 需要确保所有字段都正确映射

**解决方案**：
```typescript
// 确保 buildJobResult 返回的 JobResult 与现有接口完全一致
export function buildJobResult(
  job: JobAssignMessage,
  ctx: JobContext
): JobResult {
  return {
    // 基础字段
    text_asr: ctx.repairedText || ctx.aggregatedText || ctx.asrText || '',
    text_translated: ctx.translatedText || '',
    tts_audio: ctx.toneAudio || ctx.ttsAudio || '',
    tts_format: ctx.toneFormat || ctx.ttsFormat || 'opus',
    
    // 元数据
    extra: {
      language_probability: ctx.asrResult?.language_probability,
      language_probabilities: ctx.asrResult?.language_probabilities,
      // ... 其他字段
    },
    
    // ASR 质量信息
    asr_quality_level: ctx.asrResult?.badSegmentDetection?.isBad ? 'bad' : 'good',
    quality_score: ctx.asrResult?.badSegmentDetection?.qualityScore,
    reason_codes: ctx.asrResult?.badSegmentDetection?.reasonCodes,
    
    // Segments
    segments: ctx.asrResult?.segments,
    segments_meta: ctx.asrResult?.segments ? {
      count: ctx.asrResult.segments.length,
      max_gap: calculateMaxGap(ctx.asrResult.segments),
      avg_duration: calculateAvgDuration(ctx.asrResult.segments),
    } : undefined,
    
    // 聚合相关
    aggregation_applied: ctx.aggregationChanged || false,
    aggregation_action: ctx.aggregationAction,
    aggregation_metrics: ctx.aggregationMetrics,
    
    // 语义修复相关
    semantic_repair_applied: ctx.semanticRepairApplied || false,
    semantic_repair_confidence: ctx.semanticRepairConfidence,
    text_asr_repaired: ctx.repairedText,
    
    // 去重相关
    should_send: ctx.shouldSend ?? true,
    dedup_reason: ctx.dedupReason,
    
    // 其他字段
    rerun_count: ctx.rerunCount || 0,
  };
}
```

**注意**：
- 确保所有字段都正确映射
- 确保字段类型与 `JobResult` 接口一致

---

## 实施检查清单

### 迁移前检查

- [ ] 确认所有 Session 清理逻辑都被迁移
- [ ] 确认所有回调函数都被支持
- [ ] 确认所有指标收集方法都被支持
- [ ] 确认服务就绪检查逻辑被保留
- [ ] 确认流式 ASR 部分结果回调被支持
- [ ] 确认上下文重置逻辑被支持
- [ ] 确认日志格式和内容保持一致
- [ ] 确认错误处理和重试机制被保留
- [ ] 确认数据验证逻辑不丢失
- [ ] 确认性能监控功能被保留

### 迁移后验证

- [ ] 测试 Session 清理功能
- [ ] 测试动态依赖更新
- [ ] 测试回调函数
- [ ] 测试指标收集
- [ ] 测试流式 ASR
- [ ] 测试上下文重置
- [ ] 测试错误恢复和重试
- [ ] 测试并发处理
- [ ] 验证日志输出
- [ ] 验证性能指标

---

## 总结

节点端简化架构方案需要注意以下关键点：

1. **Session 生命周期管理**：确保 session 清理功能正常
2. **动态依赖更新**：支持运行时更新依赖
3. **回调函数和指标收集**：保持现有功能
4. **服务就绪检查**：保留首次任务检查逻辑
5. **流式 ASR 支持**：确保部分结果回调正常工作
6. **上下文重置**：支持 Gate-A 功能
7. **日志和监控**：保持详细的日志记录
8. **错误恢复和重试**：保留重试机制
9. **数据验证**：确保每个步骤都有适当的验证
10. **类型安全**：确保接口一致性

通过仔细处理这些细节，可以确保简化架构方案的成功实施。
