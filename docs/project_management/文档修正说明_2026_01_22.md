# 调度服务器技术审议文档 - 修正说明

**日期**: 2026-01-22  
**修订原因**: 决策部门反馈  
**修订版本**: 2.0 → 2.1

---

## 📋 决策部门反馈的问题

决策部门指出了原文档中 4 个"目标状态"与"当前状态"混淆的问题：

1. ❌ "无本地状态" vs "JobDispatcher 内存状态" 矛盾
2. ❌ TTL 时间与代码不一致（文档说 60/70秒，代码是 3600秒）
3. ❌ "无竞态条件"表述过头
4. ❌ Job 状态持久化描述前后不一致

---

## ✅ 修正内容详解

### 1. "无本地状态"矛盾问题

#### 原文档（问题）

**组件表**写：
> JobDispatcher：任务分发，**内存状态**，音频数据优化

**优势部分**写：
> ✅ **无本地状态**，Redis 是 SSOT

❌ **问题**：这两个说法对读者是矛盾的

#### 修正后（准确）

**组件表**修改为：

| 组件 | 职责 | **当前状态存储** | 说明 |
|------|------|----------------|------|
| Redis | 权威数据源 | 节点状态、池信息、任务绑定 | SSOT（节点管理） |
| NodeRegistry | 节点注册表 | Redis 直查，无本地缓存 | ✅ 完全无状态 |
| JobDispatcher | 任务分发 | **内存缓存（短期）** | ⚠️ 调度器重启会丢失 |

**优势部分**修改为：
> ✅ **节点管理无本地权威状态**，Redis 是节点状态的 SSOT  
> ⚠️ **Job 状态在内存**，调度器重启会丢失进行中的任务

✅ **效果**：清楚区分了"节点管理"和"任务调度"的状态存储方式

---

### 2. TTL 时间不一致问题

#### 原文档（问题）

**执行摘要**写：
> 节点 60 秒未心跳 → 状态过期  
> 节点 70 秒未心跳 → 自动从所有池移除

#### 实际代码（Lua 脚本）

```lua
-- register_node_v2.lua
redis.call("EXPIRE", node_key, 3600)  -- ❌ 实际是 3600 秒（1 小时）

-- heartbeat_with_pool_assign.lua
redis.call("EXPIRE", node_key, 3600)  -- ❌ 实际是 3600 秒（1 小时）
```

❌ **问题**：文档说 60秒，代码是 3600秒，差距巨大！

#### 修正后（准确）

**当前 TTL 配置**部分：
> - 节点状态：**3600 秒（1 小时）**
> - Pool 成员：**3600 秒（1 小时）**
> - **说明**：生产环境可根据心跳频率调整（建议：节点 TTL = 心跳间隔 × 2）

**生产环境建议**部分：
> - 心跳间隔：30 秒
> - 节点 TTL：**60-120 秒**（心跳间隔的 2-4 倍）
> - Pool TTL：略长于节点 TTL（例如 +10 秒）

**新增 TTL 参数修改指南**：
```lua
-- 需要修改的文件：
1. scripts/lua/register_node_v2.lua（第 27 行）
2. scripts/lua/heartbeat_with_pool_assign.lua（第 17, 58, 72, 89 行）
3. scripts/lua/select_node.lua（第 66 行，job 绑定）

-- 修改建议：
EXPIRE node_key 3600  -- 当前（测试环境）
EXPIRE node_key 60    -- 生产环境建议（2倍心跳间隔）
EXPIRE node_key 120   -- 生产环境建议（4倍心跳间隔，更容错）
```

✅ **效果**：
- 明确说明当前代码配置是 3600秒
- 提供生产环境调优建议
- 提供详细的修改指南

---

### 3. "无竞态条件"表述过头

#### 原文档（问题）

**优势部分**写：
> ✅ Lua 脚本原子操作，**无竞态条件**

❌ **问题**：表述过于绝对

#### 实际情况

```
单个 Lua 脚本内部：✅ 确实原子

多个 Lua 脚本之间：⚠️ 仍有时序依赖
例如：
- 节点下线脚本 vs 任务重派脚本
- 心跳刷新 TTL vs Pool 成员查询
```

#### 修正后（准确）

**优势部分**修改为：
> ✅ **Lua 脚本保证单操作原子性**，显著降低竞态风险  
> ⚠️ **多脚本间时序依赖**，需通过 key 设计和 TTL 缓解

**新增"当前竞态风险缓解措施"**：
- 使用 TTL 自动清理减少不一致窗口
- 关键路径使用 Lua 脚本保证原子性
- 通过 key 设计避免冲突（例如 job_id 唯一性）

**风险评估表新增一行**：

| 风险 | 等级 | 缓解措施 | 当前状态 |
|------|------|---------|---------|
| 多脚本竞态 | 🟡 中 | TTL + key 设计 | ✅ 已缓解 |

✅ **效果**：
- 不再宣称"完全无竞态"
- 明确说明单操作原子 vs 多操作时序
- 提供了实际的缓解措施

---

### 4. Job 状态持久化描述不一致

#### 原文档（问题）

**优势部分**暗示：
> Redis 已经是统一的状态来源，调度器重启不会带来本质问题

**后续优化部分**却写：
> 任务持久化（可选，3-4 周）：Job 状态写入 Redis，调度器重启后恢复

❌ **问题**：前后矛盾，到底 Job 状态在哪？

#### 实际代码情况

通过检查代码发现：

```rust
// src/core/dispatcher/job.rs
pub struct Job {
    pub job_id: String,
    pub audio_data: Vec<u8>,  // ⚠️ 在内存中
    pub status: JobStatus,    // ⚠️ 在内存中
    // ... 其他字段都在内存
}

// src/phase2/runtime_job_fsm.rs
// ✅ 有 Job FSM 的 Redis 实现，但不完整
pub async fn job_fsm_init(...) { ... }
pub async fn job_fsm_to_dispatched(...) { ... }
// 只记录状态转换，不存储完整 Job 对象
```

**真实情况**：
- Job 完整对象存储在调度器内存
- Redis 只保存：
  - `job_id → node_id` 绑定（timeout finalize 专用）
  - 部分状态转换事件（Job FSM，不完整）

#### 修正后（准确）

**新增"当前状态存储"说明**：
- Job 对象：调度器内存（包含音频数据、状态、元信息）
- Job → Node 绑定：Redis（仅 timeout finalize，TTL: 3600秒）
- WebSocket 连接：调度器内存

**后续优化部分**明确区分：

**1. Job 状态持久化（2-3 周）**

**现状**：
- Job 对象存储在调度器内存
- 调度器重启会丢失进行中的任务
- Redis 只保存 job_id → node_id 绑定（timeout finalize 专用）

**规划**：
- 将 Job 完整状态机写入 Redis
- 调度器重启后可恢复所有 Job
- 实现真正意义的"调度器无状态"

**新增"当前实现 vs 理想目标"对比表**：

| 维度 | 当前实现 ✅ | 理想目标 📋 | 差距评估 |
|------|-----------|-----------|---------|
| 节点管理 | Redis SSOT，完全无状态 | 同左 | ✅ 已达成 |
| Job 状态 | 内存缓存 | Redis 持久化 | 📋 可选优化 |
| 调度器重启 | Job 丢失，需重试 | 无缝恢复 | 📋 可选优化 |

✅ **效果**：
- 明确说明当前 Job 在内存
- 明确说明 Redis 只保存绑定关系
- 清晰区分"现状"和"规划"

---

## 📊 修正版文档的核心改进

### 1. 增加"当前状态"列

所有组件表、对比表都增加了**明确的状态标识**：
- ✅ 已达成
- ⚠️ 有限制（需说明）
- 📋 规划中

### 2. 明确区分三类表述

| 表述类型 | 标识 | 示例 |
|---------|------|------|
| **当前实现** | ✅ / ⚠️ | "Job 对象存储在调度器内存" |
| **理想目标** | 📋 | "Job 完整状态机写入 Redis" |
| **代码配置** | 数值 | "TTL: 3600秒（代码）" |

### 3. 增加实施指南

- **TTL 参数修改指南**（具体到文件和行号）
- **部署前准备**（TTL 调优、负载均衡、监控）
- **灰度发布计划**（10% → 50% → 100%）
- **回滚方案**（保留旧版本镜像）

### 4. 强化风险评估

修正后的风险评估表增加了：
- **当前状态**列（明确说明已实施/规划中）
- **说明**列（详细解释风险影响和缓解效果）
- **多脚本竞态**风险（原文档遗漏）

---

## 📝 修订后的文档清单

### 已完成修正

1. ✅ **执行摘要（修正版）**
   - 文件：`调度服务器技术审议_执行摘要_修正版_2026_01_22.md`
   - 状态：已完成
   - 页数：614 行（原 455 行，增加了 35%）

2. 📋 **完整技术文档（修正版）**
   - 文件：`调度服务器技术审议文档_完整版_2026_01_22.md`
   - 状态：待同步修正（与执行摘要保持一致）

3. ✅ **修正说明文档**
   - 文件：`文档修正说明_2026_01_22.md`（本文档）
   - 状态：已完成

---

## 🎯 给决策部门的建议

### 使用修正版文档

**旧版本**（不建议使用）：
- ❌ `调度服务器技术审议_执行摘要_2026_01_22.md`（已过时）
- ❌ `调度服务器技术审议文档_完整版_2026_01_22.md`（部分过时）

**新版本**（推荐使用）：
- ✅ `调度服务器技术审议_执行摘要_修正版_2026_01_22.md`（准确）
- ✅ `文档修正说明_2026_01_22.md`（本文档，修正对照）

### 关键决策点确认

修正版文档明确了以下关键点，请决策部门重点评估：

1. **TTL 参数需要调整**
   - 当前代码：3600 秒
   - 生产建议：60-120 秒
   - 需要修改 5 个 Lua 脚本

2. **Job 状态在内存**
   - 调度器重启会丢失进行中的任务
   - 需要配置负载均衡（WebSocket 会话保持）
   - 客户端需要实现重试机制

3. **多脚本间存在时序窗口**
   - 单操作原子，多操作通过 TTL 和 key 设计缓解
   - 不是"完全无竞态"，但风险可控

4. **部署前必须完成的事项**
   - ✅ 调整 Lua 脚本 TTL 参数
   - ✅ 配置负载均衡（WebSocket 会话保持）
   - ✅ 部署监控大盘
   - ✅ 准备回滚方案

---

## 📞 后续工作

### 技术团队待办

1. **修改 Lua 脚本 TTL 参数**
   - 优先级：高
   - 时间：1 小时
   - 影响：生产环境稳定性

2. **配置负载均衡**
   - 优先级：高
   - 时间：1 天
   - 影响：Job 分发正确性

3. **完善监控大盘**
   - 优先级：中
   - 时间：1 天
   - 影响：可观测性

4. **Job 状态持久化（可选）**
   - 优先级：中
   - 时间：2-3 周
   - 影响：调度器重启恢复能力

### 决策部门待办

1. **重新评审修正版文档**
   - 确认"当前实现"描述准确
   - 确认"已知限制"可接受
   - 确认"部署前准备"合理

2. **批准部署计划**
   - 确认 TTL 参数调整方案
   - 确认灰度发布计划
   - 确认回滚方案

3. **风险评估会议**
   - 讨论"Job 内存缓存"的影响
   - 讨论"多脚本竞态"的缓解措施
   - 讨论"调度器重启"的应对方案

---

## ✅ 总结

### 修正的核心价值

1. **诚实透明**
   - 明确说明"当前实现"和"理想目标"
   - 不夸大技术能力
   - 明确说明已知限制

2. **可执行性**
   - 提供详细的 TTL 参数修改指南
   - 提供具体的部署前准备清单
   - 提供明确的风险缓解措施

3. **决策友好**
   - 关键信息用表格和对比清晰呈现
   - 风险评估增加"当前状态"和"说明"
   - 决策检查清单完整可用

### 感谢决策部门的反馈

决策部门的反馈非常专业和精准，指出了文档中"目标状态"和"当前状态"混淆的问题，避免了未来可能的误解和运维风险。

修正后的文档更加准确、诚实、可执行，为决策部门提供了真实的技术评估依据。

---

**文档版本**: 修正说明 v1.0  
**最后更新**: 2026-01-22  
**修订人员**: 架构组  
**审议状态**: 待决策部门重新评审修正版文档
