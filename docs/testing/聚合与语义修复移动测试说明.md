# 聚合与语义修复移动测试说明

## 测试目标

验证将文本聚合（AggregationStage）和语义修复从 `PostProcessCoordinator` 移到 `PipelineOrchestrator` 后，节点端的翻译功能仍然正常工作。

## 测试范围

### 1. PipelineOrchestrator 测试

**文件**：`electron_node/electron-node/main/src/pipeline-orchestrator/pipeline-orchestrator-aggregation-semantic-repair.test.ts`

**测试内容**：
- ✅ 文本聚合在 ASR 之后执行
- ✅ 聚合后更新 JobResult 中的聚合字段
- ✅ 聚合后执行内部重复检测
- ✅ 语义修复在聚合之后执行
- ✅ 语义修复使用聚合后的文本
- ✅ 语义修复拒绝时使用原始文本
- ✅ use_asr 为 false 时跳过语义修复
- ✅ 按顺序执行：ASR → 聚合 → 语义修复
- ✅ 聚合和语义修复后正确设置 JobResult 字段

### 2. PostProcessCoordinator 翻译测试

**文件**：`electron_node/electron-node/main/src/agent/postprocess/postprocess-coordinator-translation.test.ts`

**测试内容**：
- ✅ 使用 JobResult 中的聚合后文本进行翻译
- ✅ 使用语义修复后的文本进行翻译
- ✅ 优先使用语义修复后的文本（如果存在）
- ✅ 在聚合和语义修复后正常执行翻译
- ✅ use_nmt 为 false 时跳过翻译
- ✅ NMT-only 模式下使用 input_text
- ✅ 正确传递聚合状态到后续处理
- ✅ 聚合未应用时使用原始文本
- ✅ 完整流程：聚合 → 语义修复 → 翻译

### 3. InferenceService 集成测试

**文件**：`electron_node/electron-node/main/src/inference/inference-service-aggregation-translation.test.ts`

**测试内容**：
- ✅ 完整流程：ASR → 聚合 → 语义修复 → 翻译
- ✅ 将聚合后的文本传递给翻译
- ✅ 将语义修复后的文本传递给翻译
- ✅ 在聚合和语义修复后正常执行翻译
- ✅ use_nmt 为 false 时跳过翻译

## 关键测试点

### 1. 文本聚合与 ASR 绑定

- **位置**：`PipelineOrchestrator.processJob()` 中，ASR 之后、语义修复之前
- **验证**：`AggregationStage.process()` 被调用，且接收正确的 `JobResult`
- **验证**：聚合后的文本用于后续的语义修复

### 2. 语义修复使用聚合后的文本

- **位置**：`PipelineOrchestrator.processJob()` 中，聚合之后
- **验证**：`SemanticRepairStage.process()` 被调用，且接收聚合后的文本
- **验证**：修复后的文本放入 `result.text_asr` 和 `result.text_asr_repaired`

### 3. 翻译使用聚合和修复后的文本

- **位置**：`PostProcessCoordinator.process()` 中
- **验证**：`TranslationStage.process()` 被调用，且接收聚合和修复后的文本
- **验证**：优先使用 `result.text_asr_repaired`（如果存在），否则使用 `result.text_asr`

### 4. JobResult 字段传递

- **验证**：`aggregation_applied`、`aggregation_action`、`is_last_in_merged_group`、`aggregation_metrics` 正确设置
- **验证**：`semantic_repair_applied`、`semantic_repair_confidence`、`text_asr_repaired` 正确设置
- **验证**：这些字段正确传递到 `PostProcessCoordinator`

## 测试执行

### 运行单个测试文件

```bash
# PipelineOrchestrator 测试
npm test -- pipeline-orchestrator-aggregation-semantic-repair.test.ts

# PostProcessCoordinator 翻译测试
npm test -- postprocess-coordinator-translation.test.ts

# InferenceService 集成测试
npm test -- inference-service-aggregation-translation.test.ts
```

### 运行所有相关测试

```bash
npm test -- --testPathPattern="(aggregation|translation|semantic-repair)"
```

## 注意事项

### 1. Mock 设置

- `AggregationStage` 在 `PipelineOrchestrator` 构造函数中创建，需要正确 mock
- `SemanticRepairInitializer` 异步初始化，需要等待初始化完成
- `SemanticRepairStage` 通过 `SemanticRepairInitializer.getSemanticRepairStage()` 获取

### 2. 测试数据

- ASR 结果需要包含 `segments` 和 `language_probability`
- 聚合结果需要包含所有必要的字段（`aggregatedText`、`aggregationChanged`、`action` 等）
- 语义修复结果需要包含 `textOut`、`decision`、`confidence` 等字段

### 3. 执行顺序

- ASR → 聚合 → 去重 → 语义修复 → 构建 JobResult
- PostProcessCoordinator 接收 JobResult → 翻译 → TTS → TONE

## 预期结果

所有测试应该通过，确保：
1. ✅ 文本聚合在 ASR 之后、语义修复之前执行
2. ✅ 语义修复使用聚合后的文本
3. ✅ 翻译使用聚合和修复后的文本
4. ✅ 整个流程（ASR → 聚合 → 语义修复 → 翻译）正常工作
5. ✅ 翻译功能不受影响

## 已知问题

### Mock 设置问题

由于 `AggregationStage` 在 `PipelineOrchestrator` 构造函数中创建，mock 设置可能需要特殊处理。如果测试失败，检查：

1. `AggregationStage` 的 mock 是否正确设置
2. `SemanticRepairInitializer` 的 mock 是否正确设置
3. 测试中的 ASR 结果是否包含所有必要的字段

### 异步初始化

`SemanticRepairInitializer` 是异步初始化的，测试中需要等待初始化完成。如果测试失败，检查：

1. `getInitPromise()` 是否正确 mock
2. `isInitialized()` 是否正确 mock
3. 测试中是否等待了初始化完成

## 后续优化

1. 考虑将 `AggregationStage` 通过依赖注入，而不是在构造函数中创建
2. 考虑将 `SemanticRepairInitializer` 的初始化改为同步或提供更好的测试支持
3. 添加更多的边界情况测试（如空文本、无意义文本等）
