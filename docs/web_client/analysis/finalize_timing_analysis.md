# Finalize时长和音频累积分析报告

## 配置信息

### Web端配置
- **silenceTimeoutMs**: 3000ms (3秒)
  - 用途：静音超时检测，触发finalize
  - 触发条件：连续静音超过3秒
- **VAD静音过滤**：
  - threshold: 0.015
  - releaseThreshold: 0.003（退出语音阈值，更宽松）
  - releaseFrames: 20（连续20帧静音才停止发送，约200ms）
  - **注意**：VAD用于过滤静音片段（不发送），但不用于触发finalize

### 调度服务器配置
- **pause_ms**: 3000ms (3秒)
  - 用途：自动finalize超时
  - 触发条件：连续音频块之间的间隔超过3秒
  - 机制：每次收到音频块时，启动/重置超时计时器，如果3秒内没有新音频块，触发finalize

## 第一段音频（utterance_index=0）分析

### Finalize信息
- **Finalize原因**: Timeout（pause_ms超时）
- **Finalize时音频大小**: 115,247 字节（Opus格式）
- **Finalize时音频时长（估算）**: 约36秒（Opus压缩后）
- **最终TTS音频大小**: 1,103,932 字节（PCM16格式）
- **最终TTS音频时长**: 25.87 秒

### 为什么会累积到25.87秒？

**原因分析：**

1. **用户连续说话**
   - 用户连续说话，没有超过3秒的静音间隔
   - Web端VAD的releaseThreshold设置为0.003（很宽松），所以即使音量稍微降低也不会被判定为静音
   - Web端的silenceTimeoutMs（3秒）没有触发，因为VAD一直在检测到语音

2. **音频块间隔小于3秒**
   - Web端每100ms发送一次音频块（onAudioFrame中每10帧发送一次）
   - 如果用户连续说话，音频块之间的间隔都小于3秒
   - 调度服务器的pause_ms机制不会触发

3. **最终通过Timeout触发**
   - 当用户停止说话后，最后一个音频块发送后，3秒内没有新音频块
   - 调度服务器的pause_ms超时机制触发finalize（reason: "Timeout"）

4. **音频大小差异**
   - Finalize时：115,247 字节（Opus格式，压缩后）
   - 最终TTS：1,103,932 字节（PCM16格式，未压缩）
   - 差异原因：节点端将Opus解码为PCM16，然后TTS生成PCM16音频

## 问题总结

**为什么会出现超过25秒的长音频？**

1. ✅ **Web端VAD配置过于宽松**
   - releaseThreshold: 0.003 太低，导致说话过程中音量稍微降低也不会被判定为静音
   - releaseFrames: 20 帧（200ms）可能不够，如果用户说话有短暂停顿，可能不会被检测到

2. ✅ **没有最大时长限制**
   - 当前只有pause_ms（3秒间隔）限制，没有总时长限制
   - 如果用户连续说话超过25秒，音频会一直累积

3. ✅ **Web端静音检测可能不够敏感**
   - silenceTimeoutMs: 3000ms 可能太长
   - 或者静音检测机制没有正确工作

## 建议解决方案

1. **添加最大时长限制**
   - 在调度服务器端添加最大音频时长限制（例如20秒）
   - 超过限制时自动finalize，即使没有pause

2. **优化Web端VAD配置**
   - 调整releaseThreshold，使其更容易检测到静音
   - 或者添加基于时长的自动finalize机制

3. **在Web端添加最大时长检查**
   - 在发送音频块前，检查当前累积时长
   - 如果超过阈值（例如20秒），自动发送is_final=true

