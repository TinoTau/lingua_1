# 强制语义修复：架构改动 — 决策部门审议文档

**日期**：2026-01  
**用途**：供决策部门审议「语义修复必经且必须成功、失败即 job 失败并回传调度」的架构改动。  
**结论**：语义修复 step 为必经且必须成功；任何不可用/超时/异常均让 job 失败并将错误回传调度服务器，由调度重分配。不再存在 PASS 降级。

---

## 一、设计契约（写进代码注释）

| 层级 | 契约 |
|------|------|
| **语义修复 step** | 本步骤为必经且必须成功；不可用/超时/异常由 stage/router throw，pipeline 视为 job 失败并回传调度。成功时 decision 为 REPAIR 或 PASS，均写回 ctx。 |
| **TaskRouter（路由层）** | 对每个 utterance 必须调用语义修复并成功返回；不可用/超时/异常一律 throw，不再存在 PASS 作为降级策略。 |
| **SemanticRepairStage（Stage 层）** | 必须调用语义修复并成功返回；不可用/不支持语言/异常一律 throw。空文本允许直通（非服务失败）。 |
| **Python 服务** | 超时/异常一律 raise，不再返回 PASS；不支持语言返回 400。 |

---

## 二、错误传播路径（单路径、无降级）

```
runSemanticRepairStep
  → SemanticRepairStage.process
    → TaskRouterSemanticRepairHandler.routeSemanticRepairTask
      （无 endpoint / 健康不可用 / 并发超时 / 调用异常 → throw）
    → 或 SemanticRepairStage：不支持语言 / ZH stage 不可用 / zhStage.process 抛错 → throw
  ← throw 冒泡
executeStep(step) 抛错
  → job-pipeline catch：step === 'SEMANTIC_REPAIR' → throw error
runJobPipeline 抛错
  → InferenceService.processJob 抛错
  → JobProcessor.processJob 抛错
  → NodeAgent.handleJob catch
    → resultSender.sendErrorResult(job, error, startTime)
      → WebSocket 发送 job_result：success: false, error: { code: 'PROCESSING_ERROR', message }
```

调度服务器收到 `job_result` 且 `success: false` 即判定 job 失败；`message` 中已含 `SEM_REPAIR_*:` 前缀，可按需解析后重试/重分配。

---

## 三、代码片段（按文件）

### 3.1 TypeScript：task-router-semantic-repair.ts

**文件头设计契约：**

```typescript
/**
 * 设计契约（强制语义修复，失败即失败）：
 * - 对每个 utterance 必须调用语义修复并成功返回。
 * - 若语义修复不可用/超时/异常：job 直接失败，由上层将错误回传调度服务器（调度重试/重分配）。
 * - 不再存在 PASS 作为降级策略；不可用/超时/异常一律 throw。
 */
```

**无 endpoint 时：**

```typescript
if (!endpoint) {
  logger.warn(
    { lang: task.lang, serviceId, message: 'Semantic repair service not found' },
    'Semantic repair service not available, failing job'
  );
  throw new Error('SEM_REPAIR_UNAVAILABLE: SERVICE_NOT_AVAILABLE');
}
```

**健康检查不可用时：**

```typescript
if (!healthResult.isAvailable) {
  logger.warn(..., 'Semantic repair service not available (not warmed), failing job');
  throw new Error(`SEM_REPAIR_UNAVAILABLE: SERVICE_NOT_${healthResult.status}`);
}
```

**并发许可超时（5s）：**

```typescript
} catch (error: any) {
  logger.warn(..., 'Semantic repair concurrency timeout, failing job');
  throw new Error('SEM_REPAIR_TIMEOUT: CONCURRENCY_TIMEOUT');
}
```

**调用服务异常/超时时：**

```typescript
} catch (error: any) {
  const isTimeout = error.message?.includes('timeout') || error.name === 'AbortError';
  logger.error(..., 'Semantic repair service error, failing job');
  const code = isTimeout ? 'SEM_REPAIR_TIMEOUT: SERVICE_TIMEOUT' : 'SEM_REPAIR_ERROR: SERVICE_ERROR';
  throw new Error(`${code} (${error.message || error})`);
}
```

---

### 3.2 TypeScript：semantic-repair-stage.ts

**文件头设计契约：**

```typescript
/**
 * 设计契约（强制语义修复，失败即失败）：
 * - 必须调用语义修复并成功返回；不可用/不支持语言/异常一律 throw，由调度重分配。
 * - 空文本允许直通（非服务失败，仅为输入为空）。
 */
```

**空文本（仍直通，不视为失败）：**

```typescript
if (!text || text.trim().length === 0) {
  return {
    textOut: text,
    decision: 'PASS',
    confidence: 1.0,
    reasonCodes: ['EMPTY_TEXT'],
    semanticRepairApplied: false,
  };
}
```

**不支持语言（非 zh/en）：**

```typescript
} else {
  logger.warn(
    { jobId: job.job_id, srcLang },
    'SemanticRepairStage: Unsupported language, failing job'
  );
  throw new Error('SEM_REPAIR_UNSUPPORTED_LANG: UNSUPPORTED_LANGUAGE');
}
```

**ZH stage 不可用：**

```typescript
if (!this.zhStage) {
  logger.warn({ jobId: job.job_id }, 'SemanticRepairStage: ZH stage not available, failing job');
  throw new Error('SEM_REPAIR_UNAVAILABLE: ZH_STAGE_NOT_AVAILABLE');
}
```

**ZH 处理（无 try/catch，抛错直接冒泡）：**

```typescript
const result = await this.zhStage.process(job, text, qualityScore, meta);
return {
  textOut: result.textOut,
  decision: result.decision,
  confidence: result.confidence,
  diff: result.diff,
  reasonCodes: result.reasonCodes,
  repairTimeMs: result.repairTimeMs,
  semanticRepairApplied: result.decision === 'REPAIR',
};
```

---

### 3.3 TypeScript：job-pipeline.ts

**关键步骤失败即 throw（SEMANTIC_REPAIR 与 ASR、TRANSLATION 同等）：**

```typescript
      } catch (error: any) {
        logger.error(
          { error: error?.message || error || 'Unknown error', stack: error?.stack, jobId: job.job_id, step, modeName: mode.name },
          `Step ${step} failed`
        );

        // 根据步骤的重要性决定是否继续（语义修复为必经且必须成功，失败即 job 失败）
        if (step === 'ASR' || step === 'TRANSLATION' || step === 'SEMANTIC_REPAIR') {
          throw error;
        } else {
          logger.warn({ jobId: job.job_id, step }, `Step ${step} failed, continuing with next step`);
        }
      }
```

---

### 3.4 TypeScript：semantic-repair-step.ts

**文件头设计契约（逻辑未改，失败由上游 throw 冒泡）：**

```typescript
/**
 * 设计契约（强制语义修复，失败即失败）：
 * - 本步骤为必经且必须成功；不可用/超时/异常由 stage/router throw，pipeline 将错误视为 job 失败并回传调度。
 * - 成功时 decision 为 REPAIR 或 PASS（服务端返回无修改时为 PASS），均写回 ctx；REJECT 保留原文。
 */
```

---

### 3.5 TypeScript：node-agent-simple.ts（handleJob）

**job 失败时统一走 sendErrorResult：**

```typescript
    try {
      const processResult = await this.jobProcessor.processJob(job, startTime);
      // ... buildResultsToSend、发送循环 ...
    } catch (error) {
      this.resultSender.sendErrorResult(job, error, startTime);
    }
```

---

### 3.6 TypeScript：node-agent-result-sender.ts（sendErrorResult）

**其他错误（含语义修复失败）单一路径，不解析 message：**

```typescript
    // 其他错误：统一 PROCESSING_ERROR，message 即抛错内容（语义修复等已含 SEM_REPAIR_* 前缀，调度可按需解析）
    const errorResponse: JobResultMessage = {
      type: 'job_result',
      job_id: job.job_id,
      attempt_id: job.attempt_id,
      node_id: this.nodeId,
      session_id: job.session_id,
      utterance_index: job.utterance_index,
      success: false,
      processing_time_ms: Date.now() - startTime,
      error: {
        code: 'PROCESSING_ERROR',
        message: error instanceof Error ? error.message : String(error),
      },
      trace_id: job.trace_id,
    };

    this.ws.send(JSON.stringify(errorResponse));
```

---

### 3.7 Python：processor_wrapper.py

**文件头设计契约：**

```python
"""
设计契约（强制语义修复，失败即失败）：
- 对每个请求必须调用处理器并成功返回；超时/异常一律 raise，由节点端 job 失败并回传调度重分配。
- 不再存在 PASS 作为降级策略。
"""
```

**超时：**

```python
        except asyncio.TimeoutError:
            elapsed_ms = int((time.time() - start_time) * 1000)
            logger.warning(...)
            raise HTTPException(
                status_code=504,
                detail={"code": "SEM_REPAIR_TIMEOUT", "reason": "TIMEOUT", "elapsed_ms": elapsed_ms},
            )
```

**异常：**

```python
        except Exception as e:
            elapsed_ms = int((time.time() - start_time) * 1000)
            logger.error(...)
            raise HTTPException(
                status_code=503,
                detail={"code": "SEM_REPAIR_ERROR", "reason": "ERROR", "message": str(e), "elapsed_ms": elapsed_ms},
            )
```

---

### 3.8 Python：service.py（统一修复端点）

**不支持语言（非 zh/en）：**

```python
    else:
        # 不支持的语言：返回 400，由节点端 job 失败并回传调度重分配
        raise HTTPException(
            status_code=400,
            detail={"code": "SEM_REPAIR_UNSUPPORTED_LANG", "reason": "UNSUPPORTED_LANGUAGE"},
        )
```

---

## 四、节点端回传调度（调度侧对接）

- 节点端**未新增**对 `message` 的解析或 `details`；语义修复失败与其它 job 失败走**同一条路径**。
- 发送内容：`job_result`，`success: false`，`error: { code: 'PROCESSING_ERROR', message }`。`message` 即 throw 时的字符串。
- 语义修复失败时，`message` 前缀为下表（调度端若需区分重试策略，可解析 `message`，如按 `:` 取首段）：

| message 前缀 | 含义 |
|--------------|------|
| SEM_REPAIR_UNAVAILABLE: | 无端点或健康检查不可用 |
| SEM_REPAIR_TIMEOUT: | 并发许可超时或服务调用超时 |
| SEM_REPAIR_ERROR: | 服务 5xx/网络/解析等错误 |
| SEM_REPAIR_UNSUPPORTED_LANG: | 不支持的语言（400） |

---

## 五、回归验收要点

1. **语义修复服务正常**：每句调用成功，pipeline 正常出结果。
2. **语义修复服务不可用**（停服务/health 不可用）：节点端 job 失败，job_result 带 `success: false`，message 含 `SEM_REPAIR_UNAVAILABLE`，调度可重分配。
3. **并发许可超时**：job 失败，message 含 `SEM_REPAIR_TIMEOUT: CONCURRENCY_TIMEOUT`。
4. **Python 超时**：processor_wrapper 返回 504，节点端 job 失败，调度可重分配。
5. **不支持语言**：Python 返回 400，节点端 job 失败，message 含 `SEM_REPAIR_UNSUPPORTED_LANG`，调度应换节点或拒绝任务。

---

## 六、涉及文件清单

| 文件 | 改动性质 |
|------|----------|
| `electron_node/electron-node/main/src/task-router/task-router-semantic-repair.ts` | 设计契约注释；4 处 return PASS → throw |
| `electron_node/electron-node/main/src/agent/postprocess/semantic-repair-stage.ts` | 设计契约注释；2 处 return PASS → throw；ZH/EN 去掉 catch 降级 PASS |
| `electron_node/electron-node/main/src/pipeline/job-pipeline.ts` | SEMANTIC_REPAIR 加入关键步骤（throw 不继续） |
| `electron_node/electron-node/main/src/pipeline/steps/semantic-repair-step.ts` | 设计契约注释（逻辑未改） |
| `electron_node/electron-node/main/src/agent/node-agent-simple.ts` | 无改动（已有 catch → sendErrorResult） |
| `electron_node/electron-node/main/src/agent/node-agent-result-sender.ts` | 无新增逻辑（其它错误统一 PROCESSING_ERROR + message） |
| `electron_node/services/semantic_repair_en_zh/base/processor_wrapper.py` | 设计契约注释；TimeoutError/Exception → raise HTTPException |
| `electron_node/services/semantic_repair_en_zh/service.py` | 不支持语言 → raise HTTPException(400) |
| `electron_node/electron-node/main/src/agent/postprocess/semantic-repair-stage.test.ts` | 3 个用例由“返回 PASS”改为“期望 throw” |

---

**文档版本**：V1  
**状态**：待决策部门审议
