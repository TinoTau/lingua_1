# 强制语义修复：失败即失败 — 实现说明

**日期**：2026-01  
**方案**：语义修复 step 为必经且必须成功；任何不可用/超时/异常均让 job 失败并将错误回传调度服务器，由调度重分配。

---

## 一、已完成的代码改动（最小 Patch）

### 1. TypeScript：task-router-semantic-repair.ts

- **设计契约**（文件头注释）：必须调用语义修复并成功返回；不可用/超时/异常一律 throw。
- **原 PASS 回退全部改为 throw**：
  - 无 endpoint → `throw new Error('SEM_REPAIR_UNAVAILABLE: SERVICE_NOT_AVAILABLE')`
  - 健康检查不可用 → `throw new Error('SEM_REPAIR_UNAVAILABLE: SERVICE_NOT_${status}')`
  - 并发许可超时（5s）→ `throw new Error('SEM_REPAIR_TIMEOUT: CONCURRENCY_TIMEOUT')`
  - 调用服务异常/超时 → `throw new Error('SEM_REPAIR_TIMEOUT: SERVICE_TIMEOUT')` 或 `SEM_REPAIR_ERROR: SERVICE_ERROR (原错误信息)`

### 2. TypeScript：semantic-repair-stage.ts

- **设计契约**（文件头注释）：必须调用语义修复并成功返回；空文本允许直通（非服务失败）。
- **原 PASS 回退改为 throw**：
  - 不支持语言（非 zh/en）→ `throw new Error('SEM_REPAIR_UNSUPPORTED_LANG: UNSUPPORTED_LANGUAGE')`
  - ZH stage 不可用 → `throw new Error('SEM_REPAIR_UNAVAILABLE: ZH_STAGE_NOT_AVAILABLE')`
  - ZH stage 抛错 → 不再 catch 返回 PASS，直接冒泡
- **EN 路径**：EN repair stage 抛错不再 catch 返回 PASS，直接冒泡。
- **空文本**：仍返回 PASS（直通），不视为失败。

### 3. TypeScript：job-pipeline.ts

- **SEMANTIC_REPAIR** 与 ASR、TRANSLATION 同等视为**关键步骤**：该 step 抛错即 `throw error`，不再“继续下一步”。

### 4. TypeScript：semantic-repair-step.ts

- **设计契约**（文件头注释）：本步骤为必经且必须成功；抛错由 pipeline 视为 job 失败并回传调度。
- 逻辑未改：仍消费 REPAIR/PASS/REJECT；成功路径（REPAIR 或 PASS）写回 ctx，REJECT 保留原文。上游改为 throw 后，失败不会进入此处。

### 5. TypeScript：node-agent-result-sender.ts

- **未新增逻辑**：语义修复失败与其它 job 失败走同一条路径：`sendErrorResult` → `job_result.success: false`，`error: { code: 'PROCESSING_ERROR', message }`。`message` 即 throw 时的字符串（task-router/stage 已包含 `SEM_REPAIR_*:` 前缀），调度端如需区分可解析 `message`，不在节点端做解析或 `details`。

### 6. Python：processor_wrapper.py

- **设计契约**（文件头注释）：超时/异常一律 raise，不再返回 PASS。
- **TimeoutError** → `raise HTTPException(504, detail={"code": "SEM_REPAIR_TIMEOUT", "reason": "TIMEOUT", "elapsed_ms": ...})`
- **Exception** → `raise HTTPException(503, detail={"code": "SEM_REPAIR_ERROR", "reason": "ERROR", "message": ..., "elapsed_ms": ...})`

### 7. Python：service.py

- **不支持语言**（非 zh/en）→ `raise HTTPException(400, detail={"code": "SEM_REPAIR_UNSUPPORTED_LANG", "reason": "UNSUPPORTED_LANGUAGE"})`
- 节点端 fetch 收到非 2xx 会抛错，进而 job 失败并回传调度。

### 8. Python：zh_repair_processor.py / en_repair_processor.py

- **成功统一为 REPAIR**：删除 `text_out == text_in ? PASS : REPAIR`；成功一律 `decision="REPAIR"`。
- **观测**：`reason_codes` 中 `REPAIR_APPLIED`（有改文）或 `NO_CHANGE`（无改文），失败由 wrapper raise。

### 9. 单元测试

- **semantic-repair-stage.test.ts**：  
  - 不支持语言、ZH stage 不可用、ZH stage 抛错 — 由“返回 PASS”改为“期望 throw”（`rejects.toThrow(...)`）。

---

## 二、节点端是否能把语义修复失败回传调度服务器？

**结论：能。**

1. **调用链**：  
   `runSemanticRepairStep` → `SemanticRepairStage.process` → `TaskRouterSemanticRepairHandler.routeSemanticRepairTask`。  
   任一环节 throw → `executeStep` 抛错 → `job-pipeline` 的 catch 中因 `step === 'SEMANTIC_REPAIR'` 而 **再次 throw** → `runJobPipeline` 抛错 → `InferenceService.processJob` 抛错 → `JobProcessor.processJob` 抛错 → `NodeAgent.handleJob` 的 **catch** 执行。

2. **handleJob 的 catch**（node-agent-simple.ts）：
   ```ts
   } catch (error) {
     this.resultSender.sendErrorResult(job, error, startTime);
   }
   ```
   即：**任意 job 失败（含语义修复失败）都会调用 `sendErrorResult`**。

3. **sendErrorResult**（node-agent-result-sender.ts）：通过 WebSocket 发送 **job_result**：`success: false`，`error: { code: 'PROCESSING_ERROR', message }`。与其它 job 失败同一路径，无对 message 的解析或额外 `details`。

4. **调度服务器**：收到 `job_result` 且 `success: false` 即可判定 job 失败；`message` 中已含 `SEM_REPAIR_*:` 前缀（如 `SEM_REPAIR_TIMEOUT: ...`），若需按错误类型重试/重分配，可在调度侧解析 `message`。

因此，**节点端已具备“语义修复失败 → job 失败 → 错误回传调度”的完整路径**；未新增流程分支或补丁逻辑。

---

## 三、错误信息（供调度解析 message）

节点端统一返回 `error.code: 'PROCESSING_ERROR'`，`error.message` 为抛错内容。语义修复失败时 message 前缀为：

| message 前缀 | 含义 |
|--------------|------|
| SEM_REPAIR_UNAVAILABLE: | 无端点或健康检查不可用 |
| SEM_REPAIR_TIMEOUT: | 并发许可超时或服务调用超时 |
| SEM_REPAIR_ERROR: | 服务 5xx/网络/解析等错误 |
| SEM_REPAIR_UNSUPPORTED_LANG: | 不支持的语言（400） |

调度端若需区分重试策略，可解析 `message`（如按 `:` 取首段）；节点端不做解析，保持单一路径。

---

## 四、回归验收要点

1. **语义修复服务正常**：每句调用成功，pipeline 正常出结果。
2. **语义修复服务不可用**（停服务/health 不可用）：节点端 job 失败，job_result 带 `success: false` 与 `SEM_REPAIR_UNAVAILABLE`，调度可重分配。
3. **并发许可超时**：job 失败，错误码 SEM_REPAIR_TIMEOUT，不再 CONCURRENCY_TIMEOUT→PASS。
4. **Python 超时**：processor_wrapper 返回 504，节点端 job 失败，调度可重分配。
5. **不支持语言**：Python 返回 400，节点端 job 失败，错误码 SEM_REPAIR_UNSUPPORTED_LANG，调度应换节点或拒绝任务。
