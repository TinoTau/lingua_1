# 强制语义修复：逐文件最小 Patch 清单（执行版）

**目标**：语义修复 step 必经且必须成功；任何不可用/超时/异常 → job 失败 → 错误回传调度 → 调度重分配。  
**原则**：不引入新流程路径、不做兼容、不增加兜底逻辑，仅删除回退、改为 fail-fast。  
**日期**：2026-01

---

## 1) `main/src/task-router/task-router-semantic-repair.ts`

**改动类型：删除 PASS 回退 → 统一 throw**

- [x] 文件头新增**设计契约注释**：语义修复必须成功；任何异常直接抛错
- [x] 删除所有 `return { decision:'PASS', ... }`
- [x] 以下场景统一 `throw new Error(...)`（错误前缀保持）：
  - 无 endpoint → `SEM_REPAIR_UNAVAILABLE: SERVICE_NOT_AVAILABLE`
  - health 非 ok → `SEM_REPAIR_UNAVAILABLE: SERVICE_NOT_${status}`
  - 并发许可超时（5s）→ `SEM_REPAIR_TIMEOUT: CONCURRENCY_TIMEOUT`
  - 调用超时/异常 → `SEM_REPAIR_TIMEOUT: SERVICE_TIMEOUT` 或 `SEM_REPAIR_ERROR: SERVICE_ERROR (<msg>)`

**验收**：router 不再返回 PASS；仅成功返回或 throw。

---

## 2) `main/src/agent/postprocess/semantic-repair-stage.ts`

**改动类型：删降级 → 直抛**

- [x] 文件头新增**设计契约注释**
- [x] 非 `zh/en` → `throw new Error('SEM_REPAIR_UNSUPPORTED_LANG: UNSUPPORTED_LANGUAGE')`
- [x] ZH stage 不可用 → `throw new Error('SEM_REPAIR_UNAVAILABLE: ZH_STAGE_NOT_AVAILABLE')`
- [x] ZH/EN repair 抛错不再 catch→PASS，**直接冒泡**
- [x] **空文本**：允许直通（不视为失败）

**验收**：除空文本外，不再出现 PASS 降级。

---

## 3) `main/src/pipeline/job-pipeline.ts`

**改动类型：把语义修复列为关键步骤**

- [x] 将 `SEMANTIC_REPAIR` 与 ASR/TRANSLATION 同等对待
- [x] step 抛错 → **立即 throw**，不再继续后续步骤

**验收**：语义修复失败必然终止 job。

---

## 4) `main/src/pipeline/steps/semantic-repair-step.ts`

**改动类型：语义收敛（可选精简）**

- [x] 文件头注明：本 step **必经且必须成功**
- [x] 不新增分支；成功路径写回 `ctx.repairedText`
- [ ] （可选）对“非空文本出现 PASS”加一条 **debug 断言日志** — **未做**，保持逻辑简单

**验收**：失败不进入该 step；成功只走单一路径。

---

## 5) `main/src/agent/node-agent-result-sender.ts`

**改动类型：不改逻辑（确认）**

- [x] 保持现状：失败统一走 `sendErrorResult`
- [x] `error.code='PROCESSING_ERROR'`，`message` 透传 throw 的字符串（含 `SEM_REPAIR_*:` 前缀）
- [x] 不做解析、不加 `details`（保持单一路径）

**验收**：语义修复失败与其它失败完全同路回传调度。

---

## 6) `services/semantic_repair_en_zh/base/processor_wrapper.py`

**改动类型：删 PASS → raise**

- [x] 文件头新增**设计契约注释**
- [x] `TimeoutError` → `raise HTTPException(504, detail={code:'SEM_REPAIR_TIMEOUT', ...})`
- [x] 其它异常 → `raise HTTPException(503, detail={code:'SEM_REPAIR_ERROR', ...})`
- [x] **不再返回 PASS + 原文**

**验收**：服务端失败统一 4xx/5xx。

---

## 7) `services/semantic_repair_en_zh/service.py`

**改动类型：不支持语言 fail-fast**

- [x] 非 `zh/en` → `raise HTTPException(400, detail={code:'SEM_REPAIR_UNSUPPORTED_LANG', ...})`

**验收**：节点端 fetch 非 2xx → throw → job 失败。

---

## 8) `services/semantic_repair_en_zh/processors/{zh,en}_repair_processor.py`

**改动类型：删除伪状态机（成功统一 REPAIR）**

- [x] 删除 `text_out == text_in ? PASS : REPAIR`
- [x] 成功统一视为 **REPAIR**；失败由 wrapper 抛错
- [x] 保留观测：`reason_codes` 中 `REPAIR_APPLIED`（有改文）或 `NO_CHANGE`（无改文）

**验收**：不再出现“修复成功但 PASS”的语义歧义。

---

## 9) 测试：`semantic-repair-stage.test.ts`

**改动类型：断言由 PASS → throw**

- [x] 不支持语言 / ZH 不可用 / 抛错 → `rejects.toThrow(...)`
- [x] 空文本 → 仍通过

**验收**：测试与 fail-fast 契约一致。

---

# 全局回归 Checklist（最小）

- [ ] 非空 utterance：**必调用语义修复一次**
- [ ] 任意语义修复失败：**job 失败并回传调度**
- [ ] 不再出现 PASS 降级（除空文本）
- [ ] 无重复调用、无重复发送
- [ ] 调度侧可基于 `SEM_REPAIR_*:` 前缀重分配

---

**说明**：清单中 4) 的“可选 debug 断言日志”未实现，以保持代码简洁；其余项均已按方案 A 落地。
