# 直接用 turnId 进行合并 — 可行性说明（2026-01）

**问题**：如果直接用 turnId 进行合并是否可行？  
**结论**：分三种含义；其中「调度附带 turnId、节点端合并」**技术上可行**，但与当前已冻结的「取消跨 Job 前向合并」裁决**直接冲突**，需决策部门明确是否修订裁决。

---

## 一、三种「用 turnId 合并」的含义

| 场景 | 含义 | 可行性 |
|------|------|--------|
| **调度附带 turnId，节点端合并** | 调度在 job_assign 中附带 turn_id；节点按 turn_id 查找「同一 turn 的上一 job」的 pending/buffer，合并进本 job 再送 ASR、输出。 | **技术上可行**，但与「取消跨 Job 前向合并」裁决**冲突**（见下） |
| **节点端自主用 turnId 合并** | 节点无 turn_id 时按 sessionId 等回溯合并（或协议无 turn_id）。 | 与裁决冲突，且当前协议无 turn_id，不讨论。 |
| **调度/Web 端用 turnId 合并** | 调度或 Web 收到 job_result 后，按 turn_id（+ utterance_index）分组、排序、拼接展示。 | **可行**，与既有设计一致。 |

---

## 二、「调度附带 turnId，节点端合并」— 技术上可行，但与当前裁决冲突

### 2.1 您的意思（确认）

- **调度**：在分配任务时在 job_assign 中附带 **turn_id**（调度端已有 current_turn_id，只需写入协议并下发给节点）。
- **节点**：收到 job_assign 后，用 **turn_id** 查找「同一 turn 的上一 job」的 pendingMaxDurationAudio（或上一 job 的 buffer），合并进本 job 再送 ASR、输出一条结果。

这样 Job2 到来时可按 turn_id 找到 Job1 的 4.8s pending，合并后一起送 ASR，前半句不再丢失。

### 2.2 技术可行性

| 点 | 说明 |
|----|------|
| **协议** | JobAssignMessage 增加可选字段 `turn_id?: string`；调度在创建 job_assign 时填入当前 `current_turn_id` 即可。 |
| **节点** | 节点维护「turn_id → 上一 job 的 pending 信息」（如 pendingMaxDurationAudio + jobInfo），或「turn_id → 上一 buffer 引用」。本 job 处理时若带 turn_id，先按 turn_id 取上一 job 的 pending，合并进本 job 的音频再走 ASR/聚合；合并后清除或更新该 turn_id 的 pending。 |
| **生命周期** | 同一 turn 内多 job 顺序到达，节点按顺序合并；turn 结束（手动/Timeout finalize）后调度会清 current_turn_id，下一 turn 的 job 带新 turn_id，不会误合。 |

**结论**：**技术上可行**，协议与节点改动量可控，能解决「Job2 前半句丢失」和「空结果」问题。

### 2.3 与当前架构裁决的冲突

《取消跨 Job 前向合并_推荐方案说明》已**冻结**且明确写出否决项：

- **彻底取消节点端跨 Job 前向合并**；不允许「等下一 job 再合并」。
- **否决项第 1 条**：**「节点端按 sessionId / turnId 回溯并合并上一 Job buffer」** — 引入跨 key 扫描与复杂状态。

「调度附带 turnId、节点端合并」正是**按 turnId 回溯并合并上一 Job buffer**，与上述裁决**直接冲突**。在未修订该裁决前，**不应实施**。

### 2.4 若决策部门采纳「调度附带 turnId、节点端合并」

需要**先修订**《取消跨 Job 前向合并》裁决，例如：

- 将「节点端按 sessionId / turnId 回溯并合并上一 Job buffer」从**否决项**改为**允许项**（仅限按 **turn_id** 合并，且 turn_id 由调度在 job_assign 中提供）；
- 或单独成文：允许「调度在 job_assign 中附带 turn_id，节点端仅按 turn_id 合并同一 turn 内上一 job 的 pending」，并约定不引入 session 级扫描、不跨 turn 合并。

修订后，再实施协议增加 turn_id、节点按 turn_id 合并即可。

---

## 三、节点端「无调度 turnId」的自主合并 — 不可行

若节点**不**从调度拿到 turn_id，而是用 sessionId 等自己推断「上一 job」并合并，则同样属于已否决的「节点端按 sessionId / turnId 回溯并合并上一 Job buffer」，且推断逻辑复杂、易错，**不可行**。

---

## 四、调度/Web 端用 turnId 合并 — 可行

### 4.1 与既有设计一致

同一份方案说明中已约定：

- 跨 Job 的语义拼接**应上移至调度服务器 / Web 端**。
- 跨 Job 的连续性由 **turnId + segmentIndex** 负责。

因此，「合并」发生在调度或 Web，用 **turn_id** 作为「同一段发言」的聚合键，与设计一致，**直接用 turnId 进行合并是可行的**。

### 4.2 当前与 turnId 相关的实现

- **调度端**：  
  - 在 finalize 时已有 `current_turn_id`（见 `actor_finalize.rs`、`job_creator.rs`）；  
  - 用于 **select_node** 的 turn 亲和（同一 turn 的 job 派到同一节点）；  
  - **Job 结构体当前未持久化 turn_id**，job_result 回传时只有 session_id、utterance_index、job_id 等，调度端无法直接按 turn_id 分组。

- **协议**：  
  - JobAssignMessage 未向节点下发 turn_id；  
  - 节点不感知 turn，只按 job 内闭环处理。

### 4.3 若要在「调度/Web 端用 turnId 合并」需要补什么

要在调度或 Web **直接用 turnId 进行合并**，需要让「每个 result 对应哪个 turn」可知：

| 方式 | 说明 |
|------|------|
| **在 Job 上存 turn_id（推荐）** | 创建 job 时把当前 `turn_id` 写入 Job（及持久化到 Redis/内存），job_result 回传时用 job_id 反查 Job 得到 turn_id，再按 turn_id 分组、按 utterance_index/segment_index 排序后合并。 |
| **在 job_result 中带 turn_id** | 若希望 Web 或其它服务直接按 turn_id 合并而不查调度端，可在协议里让调度在转发 result 时附带 turn_id（调度端从本侧 Job 或 session 状态中取 turn_id 填入）。 |

以上任一种都能支撑「调度/Web 端用 turnId 合并」，且**不违背**「节点端不做跨 Job 合并」的裁决。

### 4.4 合并逻辑本身

- 收到一批 job_result 后，按 **turn_id** 分组；  
- 组内按 **utterance_index**（或 segment_index）排序；  
- 对同一 turn 的 text_asr / text_translated 等按序拼接（或按产品规则做展示层合并）。  

这部分不依赖节点，与「取消跨 Job 前向合并」无冲突。

---

## 五、总结

| 问题 | 结论 |
|------|------|
| **「调度附带 turnId，节点端合并」是否可行？** | **技术上可行**（协议加 turn_id、节点按 turn_id 查上一 job pending 并合并）；但与当前已冻结的「取消跨 Job 前向合并」裁决**直接冲突**（否决项第 1 条即为「节点端按 turnId 回溯并合并上一 Job buffer」）。若采纳，需**先修订**该裁决。 |
| **调度/Web 端用 turnId 合并** | **可行**，与既有设计一致；需让 result 与 turn 可关联（Job 存 turn_id 或 result 带 turn_id），再按 turn_id 分组、utterance_index 排序后拼接。 |

**建议**：  
- 若希望采用「**调度分配任务时附带 turnId、节点端合并**」：需决策部门**修订**《取消跨 Job 前向合并》裁决（将「按 turnId 合并」从否决改为允许，且限定 turn_id 由调度在 job_assign 中提供）；修订后再实施协议与节点改动。  
- 若维持当前裁决：不在节点端做任何跨 Job 合并，合并仅在调度/Web 端按 turnId + utterance_index 做。

---

## 六、实施说明（2026-01）

以下方案通过「**bufferKey = turnId**」实现同一 turn 内多 job 共用同一 buffer，使 MaxDuration finalize 后下一 job 复用同一 bufferKey，自动续写上一 job 的 pendingMaxDurationAudio，从而避免 Job2 前半句丢失：

**说明**：此方案在节点端按 turn 复用 buffer，效果上仍属「同一 turn 内跨 Job 的合并」。若采纳，建议与第二节 2.4 的裁决修订一并由决策部门审议（将「按 turnId 合并/复用」从否决改为允许，且限定 turn_id 由调度在 job_assign 中提供）。

| 位置 | 改动 |
|------|------|
| **调度端** | Job 结构体增加 `turn_id: Option<String>`；创建 Job 时写入当前 `turn_id`；`JobAssign` 消息增加 `turn_id` 并下发给节点。 |
| **协议** | `JobAssignMessage` 增加可选字段 `turn_id?: string`。 |
| **节点端** | `buildBufferKey(job)` 改为 `job.turn_id ?? job.job_id`；无 `turn_id` 时退化为按 job_id（行为与改造前一致）。 |

未新增跨 key 扫描或「回溯合并」逻辑：仅将 buffer 的 key 从 job_id 改为同一 turn 共用的 turn_id，聚合器原有「按 key 取 buffer、同 key 续写」逻辑不变，MaxDuration 续句自然落在同一 buffer 内。
