# 取消跨 Job 前向合并 — 技术确认与后果说明（2026-01）

**依据**：决策部门方案 `docs/decision/取消跨job前向合并_推荐方案说明.md`  
**目的**：确认该方案所述事实是否属实、方案是否可行、落地后会造成什么后果。

---

## 一、事实确认（是否属实）

| 决策文档所述 | 代码/日志核对 | 结论 |
|--------------|----------------|------|
| 节点端 bufferKey 已统一为 jobId，每个 Job 独立 buffer | `audio-aggregator-buffer-key.ts` / 改造文档：buildBufferKey 与 bufferKey=job_id 一致；日志中 Job1 bufferKey=job-df6cabf3...，Job2=job-bcf4ca19... | **属实** |
| Job2 永远看不到 Job1 的 buffer | 节点用 job_id 作 bufferKey，getBuffer(job) 仅查当前 job 的 key；下一 job 为新 job_id → Buffer not found | **属实** |
| 原有设计隐含「同一次发言多 Job 在节点可连续合并」 | `audio-aggregator-maxduration-handler.ts` 第 7 行注释「剩余部分缓存到 pendingMaxDurationAudio，**等待下一个 job 合并**」；`audio-aggregator-finalize-merge.ts` 等有「合并 pendingMaxDurationAudio」逻辑 | **属实** |
| MaxDuration 时「不输出结果、等待下一 Job 合并」导致空结果 | 日志：Job1 shouldWaitForMerge=true，segmentLength=0，Job processing completed 且 textAsr=""、isEmptyJob=true；Job2 Buffer not found，未合并 4.8s | **属实** |
| 跨 Job 前向合并与新架构（bufferKey=jobId）根本性冲突 | 同上：pending 存于 Job1 buffer，Job2 用新 key 查不到，无法合并 | **属实** |

**结论**：决策文档中的**问题背景、根因分析、设计原则**与当前代码和集成测试日志一致，**属实**。

---

## 二、方案可行性（是否可行）

### 2.1 核心裁决回顾

- **彻底取消节点端跨 Job 前向合并**
- MaxDuration finalize **不再允许输出空结果**
- 不再使用 `shouldWaitForMerge = true`（用于「等下一 Job 再发」）
- 不再依赖 `pendingMaxDurationAudio` 传递到下一 Job
- **任何 finalize 都必须输出当前 Job 内「可得到的最好结果」**

### 2.2 技术可行性

| 点 | 说明 |
|----|------|
| **MaxDuration：剩余音频在本 Job 内处理** | 当前 MaxDuration 把「前 5s+」送 ASR、剩余写入 `pendingMaxDurationAudio`。改造后：**不写 pendingMaxDurationAudio**，把「剩余」也作为本 Job 的 batch（或第二批）一并返回；pipeline 已有 `audioSegments` 数组、多段 ASR 与聚合，可在**同一 job 内**对多 batch 跑 ASR 并合并为一条 job_result。 | **可行** |
| **不再因「等合并」发空结果** | 当前当 `shouldWaitForMerge=true` 时本 job 的 job_result 不带文本（空结果）。取消该路径后，只要本 job 有 ASR 输出就带出，不再为「等下一 job」扣留。AggregationStage / result builder 中去掉或绕过「shouldWaitForMerge → 空结果」即可。 | **可行** |
| **与「Job 内闭环、跨 Job 拼接上移」一致** | 节点只负责「本 job 内所有音频 → 本 job 一条结果」；跨 job 顺序与拼接由调度/Web 用 turnId + segmentIndex 负责。不引入 session/turn 级扫描、不跨 key 合并。 | **一致** |

**结论**：在不动摇「Job 最小单位、bufferKey=jobId、跨 Job 拼接上移」的前提下，**方案技术上可行**。

---

## 三、落地后后果（会造成什么）

### 3.1 直接收益（与决策文档一致）

- **Job2 前半句不再丢失**：Job1 的 9.1s 在本 job 内全部送 ASR 并输出一条结果，不再把 4.8s 留给「下一 job」；Job2 只处理自己那 1.5s，界面按 turnId + segmentIndex 展示 [0]、[1]、[2] 即可。
- **因「等合并」产生的空结果消失**：不再出现「本 job 有 ASR 文本却发 isEmptyJob」；空结果仅剩 RMS 拒绝、真正无识别等合理情况。
- **控制流收敛**：finalize → 输出结果（单一路径），不再有「finalize → 等下一 job → 再 finalize」的跨 job 依赖。
- **与 turn/segment 设计对齐**：跨 job 拼接明确由调度/Web 负责，节点职责清晰。

### 3.2 需要接受的后果与注意点

| 后果/注意点 | 说明 |
|-------------|------|
| **同一 Job 可能多段 ASR** | MaxDuration 的「前 5s+」与「剩余」在同一 job 内处理时，可能对应 2 次 ASR 调用、再在节点内合并为一条 job_result。单 job 耗时略增（仍在本 job 生命周期内），无需协议或调度改动。 |
| **文本层「短句等合并」行为变化** | 当前 text-forward-merge-gate 会在 6–20/20–40 字等情况下设 `shouldWaitForMerge=true`，本 job 不发文本、等下一 job。取消后，这些短句会**在本 job 即发出**，可能从「多 job 合并成一句展示」变为「多 segment 按顺序展示」。若产品希望「仍按句合并展示」，需在 **Web/调度用 turnId + segmentIndex 做展示层合并**，而不是节点扣留。 |
| **测试与用例需同步** | 大量用例依赖 `pendingMaxDurationAudio`、`shouldWaitForMerge`（如 `audio-aggregator.test.ts`、`audio-aggregator-finalize-merge.ts`、`text-forward-merge-gate` / manager 相关测试）。需随方案改为「本 job 内处理完、必出结果」，并删除或重写「跨 job 合并」相关用例。 |
| **Buffer 生命周期与 TTL** | 当前有「pendingMaxDurationAudio 超 TTL 强制 flush」等逻辑；取消 pending 后，这些分支可删除或简化，buffer 删除逻辑更简单（本 job 结束即清）。 |

### 3.3 不采纳的替代方案（与决策文档一致）

- **节点端按 sessionId/turnId 回溯合并上一 Job buffer**：会引入跨 key、跨 job 状态，与「bufferKey=jobId、不跨 key」冲突。
- **调度端回收并重发节点 pending 音频**：协议与带宽复杂度高，且与「节点 Job 内闭环」原则不符。
- **增加 TTL/等待窗口猜测是否有下一 Job**：与「无超时猜测」的既定决策冲突。

---

## 四、总结

| 问题 | 结论 |
|------|------|
| 决策文档所述事实是否属实？ | **属实**。与代码、日志一致。 |
| 方案是否可行？ | **可行**。可在不违背现有架构的前提下，通过「MaxDuration 剩余在本 job 内处理」「取消 shouldWaitForMerge 导致的空结果」实现。 |
| 会造成什么后果？ | **收益**：Job2 前半句不再丢失、空结果减少、控制流收敛、与 turn/segment 对齐。**需要接受**：同一 job 可能多段 ASR、文本层「短句等合并」改为由展示层做、测试与 buffer 逻辑需同步调整。 |

建议以决策文档为**唯一依据**进行最小 patch 与实现调整；若需，可再单独列一版「取消跨 Job 前向合并」的逐文件改动清单与测试调整清单。
