# 异常 Job 根因分析（2026-01）

基于 `analyze_jobs_per_service_flow` 脚本对 `electron-main.log` 的分析结果，逐类说明异常现象、根因位置与建议修复方向。

---

## 一、异常分类与对应 Job

| 类型 | 涉及 Job | 现象摘要 |
|------|----------|----------|
| **job-1 幽灵 NMT** | utterance_index=1, job_id=job-1 | 无 ASR/聚合/语义修复/job_result 发送，但脚本展示「NMT 已执行、translatedText 长度 4、preview: Translated.» |
| **同一 ui 双 Job** | ui=1 | 存在 job-1 与 job-f0797f8b-... 两个 job_id，utterance_index 均为 1 |
| **HOLD 未送语义修复** | ui=1 (job-f0797f8b)、ui=4 | 有 ASR 与 segmentForJobResult，但 shouldSendToSemanticRepair=false，未走 NMT/TTS |
| **ASR 空 + 低质量拒绝** | ui=6, 10, 11, 12, 13, 14 | ASR 返回空，日志有「Rejecting low quality audio, returning empty result」 |
| **DUP_SEND** | ui=3 (job-7e91de76) | job_result 发送次数=2 |

---

## 二、根因与代码位置

### 1. job-1（幽灵 NMT）

**现象**：Summary 表中 job-1 的 NMT req/resp = 0/0、job_result sent = 0，但详情里出现「translatedText 长度: 4」「translatedTextPreview: Translated.»。

**根因判断**：

- 脚本按「日志行中是否出现 jobId/job_id 等于该 job」归并到该 job；**translatedText/translatedTextPreview** 是从该 job 的所有日志行里用正则提取的。
- 若某条日志同时带有 `job_id: "job-1"` 和 `translatedText: "Translated."`（长度 4），就会被算到 job-1 的「NMT 输出」里。
- 生产代码中**没有**对 NMT 返回固定写死 `"Translated."` 的逻辑；该字符串仅出现在单测 mock（`translation-stage.context.test.ts` 的 `routeNMTTask.mockResolvedValue({ text: 'Translated.' })`）。
- 因此要么是：**(1) 同一次运行中混入了单测输出写入了 electron-main.log**，**(2) 调度侧下发了 job_id 为字面量 "job-1" 的 job，且某处错误地打出了带 translatedText 的日志**。

**结论**：job-1 在统计上**未**发起 NMT 请求、也未发送 job_result；详情里的「Translated.» 来自某条含 job_id "job-1" 的日志行，需在原始日志中搜 `"job-1"` 与 `"Translated."` 定位该行来源（测试/错误打日志）。

**建议**：

- 在 `electron-main.log` 中搜索 `"job-1"`，确认该 job 的来源（调度下发的真实 job 还是测试）。
- 若为真实 job：检查为何无 ASR/聚合日志（是否未走主 pipeline 或日志未带 jobId）。
- 若为测试混入：确保单测不写主进程日志文件，或使用独立 log 路径。

---

### 2. 同一 utterance_index 出现两个 job（ui=1）

**现象**：utterance_index=1 对应两个 job_id：`job-1` 与 `job-f0797f8b-fc6e-43a1-819a-acb0dd00b7e2`。

**根因判断**：

- 调度服务器或上游会按会话、utterance 下发 job；同一 ui 出现两个 job_id 通常表示：
  - 调度侧对同一 utterance 发了两次（重试、双路、bug），或
  - 节点侧某处生成了额外的「虚拟 job」或把同一音频处理了两次并赋予不同 job_id。
- 节点端 pipeline 是「一个 job 一条链路」：一个 `job_assign` 对应一次 `handleJob` → 一次 `sendJobResult`（在应发送时）。**节点端不会根据 utterance_index 去重或合并 job_id**。

**结论**：根因在**调度侧或会话管理**：同一 utterance_index 被分配了两个 job_id。节点端只是按收到的 job 执行并回传结果。

**建议**：

- 在调度/会话层查：同一 session_id + utterance_index 是否可能被分配多个 job_id。
- 若为设计（如重试、备选路径），需在调度侧做去重或只认其中一个 job 的结果，避免客户端按 ui 展示时混乱。

---

### 3. HOLD 未送语义修复（shouldSendToSemanticRepair=false）

**现象**：  
- ui=1（job-f0797f8b）：ASR 有输出「我會先讀一兩句比較短的話,用來確認」，聚合有 segmentForJobResult，但 **shouldSendToSemanticRepair=false**，未走 NMT/TTS，有发送 job_result。  
- ui=4：ASR 有输出「10秒鐘之後系統會不會因為超時或者經營來電影而插型把這句話解斷」，同样 **shouldSendToSemanticRepair=false**，未走 NMT/TTS。

**根因（代码位置）**：

- **TextForwardMergeManager**（`main/src/agent/postprocess/text-forward-merge-manager.ts`）的 **Gate 决策** `decideGateAction` 根据**合并后文本长度**和**是否手动发送**决定 SEND/HOLD/DROP：
  - **&lt; 6 字符**：DROP，不送语义修复。
  - **6–20 字符**：若非手动发送（`isManualCut=false`）→ **HOLD**（等待与下一句合并），**shouldSendToSemanticRepair=false**。
  - **20–40 字符**：若非手动发送 → **HOLD**（等待约 3 秒），**shouldSendToSemanticRepair=false**；超时后由后续逻辑 SEND。
  - **&gt; 40 字符**：SEND，**shouldSendToSemanticRepair=true**。

- 长度配置来自 `nodeConfig.textLength`（默认 `minLengthToKeep=6`, `minLengthToSend=20`, `maxLengthToWait=40`, `waitTimeoutMs=3000`），见同文件构造函数与 `text-forward-merge-length-decider`。

**对应关系**：

- 「我會先讀一兩句比較短的話,用來確認」长度在 6–20 之间，且非手动发送 → HOLD → 不送语义修复/NMT/TTS，符合当前逻辑。
- 「10秒鐘之後系統會不會因為超時或者經營來電影而插型把這句話解斷」约 30+ 字，落在 20–40 → HOLD（等 3 秒），若 3 秒内没有新的 processText 调用或超时未触发 SEND，本段就不会在本 job 内送语义修复。

**结论**：这是**当前 Gate 策略的预期行为**，不是单点 bug。若产品希望「每一句只要 ASR 有结果就都做语义修复+NMT+TTS」，需要调整策略（例如缩短 HOLD 区间、或对某些场景强制 SEND）。

**建议**：

- 产品确认：短句/中等长度句是否允许「等下一句合并」再送；若不允许，可考虑：
  - 调小 `minLengthToSend` / `maxLengthToWait`，或
  - 在特定场景（如检测到静音/断句）将 `isManualCut` 设为 true，或
  - 增加「超时后对本段单独 SEND」的路径并保证只发送一次 job_result。

---

### 4. ASR 空 + 低质量拒绝（ui=6, 10, 11, 12, 13, 14）

**现象**：这些 Job 的 ASR 输出为空，日志中出现「ASR task: Rejecting low quality audio, returning empty result」及「ASR task: Audio quality too low (likely silence or noise), rejecting」。

**根因（代码位置）**：

- **task-router-asr.ts**（约 98–126 行）：在调用 ASR 服务前执行 `checkAudioQuality(task, endpoint.serviceId)`；若返回 falsy，直接返回空 ASR 结果（text='', segments=[]），并打上述 warn 日志。
- **task-router-asr-audio-quality.ts**：`checkAudioQuality` 对 `task.audio` 做 PCM 解析，计算 RMS（归一化到 0–1）；若 **rmsNormalized &lt; MIN_RMS_THRESHOLD（0.008）** 则判定为静音/极低质量，返回 `null`，从而触发上面的空结果路径。

**结论**：这些 Job 的音频在节点端被判定为「音量过低/静音」，**未发给 ASR 服务**，直接返回空，导致后续聚合为空、不送语义修复/NMT/TTS，客户端易出现 [音频丢失]。

**建议**：

- **接受当前策略**：若业务上希望过滤掉极短/静音片段，可保留现状，仅在文档中说明「低质量音频会返回空结果」。
- **放宽判定**：若怀疑误杀有效语音，可：
  - 将 `MIN_RMS_THRESHOLD` 调低（如 0.005），或
  - 改为可配置（如从 nodeConfig 读取），便于按环境调参。
- **观测**：在日志中增加「被拒绝的 job_id、utterance_index、estimatedDurationMs、rms」等，便于区分「真实静音」与「有效但音量偏小」的片段。

---

### 5. DUP_SEND（ui=3, job-7e91de76）

**现象**：Summary 表显示该 Job 的 job_result sent = 2；脚本闭环断言标出 **DUP_SEND**。

**根因判断**：

- 节点端 **sendJobResult** 仅在 **node-agent-simple.ts** 的 `handleJob` 中调用（约 439 行），且按当前设计每个 job 只应发送一次结果。
- job_result 被发送两次，只可能来自：
  - **同一 job 的 handleJob 被调用了两次**（例如 WebSocket 重复下发同一 `job_assign`，或某处重复入队同一 job），或
  - **存在另一条代码路径也调用了 sendJobResult**（已确认 asr-step 等不再发送，仅 node-agent-simple 一处）。

**结论**：根因偏向**同一 job 被处理两次**（调度重复下发或节点重复消费），需在调度/节点侧查「同一 job_id 的 job_assign 是否被处理了两次」。

**建议**：

- 在 `electron-main.log` 中按 `job_id: "job-7e91de76-78e6-4858-8a2b-7b740ff19a59"` 搜索，确认「Job result sent successfully」等发送日志是否出现两次及时间戳。
- 在调度侧确认：同一 job_id 是否可能被下发两次（重试、多实例、会话恢复等）。
- 若需在节点端防护：可在发送前做**幂等**（如按 job_id 记录「已发送」，同一 job_id 再次进入 handleJob 时跳过发送或仅打 warn）。

---

## 三、汇总表（问题 → 位置 → 建议）

| 问题 | 根因位置 | 建议 |
|------|----------|------|
| job-1 详情出现「Translated.» | 某条含 job_id "job-1" 的日志行；生产无该固定返回值 | 搜原始日志定位该行；区分测试混入 vs 错误打日志 |
| 同一 ui 两个 job_id | 调度/会话层 | 查同一 session+utterance_index 是否分配多 job_id；调度去重或只认其一 |
| HOLD 不送语义修复 | TextForwardMergeManager.decideGateAction（6–20 / 20–40 字且非手动） | 按产品需求调 lengthConfig 或 isManualCut，或增加超时 SEND 路径 |
| ASR 空、低质量拒绝 | task-router-asr + task-router-asr-audio-quality（RMS &lt; 0.008） | 保持现状或调低/可配置 MIN_RMS_THRESHOLD，并加观测 |
| DUP_SEND（ui=3） | 同一 job 被 handleJob 两次（调度或节点重复） | 日志确认发送两次；调度去重；节点可做 job_id 发送幂等 |

---

## 四、建议的下一步

1. **job-1**：在本次测试的 `electron-main.log` 中搜索 `"job-1"` 和 `"Translated."`，定位并修正日志来源或测试隔离。
2. **ui=1 双 Job**：在调度/会话代码中查「同一 session_id + utterance_index 对应多个 job_id」的生成与去重逻辑。
3. **HOLD**：与产品确认「短句/中等句是否必须在本句内走语义修复+NMT+TTS」；若必须，再改 TextForwardMergeManager 的 Gate 或超时 SEND。
4. **低质量拒绝**：确认当前 0.008 阈值是否过严；必要时改为配置项并加指标。
5. **DUP_SEND**：对 job-7e91de76 查日志确认两次发送的时间与调用栈；在调度或节点做幂等防护。

以上分析基于当前代码与脚本输出；若日志或配置有更新，可重新跑脚本并对照本表更新结论。
