# 节点端 Job 调度管理、AudioAggregator、Utterance 聚合与 NMT 上下文流程审议

**文档目的**：供决策部门审议节点端「Job 调度管理」「AudioAggregator（从 ASR 收到 job 到送入 ASR）」「Utterance 聚合（从 ASR 返回到送语义修复）」「NMT 上下文处理（从语义修复返回到送入 NMT）」的完整调用链，并识别是否存在重复调用或错误调用导致的不必要开销。

**代码基准**：`electron_node/electron-node/main/src`（截至 2026-01）。

---

## 一、Job 调度管理（节点端）

### 1.1 入口与步骤顺序

| 序号 | 调用位置 | 方法/模块 | 说明 |
|------|----------|-----------|------|
| 1 | WebSocket 收到 `job_assign` | `NodeAgentSimple.handleJobAssign()` | 节点收到调度派发的 job |
| 2 | 同上 | `JobProcessor.processJob(job, startTime)` | 单 job 处理入口 |
| 3 | 同上 | `InferenceService.processJob(job, partialCallback)` | 推理服务入口；首次 job 会 `waitForServicesReady()` |
| 4 | 同上 | `taskRouter.refreshServiceEndpoints()` | 刷新服务端点（带缓存） |
| 5 | 同上 | **`runJobPipeline({ job, services, ... })`** | **唯一 Pipeline 编排入口** |
| 6 | `job-pipeline.ts` | `inferPipelineMode(job)` | 根据 job.pipeline 推断模式（如 GENERAL_VOICE_TRANSLATION） |
| 7 | 同上 | 按 `mode.steps` 循环 | 步骤序列：**ASR → AGGREGATION → SEMANTIC_REPAIR → DEDUP → TRANSLATION → TTS/YOURTTS** |
| 8 | 同上 | `shouldExecuteStep(step, mode, job, ctx)` | 动态判断是否执行（如 SEMANTIC_REPAIR 仅当 `ctx.shouldSendToSemanticRepair === true`） |
| 9 | 同上 | `executeStep(step, job, ctx, services, stepOptions)` | 从 `STEP_REGISTRY` 取执行函数并执行 |
| 10 | 同上 | `buildJobResult(job, ctx)` | 构建最终 JobResult |

**结论（调度管理）**：单 job 单次 `runJobPipeline`，步骤顺序固定、条件执行明确，无重复编排。

---

## 二、AudioAggregator 流程（从 ASR 收到 job 到送入 ASR）

### 2.1 调用链（按方法）

| 序号 | 文件 | 方法/调用 | 说明 |
|------|------|-----------|------|
| 1 | `pipeline/steps/asr-step.ts` | `runAsrStep(job, ctx, services, options)` | ASR 步骤入口 |
| 2 | 同上 | `new PipelineOrchestratorAudioProcessor(services.audioAggregator)` | 每 job 新建 AudioProcessor（轻量，无状态） |
| 3 | 同上 | `audioProcessor.processAudio(job)` | 音频处理入口 |
| 4 | `pipeline-orchestrator/pipeline-orchestrator-audio-processor.ts` | `this.audioAggregator.processAudioChunk(job)` | **唯一进入 AudioAggregator 的调用** |
| 5 | `pipeline-orchestrator/audio-aggregator.ts` | `processAudioChunk(job)` | 聚合入口；`bufferKey = sessionId`；解码、缓冲、finalize、切片 |
| 6 | 同上 | `decodeAudioChunk(job, SAMPLE_RATE, BYTES_PER_SAMPLE)` | 解码当前 chunk（opus/pcm16 → PCM16） |
| 7 | 同上 | `this.buffers.get(bufferKey)` / 创建新 buffer | 按 session 维度的缓冲区 |
| 8 | 同上 | `this.timeoutHandler.checkTimeoutTTL(currentBuffer, job, currentAudio, nowMs)` | 检查 pendingTimeoutAudio 是否超 TTL（10s），超则直接返回待处理片段 |
| 9 | 同上 | 更新 `currentBuffer.audioChunks`、`totalDurationMs`、`originalJobInfo` | 当前 chunk 写入 buffer |
| 10 | 同上 | 若 `isMaxDurationTriggered` → `this.maxDurationHandler.handleMaxDurationFinalize(..., this.aggregateAudioChunks.bind(this), this.createStreamingBatchesWithPending.bind(this))` | 超长句按能量切片，处理前 ≥5s，剩余缓存 |
| 11 | 同上 | 若 `shouldProcessNow`（手动/超时/≥10s/≥20s）→ `currentBuffer.state = 'FINALIZING'`，`this.aggregateAudioChunks(currentBuffer.audioChunks)`，`this.finalizeHandler.handleFinalize(...)` | 合并 pending（mergePendingMaxDurationAudio、mergePendingTimeoutAudio、mergePendingSmallSegments），得到待送 ASR 的音频 |
| 12 | `audio-aggregator-finalize-handler.ts` | `handleFinalize()` → `mergePendingMaxDurationAudio()` / `mergePendingTimeoutAudio()` / `mergePendingSmallSegments()` | 三类 pending 的合并逻辑 |
| 13 | `audio-aggregator.ts` 或 handler | `createStreamingBatchesWithPending()` / 能量切分 | 得到 `audioSegments[]`（base64 PCM16）与 `originalJobIds` / `originalJobInfo` |
| 14 | `pipeline-orchestrator-audio-processor.ts` | 若 `!chunkResult.shouldReturnEmpty` 且 `audioSegments.length > 0`，返回 `audioSegments`、`originalJobIds`、`originalJobInfo` | 供 ASR 步骤使用 |
| 15 | `asr-step.ts` | `audioSegments` 循环：每段构建 `ASRTask`，`services.taskRouter.routeASRTask(asrTask)` 或 `asrHandler.processASRStreaming(...)` | **送入 ASR 服务** |

**结论（AudioAggregator）**：每个 job 只进入一次 `processAudioChunk`；解码、缓冲、finalize、切片、送 ASR 的路径清晰，未发现同一 job 下重复调用 `processAudioChunk` 或重复送 ASR 的逻辑。

---

## 三、Utterance 聚合流程（从 ASR 返回结果到送语义修复服务）

### 3.1 调用链（按方法，到具体调用）

| 序号 | 文件 | 方法/调用 | 说明 |
|------|------|-----------|------|
| 1 | `pipeline/steps/aggregation-step.ts` | `runAggregationStep(job, ctx, services)` | 聚合步骤入口 |
| 2 | 同上 | 若 `!ctx.asrText` 或 `trim` 为空 → `ctx.segmentForJobResult = ''`，`ctx.repairedText = ''`，return | ASR 为空则直接返回 |
| 3 | 同上 | 若 `!services.aggregatorManager` → `ctx.segmentForJobResult = ctx.asrText`，`ctx.shouldSendToSemanticRepair = true`，return | 无聚合器时本段直送语义修复 |
| 4 | 同上 | `tempResult = { text_asr: ctx.asrText, segments, extra, quality_score }` | 构造临时 JobResult |
| 5 | 同上 | **`services.aggregatorManager.getLastCommittedText(job.session_id, job.utterance_index)`** | **① 获取上一句已提交文本（Trim 用）** |
| 6 | 同上 | `ctx.lastCommittedText = lastCommittedText ?? null` | 写入 ctx，供语义修复步骤只读 |
| 7 | 同上 | `new AggregationStage(services.aggregatorManager, services.deduplicationHandler)` | **每 job 新建 AggregationStage（内建 new TextForwardMergeManager）** |
| 8 | 同上 | `aggregationStage.process(jobWithDetectedLang, tempResult, lastCommittedText)` | 执行聚合与向前合并 |
| 9 | `agent/postprocess/aggregation-stage.ts` | `AggregationStage.process(job, result, lastCommittedText)` | 入口 |
| 10 | 同上 | 若 `!result.text_asr` 或 trim 为空 → return 空结果 | 空 ASR 不往下走 |
| 11 | 同上 | **`this.aggregatorManager.processUtterance(session_id, asrTextTrimmed, segments, langProbs, quality_score, isFinal, isManualCut, mode, isTimeoutTriggered)`** | **Utterance 级聚合（MERGE/NEW_STREAM/COMMIT）** |
| 12 | 同上 | 根据 `aggregatorResult.action`（MERGE/NEW_STREAM）设置 `aggregatedText`、`isLastInMergedGroup` | 仅合并组最后一条带聚合文本 |
| 13 | 同上 | 若 `this.deduplicationHandler` 存在 → **`this.deduplicationHandler.isDuplicate(session_id, aggregatedText, job_id, utterance_index)`** | 去重判定（完全重复/子串/高相似度） |
| 14 | 同上 | 若 duplicate → return 空结果、`shouldSendToSemanticRepair: false` | DROP |
| 15 | 同上 | `lastSentText = this.deduplicationHandler.getLastSentText(session_id)`（若存在） | 供 Gate 日志 |
| 16 | 同上 | **`this.forwardMergeManager.processText(sessionId, textAfterDeduplication, previousText, job_id, utterance_index, isManualCut, lastSentText)`** | **向前合并 + Gate（SEND/HOLD/DROP）** |
| 17 | `agent/postprocess/text-forward-merge-manager.ts` | `processText()` | 内部：mergeByTrim（dedupMergePrecise）、decideGateAction（长度与 HOLD/SEND/DROP）、可选写入 pendingTexts |
| 18 | `aggregation-stage.ts` | `segmentForJobResult = forwardMergeResult.segmentForCurrentJob`，`finalAggregatedText = forwardMergeResult.processedText`（仅当 shouldSendToSemanticRepair） | 本 job 本段 + 送语义修复的合并句 |
| 19 | `aggregation-step.ts` | `ctx.segmentForJobResult = aggregationResult.segmentForJobResult`，`ctx.shouldSendToSemanticRepair = aggregationResult.shouldSendToSemanticRepair`；若 false 则 `ctx.repairedText = ''` | 写回 ctx |
| 20 | `job-pipeline.ts` | 若 `shouldExecuteStep('SEMANTIC_REPAIR', ...)` 为 true（即 `ctx.shouldSendToSemanticRepair === true`）→ `executeStep('SEMANTIC_REPAIR', ...)` | 执行语义修复步骤 |
| 21 | `pipeline/steps/semantic-repair-step.ts` | `runSemanticRepairStep(job, ctx, services)` | 语义修复步骤入口 |
| 22 | 同上 | `textToRepair = (ctx.segmentForJobResult ?? '').trim()` | 只读本段 |
| 23 | 同上 | 若 `!services.semanticRepairInitializer` 或 init 失败或 `!getSemanticRepairStage()` → `ctx.repairedText = ''`，`ctx.shouldSend = false`，return | 语义修复不可用时不透传 |
| 24 | 同上 | `semanticRepairStage.process(jobWithDetectedLang, textToRepair, qualityScore, { segments, language_probability, micro_context })` | **调用语义修复服务** |
| 25 | 同上 | `ctx.repairedText = repairResult.textOut`；若存在 `services.aggregatorManager` → **`services.aggregatorManager.updateLastCommittedTextAfterRepair(session_id, utterance_index, textToRepair, ctx.repairedText)`** | 写回修复结果并更新「上一句已提交」 |

**结论（Utterance 聚合）**：  
- `getLastCommittedText` 在聚合步骤中**只调用 1 次**，用于 Trim 与 Gate 的「上一句」快照，语义合理。  
- `processUtterance`、`isDuplicate`、`processText` 在单次 `AggregationStage.process` 内各调用 1 次，无重复。  
- 唯一可能讨论点：**每 job 新建 `AggregationStage`（及内建 `TextForwardMergeManager`）**。二者均为无状态调用，创建成本低；若未来做「按 session 复用实例」可再评估，当前未发现错误或重复调用。

---

## 四、NMT 上下文处理（从语义修复返回到送入 NMT）

### 4.1 调用链（按方法）

| 序号 | 文件 | 方法/调用 | 说明 |
|------|------|-----------|------|
| 1 | `pipeline/steps/translation-step.ts` | `runTranslationStep(job, ctx, services)` | 翻译步骤入口 |
| 2 | 同上 | 若 `ctx.shouldSend === false` 或 `ctx.shouldSendToSemanticRepair === false` → 置空译文并 return | 未送语义修复则不翻译 |
| 3 | 同上 | `textToTranslate = (ctx.repairedText ?? '').trim()` | **NMT 输入 = 语义修复产出（本段）** |
| 4 | 同上 | 获取 `TranslationStage`（来自 `semanticRepairInitializer` 或 services 注入），`translationStage.process(job, textToTranslate, ctx.qualityScore, dedupCharsRemoved, semanticRepairContext)` | 进入翻译阶段 |
| 5 | `agent/postprocess/translation-stage.ts` | `TranslationStage.process(job, aggregatedText, ...)` | 入口 |
| 6 | 同上 | **`contextText = this.aggregatorManager?.getLastCommittedText(job.session_id, job.utterance_index) ?? undefined`** | **② 获取「上一句已提交」作为 NMT context_text** |
| 7 | 同上 | 若 `contextText` 长度 > 200 → `contextText = contextText.slice(-200)` | 截断为最多 200 字 |
| 8 | 同上 | `cacheKey = generateCacheKey(job.src_lang, job.tgt_lang, aggregatedText, contextText)` | 缓存键含上下文 |
| 9 | 同上 | 若缓存命中 → return 缓存译文 | 不调 NMT |
| 10 | 同上 | `sequentialExecutor.execute(sessionId, utteranceIndex, 'NMT', () => this.executeNMT(job, aggregatedText, contextText, startTime))` | 顺序执行 NMT |
| 11 | 同上 | `executeNMT(job, aggregatedText, contextText, startTime)`：构建 `NMTTask`，**`context_text: contextText`**，`this.taskRouter.routeNMTTask(nmtTask)` | **送入 NMT 服务（带上下文）** |

**结论（NMT 上下文）**：  
- **`getLastCommittedText` 在翻译阶段调用 1 次**，专门为 NMT 的 `context_text` 提供「上一句已提交」；该值在语义修复步骤中已通过 `updateLastCommittedTextAfterRepair` 更新，因此此处读取的是**修复后的上一句**，语义正确。  
- 与聚合步骤中的 `getLastCommittedText` 用途不同：聚合步骤用于 Trim/ Gate，翻译步骤用于 NMT 上下文；且两次调用之间有一次 `updateLastCommittedTextAfterRepair`，**不是重复逻辑，也不是错误调用**。

---

## 五、重复调用与潜在开销审议

### 5.1 `getLastCommittedText` 调用次数与必要性

| 调用点 | 时机 | 用途 | 是否必要 |
|--------|------|------|----------|
| **① runAggregationStep** | 聚合前 | 作为 `lastCommittedText` 传入 `AggregationStage.process`，用于 TextForwardMergeManager 的 Trim（边界去重）与 Gate 决策 | **必要**：聚合阶段需要「上一句」快照 |
| **② TranslationStage.process** | 翻译前 | 作为 NMT 的 `context_text`（上一句原文，已修复） | **必要**：语义修复后已通过 `updateLastCommittedTextAfterRepair` 更新，NMT 必须用更新后的值 |

**审议结论**：同一 job 内 `getLastCommittedText` 被调用 2 次，分别服务于聚合（Trim/Gate）与 NMT 上下文，且第二次调用前已更新「上一句已提交」内容，**无重复逻辑，无错误调用，不构成不必要的开销**。

### 5.2 每 Job 新建实例

| 实例 | 创建位置 | 说明 |
|------|----------|------|
| **PipelineOrchestratorAudioProcessor** | `runAsrStep` | 每 job 新建，仅包装 `audioAggregator`，无重状态，开销可忽略 |
| **AggregationStage** | `runAggregationStep` | 每 job 新建（内建 `new TextForwardMergeManager()`）。二者均为无状态 process，创建成本低 |

**审议结论**：当前实现简单、易测；若未来有「按 session 复用 AggregationStage/TextForwardMergeManager」的需求，可再评估复用带来的复杂度与收益，**当前未发现错误或明显多余开销**。

### 5.3 其他调用

- **aggregatorManager.processUtterance**：每个 job 在 `AggregationStage.process` 内调用 1 次。  
- **deduplicationHandler.isDuplicate** / **getLastSentText**：各 1 次，用于去重与 Gate 日志。  
- **forwardMergeManager.processText**：1 次，向前合并 + Gate。  
- **updateLastCommittedTextAfterRepair**：仅在语义修复成功且存在 `aggregatorManager` 时调用 1 次。

**审议结论**：未发现重复调用或错误调用。

---

## 六、总结与建议

| 项目 | 结论 |
|------|------|
| **Job 调度管理** | 单 job 单次 `runJobPipeline`，步骤顺序与条件执行清晰，无重复编排。 |
| **AudioAggregator** | 每 job 单次 `processAudioChunk`，解码→缓冲→finalize→切片→送 ASR 路径清晰，无重复送入 ASR。 |
| **Utterance 聚合** | ASR 结果 → getLastCommittedText（1 次）→ processUtterance（1 次）→ isDuplicate（1 次）→ processText（1 次）→ segmentForJobResult / shouldSendToSemanticRepair → 语义修复（1 次）→ updateLastCommittedTextAfterRepair（1 次）。无重复或错误调用。 |
| **NMT 上下文** | 语义修复结果 → repairedText → TranslationStage.process → getLastCommittedText（1 次，取「上一句已提交」）→ context_text 送入 NMT。与聚合阶段的 getLastCommittedText 用途不同且时机在 update 之后，合理。 |
| **getLastCommittedText 两次调用** | 一次为聚合（Trim/Gate），一次为 NMT 上下文；第二次前已更新，**均必要，非重复逻辑**。 |
| **每 job 新建 AggregationStage/TextForwardMergeManager** | 当前为无状态、低开销；可接受。若后续需要可审议「按 session 复用」方案。 |

**总体结论**：当前节点端 Job 调度、AudioAggregator、Utterance 聚合与 NMT 上下文的调用链清晰，**未发现重复调用或错误调用导致的不必要开销**。建议决策部门据此闭环；若后续有性能或复用需求，可针对「AggregationStage/TextForwardMergeManager 按 session 复用」单独审议。
