# 下一步排查清单：文本累积、重复处理、Job 乱序、音频丢失（2026-01）

**原则**：谨慎调整，不新增冗余流程；代码逻辑简单；项目未上线可不考虑兼容。

---

## 一、先用脚本拿到按 Job 的输入/输出

在 **electron_node** 目录下，用**本次集成测试**产生的 `electron-main.log` 跑：

```powershell
.\scripts\analyze_jobs_per_service_flow.ps1 -LogPath "electron_node\electron-node\logs\electron-main.log"
```

或（若已在 electron-node 下）：

```powershell
.\scripts\analyze_jobs_per_service_flow.ps1
```

脚本会按 **utterance_index** 列出每个 Job 的：

- [ASR] 输出、[聚合] segmentForJobResult / shouldSendToSemanticRepair  
- [语义修复] 是否执行、repairedText 预览  
- [NMT 输入] text、[NMT 输出] translatedTextPreview  
- [TTS] 是否有音频  

**重点看**：  
- 某 Job 的 **segmentForJobResult** 是否包含上一句或累积多句（文本累积）。  
- 同一 Job 是否出现**多次**语义修复/NMT/TTS 请求（重复处理）。  
- Job 顺序：同一 session 下 **job_assign** 与 **utterance_index** 是否一致、是否有先发 Job2 再发 Job1（乱序）。  
- 某 Job 的 NMT 输入有内容但 **translatedText** 为空或明显被截断（NMT 空/截断）。  
- 某 Job 有译文但 **[音频丢失]**（TTS 未调用或未回填）。

---

## 二、可能根因与对应代码点（供对照日志定位）

| 现象 | 可能根因 | 代码/位置 |
|------|----------|-----------|
| **文本累积**（本段含上句或多句） | 聚合「本段」划错；或 lastCommittedText/processedText 混入当前句 | `aggregation-stage.ts`：ForwardMerge 的 segmentForJobResult、aggregatedText；`aggregator-state` 的 getLastCommittedText / setLastSentText 时机 |
| **重复语义修复/NMT/TTS** | 同一 job 被 pipeline 执行多次；或 job_result 被发送多次 | `node-agent-simple.ts`：handleJob 内只应有一处 sendJobResult；`asr-step` 不应再调 sendJobResult；确认无「先发 ASR 再发完整结果」双出口 |
| **Job 乱序**（如 Job2 先于 Job1 完成） | 多 job 并发且无按 utterance_index 排序 | `sequential-executor`：NMT 已按 sessionId+utteranceIndex 排队；检查 job_assign 到达顺序与 pipeline 调度顺序是否一致；WebSocket 收 job 后是否按序入队 |
| **NMT 空译文** | 语言为 `auto` 未落成 zh/en；或 NMT 端 extract/context 导致空 | `translation-step.ts`：src_lang/tgt_lang 已落成具体语言（见 NMT_EMPTY_RETURN_CAUSE_AND_FIX）；`translation-stage.ts`：**已改为**节点端一律传 `context_text: undefined`，由 NMT 服务自行处理上下文 |
| **译文丢前半句** | 本段就缺前半（ASR/聚合）；或 NMT 长句/哨兵截断 | 先看脚本中该 Job 的 segmentForJobResult 与 NMT 输入是否已缺前半；若一致则修 ASR/聚合；若输入完整则查 NMT 服务 |
| **音频丢失** | TTS 未调用；或 tts_audio 未回填到 finalResult | `translation-step`：shouldSendToSemanticRepair=false 时 translatedText 置空会跳过 TTS；`result-builder`：text_asr/translatedText/tts_audio 来源是否一致；`node-agent-result-sender`：finalResult.tts_audio 是否被正确发送 |

---

## 三、已完成的架构约束（避免新乱）

- **单发送点**：job_result 仅由 `node-agent-simple.ts` 在 handleJob 结尾根据 `processResult.shouldSend` 调用 `sendJobResult`，asr-step 不再发送。  
- **语义修复失败即失败**：语义修复不可用/超时/异常均 throw，job 失败并回传调度，无 PASS 回退。  
- **各步骤只读上游产出**：语义修复只读 segmentForJobResult；去重/翻译/ResultBuilder 只读 repairedText；无 `|| ctx.xxx` 回退（见 JOB_CONTEXT_FIELDS_AND_FLOW_2026_01_29）。

---

## 四、建议排查顺序

1. 跑脚本，对异常 Job（如原文/译文缺前半、重复、乱序、音频丢失）记下 **job_id / utterance_index**。  
2. 在脚本输出的「按 Job 详情」里对照：ASR → 聚合 segmentForJobResult → 语义修复 repairedText → NMT 输入/输出 → TTS。  
3. 若 segmentForJobResult 已错误累积或截断 → 查 aggregation-stage / ForwardMerge / setLastSentText 时机。  
4. 若 NMT 输入正确但译文空或截断 → 查 NMT 服务（语言、context、长句）；节点端可尝试 context_text 传 undefined。  
5. 若同一 Job 在脚本里出现多次请求 → 查 handleJob/pipeline 是否被重复调用或双出口发送。

完成上述对照后，可将脚本报告或关键 Job 的日志片段贴出，便于进一步精确定位到文件和行号。
