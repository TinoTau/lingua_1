# 集成测试：Job 2 前半句丢失与多 Job 空结果 — 决策审议（2026-01）

**文档用途**：供决策部门审议当前集成测试暴露的问题、根因与可选方案。  
**测试会话**：s-CB072AAB  
**日志依据**：`electron_node/electron-node/logs/electron-main.log`，节点端分析见 `electron_node/electron-node/logs/docs/asr_performance/INTEGRATION_TEST_LOG_ANALYSIS_S_CB072AAB_2026_01.md`。

---

## 一、问题概述（当前现象）

| 现象 | 描述 |
|------|------|
| **界面仅显示 [0]、[2]** | 用户阅读长段稳定性测试文本后，返回结果中仅有两条有内容：[0]「我們開始建議一次語音識別穩定性測試」→ [2]「結束本次識別」，中间及后续内容在界面上不可见。 |
| **Job 2 前半句丢失** | 预期「…或者在没有必要的时候**提前**结束本次识别」整句，实际 Job 2 只识别出「結束本次識別」6 字，前半句「在没有必要的时候提前」未出现。 |
| **调度端显示「每个 job 不停重分配」** | 调度器终端侧观察到 job 被反复重分配；需与节点端日志对照以区分「调度无法分配」与「节点未在超时内回报」。 |

---

## 二、前因：测试场景与当前设计

### 2.1 测试场景

- **阅读文本**（节选）：  
  「现在我们开始进行一次语音识别稳定性测试。我会先读一两句比较短的话，用来确认系统不会在句子之间随意地把语音切断，或者**在没有必要的时候提前结束本次识别**。接下来这一句我会尽量连续地说得长一些…」
- **预期**：长句完整识别，不因超时/静音判定被截断，不出现前半句丢失或前后不连贯。
- **实际**：仅 [0]、[2] 有内容；[2] 仅后半句「結束本次識別」，前半句丢失。

### 2.2 当前设计（与问题相关的部分）

| 设计点 | 当前行为 | 与问题的关系 |
|--------|----------|--------------|
| **节点端 bufferKey** | 每个 job 使用 **job_id** 作为 bufferKey（与需求/改造文档一致）。同一 job 的音频写入同一 buffer；**不同 job 对应不同 buffer**。 | Job 1 的 buffer 存有 MaxDuration 后未送完的 4.8s 音频；Job 2 以**新 job_id** 到来时使用**新 bufferKey**，不会自动查到、合并 Job 1 的 buffer。 |
| **MaxDuration 触发** | 单段音频超过设定时长（如约 5s）时，调度端触发 MaxDuration finalize，产生一个 job；节点端对该 job 的音频做「前一段送 ASR + 剩余缓存为 pendingMaxDurationAudio」。 | Job 1 为 MaxDuration 触发，前 4.3s 送 ASR 得到 21 字，**剩余 4.8s 缓存在 Job 1 的 buffer**，等待「下一 job」合并。 |
| **下一 job 的 finalize 类型** | Job 2 为 **Manual 切分**（用户或 VAD 触发的句末），调度端下发新 job，带新 job_id 与约 1.5s 音频。 | 节点端用 Job 2 的 job_id 作 bufferKey，**Buffer not found**，新建 buffer，**未**去查找/合并「同一 session/turn 上一 job 的 pendingMaxDurationAudio」。 |
| **前向合并（AggregationStage）** | 若本段与下一段语义连续，可设 `shouldWaitForMerge=true`，本 job 先发**空结果**，文本在后续 job 一并带出。 | Job 1 因前向合并发空结果；其 4.8s pending 本应在「下一句」被合并进同一段话，但下一句（Job 2）是**新 buffer**，未包含该 4.8s。 |

### 2.3 因果链简述

1. **Job 1**：MaxDuration 触发，9.1s 音频 → 前 4.3s 送 ASR（21 字），**剩余 4.8s 留在 Job 1 的 buffer**；AggregationStage 设 `shouldWaitForMerge=true`，Job 1 向调度端**发空结果**。  
2. **Job 2**：Manual 切分，调度端只下发 **5996 bytes**（约 1.5s）到本 job；节点用 **Job 2 的 job_id** 作 bufferKey，**未合并 Job 1 的 4.8s**，仅将 1.3s 送 ASR → 只识别出「結束本次識別」。  
3. **结果**：Job 1 的 4.8s（对应「在没有必要的时候提前」等）既未在 Job 1 发出（空结果），也未进入 Job 2，**整段丢失**；界面仅看到 [0] 和 [2]，且 [2] 缺前半句。

---

## 三、基础测试 — 每个 Job 状态一览

以下为本次集成测试（Session s-CB072AAB）中，节点端实际处理状态（依据节点日志整理）。

| utteranceIndex | 是否收到 job_assign | 本 job 音频 (约) | ASR 识别结果（摘要） | Aggregation 动作 | 本 job 是否空结果 | 是否已发送 job_result (sendSeq) |
|----------------|--------------------|------------------|----------------------|------------------|--------------------|----------------------------------|
| **0** | ✅ | 14756 B opus, ~3.1s | 「我們開始建議一次語音識別穩定性測試」17 字 | NEW_STREAM, shouldWaitForMerge=false | 否 | ✅ sendSeq 1 |
| **1** | ✅ | 42140 B opus, ~9.1s | 「我會先度一、兩句比較短的話,用來確認性測試」21 字；**4.8s 缓存在本 buffer pending** | NEW_STREAM, **shouldWaitForMerge=true** | **是** | ✅ sendSeq 2 (isEmptyJob) |
| **2** | ✅ | **5996 B opus, ~1.3s** | **「結束本次識別」6 字**（未合并 Job 1 的 4.8s） | 本 job 带出 6 字 | 否 | ✅ sendSeq 3 |
| **3** | ✅ | （见日志） | （本 job 内无有效 ASR 或为空） | — | **是** | ✅ sendSeq 4 (isEmptyJob) |
| **4** | ✅ | （见日志） | — | — | **是** | ✅ sendSeq 5 (isEmptyJob) |
| **5** | ✅ | （见日志） | — | — | **是** | ✅ sendSeq 6 (isEmptyJob) |
| **6** | ✅ | （见日志） | — | — | **是** | ✅ sendSeq 7 (isEmptyJob) |
| **7** | ✅ | （见日志） | — | — | **是** | ✅ sendSeq 8 (isEmptyJob) |
| **8** | ✅ | （见日志） | — | — | **是** | ✅ sendSeq 9 (isEmptyJob) |
| **9** | ✅ | （见日志） | — | — | **是** | ✅ sendSeq 10 (isEmptyJob) |
| **10** | ✅ | （见日志） | — | — | **是** | ✅ sendSeq 11 (isEmptyJob) |
| **11** | ✅ | （见日志） | — | — | （日志内是否完成需查后续行） | — |
| **12** | ✅ | （见日志） | — | — | — | — |

**结论**：

- 调度器**能**把 job 分给节点（0–12 均收到 job_assign）。
- 节点**能**处理并回报：Job 0–10 均「Job processing completed successfully」且「Sending job_result to scheduler」。
- Job 1、3–10 的 job_result 均为 **isEmptyJob**（textAsr=""、textTranslated=""、ttsAudioLength=0）；若前端只展示「有内容的」结果，则界面仅显示 [0]、[2] 符合当前实现。
- **Job 2 前半句丢失**：根因在节点端未将 Job 1 的 pendingMaxDurationAudio（4.8s）合并进 Job 2。

---

## 四、后果与影响

| 维度 | 影响 |
|------|------|
| **用户体验** | 长句被拆成多段后，中间或后半句缺失、仅剩尾句几个字，语义不完整、阅读不连贯。 |
| **调度端观感** | 若出现「每个 job 不停重分配」，需区分是「调度无法分配」还是「节点已回报但超时/路由导致调度未收到」；本日志中节点已成功发送 0–10 的 job_result。 |
| **设计一致性** | 当前 bufferKey=jobId 与会议室需求一致；但「MaxDuration 产生的 pending 在下一 job（Manual/Timeout）合并」未在节点实现，导致跨 job 的同一句话被截断。 |

---

## 五、根因归纳（供决策参考）

1. **直接原因**  
   节点端在处理 Job 2（Manual finalize）时，使用**新 bufferKey（Job 2 的 job_id）**，未在**同一 session（及可选同一 turn）**下查找并合并**上一 job 的 pendingMaxDurationAudio**，导致 Job 1 缓存的 4.8s 永远未进入任何 ASR，前半句丢失。

2. **设计缺口**  
   - 要么：节点在「下一 job 为 Manual/Timeout finalize」时，按 **sessionId（+ 可选 turnId）** 查找上一 job 的 buffer，将其 pendingMaxDurationAudio 合并进本 job 再送 ASR；  
   - 要么：调度端/Web 在 MaxDuration 后、下一句切分时，把「未送完的剩余音频」**一并放入下一 job 的 payload**，节点无需跨 buffer 合并。  
   当前两点均未满足，故出现丢失。

3. **空结果与界面**  
   Job 1、3–10 为空结果，可能原因包括：前向合并扣留、RMS 拒绝、本段无有效识别等；需按 utterance_index 逐条分析。界面只显示 [0][2] 与前端「只展示非空结果」的规则一致，若需占位或顺序展示，需产品/前端约定。

---

## 六、待决策事项

| 序号 | 事项 | 选项摘要 |
|------|------|----------|
| **1** | **Job 2 前半句丢失（pending 未合并）** | **A**：节点端改造 — 下一 job（Manual/Timeout）时按 sessionId（+ 可选 turnId）查找并合并上一 job 的 pendingMaxDurationAudio；**B**：调度端/Web 改造 — 下一 job 携带「上一 MaxDuration 未送完的剩余音频」，节点仅处理本 job 负载；**C**：两者结合或其它方案（请注明）。 |
| **2** | **空结果 Job 的展示与协议** | 是否要求前端展示「空句占位」或顺序；是否在协议中显式区分「空结果」与「失败」，以便后续排查与产品策略。 |
| **3** | **「每个 job 不停重分配」的定位** | 本日志中节点已发送 0–10 的 job_result；若调度端仍重分配，需确认：result 路由、job_timeout_seconds、会话/实例一致性。建议决策是否纳入本次审议范围（仅记录现象 vs 一并排期排查）。 |

---

## 七、参考文档

- 节点端日志分析（本会话）：`electron_node/electron-node/logs/docs/asr_performance/INTEGRATION_TEST_LOG_ANALYSIS_S_CB072AAB_2026_01.md`
- 节点端 bufferKey 改造与可行性：`electron_node/docs/节点端_buffer_key_改造_可行性确认与待确认项.md`
- 集成测试 job 丢失与重分配排查：`docs/troubleshooting/集成测试_job丢失与重分配_排查指南_2026_01.md`
- 决策部门文档索引：`docs/decision/决策部门文档索引.md`

---

**文档版本**：V1.0  
**整理日期**：2026-01  
**状态**：待决策部门审议
