# 大量 260ms 独立 Job 是怎么产生的（2026-01）

**现象**：集成测试中同一段稳定长句被拆成大量极短 job（如 260ms PCM），在节点端被 RMS 质检拒绝，导致大段丢失。

**结论**：260ms 独立 job 来自 **「客户端按静音切 burst + 调度端按无-chunk 超时 finalize」** 的组合，不是单侧 bug。

---

## 一、产生链路（谁在什么时候干了什么）

### 1. 调度端：何时 finalize、buffer 里是什么

- **Finalize 触发**（`actor_event_handling.rs` / `actor_finalize.rs`）只有几类：
  - **MaxDuration**：`accumulated_audio_duration_ms >= max_duration_ms`（默认 10 秒）→ 按「累积时长」切，buffer 里是一整段长音频。
  - **Timeout**：**连续 `pause_ms`（默认 3000ms）没有收到任何音频 chunk** → 用当前 buffer 做一次 finalize。
  - **IsFinal**：客户端发来「结束」信号 → 用当前 buffer 做一次 finalize。

- **Buffer 内容**：每次 finalize 时 `take_combined(session_id, utterance_index)` 取的是 **本 utterance 自上次 finalize 以来累积的所有 chunk**。  
  因此：**一次 finalize = 一个 job 的音频 = 从「上一次 finalize」到「这次触发」之间客户端发来的全部数据**。

- **Timeout 会制造「短 job」**：若客户端在发了一小段音频（例如 260ms）后 **长时间不再发 chunk**（≥ pause_ms），调度端就会在 3 秒后因 Timeout 触发 finalize，此时 buffer 里只有这一小段 → **一个约 260ms 的独立 job**。

### 2. 客户端（Web）：为何会「发一小段就停」

- **静音过滤（VAD）**（`webapp/web-client/src/recorder.ts`）：
  - `releaseFrames=20`，`windowMs=100` → **连续 200ms 被判为静音就「停止发送」**（不再往调度端发 chunk）。
  - 效果：语音被切成一段段「有声 burst」，中间静音不发送。

- **静音超时（end-of-utterance）**（`recorder.ts` + `session_manager.ts`）：
  - `silenceTimeoutMs=3000` → 连续 3 秒静音才调用 `onSilenceDetected()` → 发剩余音频 + **sendFinal()**。
  - 即：**真正发 finalize 的是 3 秒静音**，而 **停止发 chunk 的是 200ms 静音**。

- **组合效果**：
  1. 用户说一小段（例如 260ms）→ 200ms 静音 → VAD 判定静音 → **不再发 chunk**。
  2. 调度端这边：只收到了这 260ms 的 chunk，之后 **连续 3 秒没新 chunk** → Timeout 触发 → finalize → **buffer 里只有这 260ms** → 产生 **一个 260ms 的 job**。
  3. 用户继续说下一小段 → 客户端再发 chunk → 调度端重置 timer；若 again「说一点 → 静音 200ms → 停发 → 3 秒无 chunk」→  again 一个短 job。

所以：**同一段稳定长句** 若中间有多次「短停顿（≥200ms）」，就会被拆成多个「burst」，每个 burst 在「3 秒无 chunk」时被调度端 Timeout 成 **一个独立 job**；当某个 burst 很短（如 260ms）时，就出现 **大量 260ms 独立 job**。

---

## 二、根因归纳

| 环节 | 行为 | 对 260ms job 的贡献 |
|------|------|---------------------|
| **客户端 VAD** | 连续 200ms 静音即停止发送 chunk | 把连续语音切成「burst」；短 burst = 短 buffer |
| **客户端 finalize** | 3 秒静音才 sendFinal() | 不会在 200ms 静音时立刻 finalize，中间依赖调度端 |
| **调度端 Timeout** | 连续 pause_ms（3 秒）无 chunk 即 finalize | 每个「停发 3 秒」的区间 = 一次 finalize = 一个 job，内容 = 该区间内收到的全部 chunk（可能只有 260ms）|

因此：**不应出现大量 260ms 独立 job** 的违背，来自 **「客户端过早停发（200ms 静音）+ 调度端按 3 秒无 chunk 收尾」** 的组合设计，而不是某一行代码的明显 bug。

---

## 三、修复方向（不降噪音阈值前提下）

### 1. 客户端：减少「短 burst」导致的短 job（推荐优先）

- **放宽「停止发送」条件**：  
  增大 `releaseFrames` 或 `windowMs`，使「连续静音多久才停发」变长（例如 400–600ms），这样自然呼吸、短停顿不会把一句拆成很多 200ms 级 burst，每个 burst 对应的 job 就不会那么短。
- **或**：在「停发」时 **立刻 sendFinal()**（即：停发 = 本句结束），让「一个 burst = 一个 job」语义明确，避免「停发后等 3 秒再由 Timeout 收尾」；再在调度/节点侧考虑对「极短 job」做合并或最小时长策略（见下）。

### 2. 调度端：避免用「极短 buffer」直接成 job

- **最小时长 / 最小字节数**：  
  在 `do_finalize` 里，若 `take_combined` 得到的音频时长（或字节数）小于阈值（例如 1 秒），可选择：
  - **不立即 finalize**：不创建 job，等更多 chunk 或等 IsFinal；或  
  - **合并到下一句**：本段不单独成 job，标记为「pending short」，下次 finalize 时与下一段一起成 job（需改状态与语义）。
- **或延长 Timeout 对短 buffer 的等待**：  
  当 buffer 时长很短（如 <1s）时，Timeout 不立即 finalize，而是再等一段时间看是否还有 chunk（实现复杂、易引入新边界问题，需谨慎）。

### 3. 节点端（已有结论）

- **不再降 MIN_RMS_THRESHOLD**。  
- 若仍存在少量「合理短句」被 RMS 拒绝，可单独评估：对「极短 + MaxDuration/Timeout 触发」的片段是否豁免 RMS 送 ASR（与产品权衡噪声与漏句）。

---

## 四、配置与代码位置速查

| 项目 | 默认/位置 | 说明 |
|------|-----------|------|
| 客户端 VAD 停发 | `releaseFrames=20`, `windowMs=100` → 200ms | `webapp/web-client/src/types.ts` DEFAULT_SILENCE_FILTER_CONFIG |
| 客户端静音 finalize | `silenceTimeoutMs=3000` | `webapp/web-client/src/types.ts` |
| 调度端 Timeout | `pause_ms=3000` | `central_server/scheduler` config_defaults.rs / config.toml |
| 调度端 MaxDuration | `max_duration_ms=10000` | 同上 |
| 调度 finalize 入口 | `actor_event_handling.rs` handle_audio_chunk / handle_timeout_fired；`actor_finalize.rs` do_finalize | Timeout → try_finalize("Timeout")；buffer = take_combined |

---

## 五、小结

- **260ms 独立 job**：来自「客户端 200ms 静音就停发 + 调度端 3 秒无 chunk 就 Timeout finalize」的组合；每次「停发且 3 秒内无新 chunk」的那段 buffer（可能只有 260ms）会变成单独一个 job。
- **不是**调度端单独「按 260ms 切分」的逻辑，也**不是**节点端创造 job；节点端只是对收到的短、低 RMS 片段做了拒绝。
- **修复重点**：在客户端放宽停发条件（或停发即 finalize + 上游短句策略），或在调度端对「过短 buffer」不做单独 job，二者至少做其一，才能从源头减少大量 260ms 独立 job。
