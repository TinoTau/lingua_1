# v2 方案开发前检查清单

## 评估结论

**v2 方案整体设计完善，但仍有以下遗漏和优化点需要在开发前明确：**

---

## 1. 关键遗漏点

### 1.1 ⚠️ 服务器端 API 格式未明确

**问题**：v2 方案中提到了 API 路径，但没有明确响应格式。

**需要明确**：
- `GET /api/models` 的响应格式（是否支持多版本嵌套结构？）
- `GET /api/models/{model_id}` 的响应格式
- 热门模型排名 API `GET /api/model-usage/ranking` 的响应格式

**建议补充**：
```json
// GET /api/models 响应格式
[
  {
    "id": "whisper-large-v3-zh",
    "name": "Whisper Large V3 中文增强版",
    "versions": [
      {
        "version": "1.0.0",
        "size_bytes": 1865432123,
        "files": [
          { "path": "model.onnx", "size_bytes": 123456789 },
          { "path": "tokenizer.json", "size_bytes": 456789 }
        ],
        "checksum_sha256": "abc123...",
        "updated_at": "2025-11-30T12:34:56Z"
      }
    ],
    "default_version": "1.0.0",
    "task": "asr",
    "languages": ["zh", "en"]
  }
]

// GET /api/model-usage/ranking 响应格式
[
  {
    "model_id": "marian-zh-en",
    "request_count": 1523,
    "rank": 1
  },
  {
    "model_id": "whisper-large-v3-zh",
    "request_count": 987,
    "rank": 2
  }
]
```

### 1.2 ⚠️ 文件下载接口实现细节缺失

**问题**：方案提到 `GET /storage/models/<model_id>/<version>/<file>`，但未明确：
- 是否需要认证？
- 如何处理文件不存在的情况？
- 是否支持目录遍历防护？

**建议补充**：
- 明确文件下载接口的完整路径规范
- 添加安全防护（防止路径遍历攻击）
- 明确错误响应格式

### 1.3 ⚠️ 锁机制实现细节不完整

**问题**：方案提到了任务锁和文件锁，但缺少：
- 锁的超时机制（防止死锁）
- 锁的清理策略（何时清理孤儿锁）
- 锁文件的内容格式（是否需要记录进程ID、时间戳等）

**建议补充**：
```typescript
// 锁文件格式建议
interface LockFile {
  pid: number;           // 进程ID
  timestamp: number;     // 创建时间
  modelId: string;       // 模型ID
  version: string;       // 版本
  timeout: number;       // 超时时间（毫秒）
}

// 锁超时策略
- 任务锁超时：30分钟（大模型下载可能需要较长时间）
- 文件锁超时：5分钟（单文件下载不应过长）
- 启动时清理：超过1小时的锁文件自动清理
```

### 1.4 ⚠️ 错误处理策略不完整

**问题**：方案提到客户端不兜底，但未明确：
- `getModelPath()` 抛出异常还是返回 null？
- 如何区分"模型不存在"和"模型下载中"？
- 错误如何传递给调度服务器？

**建议补充**：
```typescript
// 错误类型定义
class ModelNotAvailableError extends Error {
  constructor(
    public modelId: string,
    public version: string,
    public reason: 'not_installed' | 'downloading' | 'verifying' | 'error'
  ) {
    super(`Model ${modelId}@${version} is not available: ${reason}`);
  }
}

// getModelPath 实现
async getModelPath(modelId: string, version?: string): Promise<string> {
  const model = this.getInstalledModel(modelId, version);
  
  if (!model) {
    throw new ModelNotAvailableError(modelId, version || 'latest', 'not_installed');
  }
  
  if (model.status !== 'ready') {
    throw new ModelNotAvailableError(modelId, version || 'latest', model.status);
  }
  
  return model.path;
}
```

### 1.5 ⚠️ 多文件下载的并发控制缺失

**问题**：方案提到支持多文件下载，但未明确：
- 多个文件是串行还是并行下载？
- 如何控制并发下载数量？
- 部分文件下载失败如何处理？

**建议补充**：
- 并行下载策略：最多同时下载 3 个文件
- 失败重试：单个文件失败重试 3 次
- 部分失败处理：已下载的文件保留，失败的文件标记为错误状态

### 1.6 ⚠️ registry.json 原子写入机制缺失

**问题**：方案提到"原子写入"，但未明确实现方式。

**建议补充**：
```typescript
// 原子写入实现
async saveRegistry(registry: Registry): Promise<void> {
  const registryPath = path.join(this.modelsDir, 'registry.json');
  const tempPath = registryPath + '.tmp';
  
  // 写入临时文件
  await fs.writeFile(tempPath, JSON.stringify(registry, null, 2));
  
  // 原子替换
  await fs.rename(tempPath, registryPath);
}
```

---

## 2. 可优化点

### 2.1 性能优化

#### 2.1.1 下载速度优化
- **建议**：实现下载限速（避免占用过多带宽）
- **建议**：支持多线程下载（大文件分片下载）

#### 2.1.2 内存优化
- **问题**：当前实现使用 `arraybuffer`，大文件会占用大量内存
- **建议**：使用流式下载（`responseType: 'stream'`）

#### 2.1.3 缓存优化
- **建议**：实现 `manifest_cache.json` 的 TTL 机制（避免频繁请求服务器）
- **建议**：支持增量更新（只下载变更的模型）

### 2.2 用户体验优化

#### 2.2.1 下载队列管理
- **建议**：支持下载队列（用户可以选择下载优先级）
- **建议**：支持暂停/恢复下载

#### 2.2.2 进度显示优化
- **建议**：显示下载速度（MB/s）
- **建议**：显示预计剩余时间
- **建议**：支持多模型下载的总进度

#### 2.2.3 错误提示优化
- **建议**：提供更详细的错误信息（网络错误、磁盘空间不足等）
- **建议**：提供一键重试功能

### 2.3 安全性优化

#### 2.3.1 文件校验增强
- **建议**：除了 SHA256，还支持文件大小校验
- **建议**：支持部分文件校验（大文件分块校验）

#### 2.3.2 路径安全
- **建议**：防止路径遍历攻击（`../` 等）
- **建议**：验证文件路径在允许的目录内

### 2.4 可维护性优化

#### 2.4.1 代码结构
- **建议**：将下载、校验、安装逻辑分离为独立模块
- **建议**：使用状态机模式管理下载状态

#### 2.4.2 日志和调试
- **建议**：添加详细的调试日志（开发环境）
- **建议**：支持导出下载日志（用于问题排查）

---

## 3. 与现有系统的集成点

### 3.1 与调度服务器的集成

**需要明确**：
- 客户端如何上报 `MODEL_NOT_AVAILABLE` 错误？
- 是否需要新的消息类型？
- 调度服务器如何处理这种错误？

**建议**：
```typescript
// 在 node-agent.ts 中
async handleJob(job: JobAssignMessage): Promise<void> {
  try {
    const modelPath = await this.modelManager.getModelPath(
      job.required_model_id,
      job.required_model_version
    );
    // ... 处理任务
  } catch (error) {
    if (error instanceof ModelNotAvailableError) {
      // 发送错误消息给调度服务器
      this.sendModelNotAvailableError(job, error);
      return;
    }
    // ... 其他错误处理
  }
}
```

### 3.2 与推理服务的集成

**需要明确**：
- 推理服务如何获取模型路径？
- 模型路径变更时如何通知推理服务？

**建议**：
- 推理服务通过 `ModelManager.getModelPath()` 获取路径
- 模型安装完成后，通过事件通知推理服务重新加载

---

## 4. 测试相关补充

### 4.1 单元测试覆盖

**建议补充**：
- 锁机制的单元测试
- 断点续传的单元测试
- 多文件下载的单元测试
- registry.json 原子写入的单元测试

### 4.2 集成测试场景

**建议补充**：
- 网络中断恢复测试（多次中断）
- 磁盘空间不足测试
- 并发下载多个大模型测试
- 服务器响应慢的测试

### 4.3 压力测试

**建议补充**：
- 同时下载 10 个模型的压力测试
- 频繁启动/停止下载的测试
- 长时间运行的稳定性测试

---

## 5. 开发优先级建议

### 高优先级（必须实现）
1. ✅ 明确 API 响应格式
2. ✅ 实现文件下载接口（支持 Range）
3. ✅ 实现任务锁和文件锁机制
4. ✅ 实现多文件下载支持
5. ✅ 实现断点续传
6. ✅ 实现 registry.json 原子写入
7. ✅ 实现错误处理和 MODEL_NOT_AVAILABLE 上报

### 中优先级（重要功能）
8. ⚠️ 实现下载进度事件推送
9. ⚠️ 实现热门模型排名 UI
10. ⚠️ 实现锁超时和清理机制
11. ⚠️ 实现流式下载（内存优化）

### 低优先级（优化功能）
12. ⏸️ 实现下载队列管理
13. ⏸️ 实现下载限速
14. ⏸️ 实现 manifest_cache.json TTL
15. ⏸️ 实现多线程下载

---

## 6. 风险点提醒

### 6.1 技术风险
- **锁机制死锁**：需要仔细设计超时和清理策略
- **大文件内存占用**：必须使用流式下载
- **并发下载冲突**：需要完善的锁机制

### 6.2 业务风险
- **模型版本管理**：需要明确版本选择策略（default_version vs 指定版本）
- **错误恢复**：需要完善的错误恢复机制
- **用户体验**：下载大模型时需要有良好的进度反馈

---

## 7. 总结

v2 方案整体设计完善，但需要在开发前明确：

1. **API 格式规范**：明确所有 API 的请求/响应格式
2. **锁机制细节**：超时、清理、格式等
3. **错误处理策略**：错误类型、传递方式等
4. **集成点**：与调度服务器、推理服务的集成方式

建议在开发前先完成 API 接口文档和详细设计文档，确保所有细节都明确后再开始编码。

