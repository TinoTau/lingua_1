# 近音字表设计（口音导致的 ASR 错误纠错）

### ——与方言/口音相关的后处理设计，具体实现方案待定

**版本：v0.1（设计阶段）**  
**位置：`docs/train`，与方言模型训练文档并列**

---

## 1. 目标与范围

### 1.1 要解决的问题

- 部分用户说中文**带口音**，ASR 会识别出错误字组合（如「圈人」代替「确认」、「超市」代替「超时」）。
- 典型口音类型：
  - **前后鼻音不分**：如 -n / -ng（因/英、陈/程、民/明、信/性 等）。
  - **n / l 不分**：如 南/兰、年/连、农/龙、女/旅 等。
- 目标：通过**近音字表**（可替换字组）在**同音纠错**阶段生成候选，由 LM 选优，从而在不改 ASR 模型的前提下减轻口音带来的识别错误。

### 1.2 不做的事（与本设计无关）

- **不做方言词汇对照表**：不是「方言词 → 普通话词」的整词映射。
- **不做方言 ASR/TTS 模型训练**：本设计仅针对**后处理层**的近音字表扩充，与方言语料采集、模型训练文档（如吴语语料设计）互补。

---

## 2. 与现有同音纠错的关系

### 2.1 现有机制简述

- 节点端流水线：**ASR → 聚合 → 同音纠错 → 语义修复 → NMT → TTS**。
- 同音纠错服务（`phonetic_correction_zh`）使用：
  - **混淆集**：多组「同音字组」（如 识/试/式/市、句/具/据/距），每组内字符可互相替换。
  - **候选生成**：在句子中取若干「可替换位点」（字属于某组），用同组其它字替换，得到多个候选句。
  - **LM 选优**：KenLM 对候选打分，仅当最佳候选比原文高出一定阈值时才输出最佳，否则保留原文。

### 2.2 近音字表的定位

- **近音字表** = 在现有「同音字组」基础上，**扩充近音字组**（前后鼻音、n/l 等）。
- 实现方式与现有同音字组一致：**按字分组**，不引入词级或句级映射；同一组内的字仍作为候选互相替换，由 LM 决定是否采纳。
- 与「方言词汇对照表」区别：只做**字级**可替换集合，不做「错误词 → 正确词」的整词表。

---

## 3. 对翻译效率的影响（设计约束）

### 3.1 成本来源

- 同音纠错的主要成本 = **候选句数量 × 单次 LM 打分**。
- 当前实现已有上界：
  - `max_positions`：每句最多取若干可替换位点（如 2）。
  - `max_candidates`：每句最多生成若干候选（如 24），含原文。

### 3.2 扩充近音字表后的影响

- **字组变大 / 组数变多**：可替换位点可能增多，候选数更容易顶到上限。
- **单句耗时**：每句最多固定次 LM 调用（由 `max_candidates` 决定），因此同音纠错步骤的**最坏耗时是有上界的**。
- **整体链路**：同音纠错在 NMT 之前，且通常不是主瓶颈；扩充近音字表后，该步骤平均耗时可能略有上升（数十到百毫秒量级），对端到端「翻译效率」的影响在**几个到十来个百分点**量级，且可通过 `max_positions` / `max_candidates` 调参平衡。

### 3.3 设计原则

- 近音字表扩充**不取消**现有上界；若后续实现需要更强纠错能力，可考虑可配置的 `max_positions` / `max_candidates`，在质量与延迟之间做权衡。

---

## 4. 后续实现方向（待定）

以下为预留方向，**不在此文档中规定具体实现**，后续单独设计实现方案：

1. **字表来源与维护**
   - 前后鼻音、n/l 等近音字组：按拼音/音素整理，手写或半自动生成。
   - 是否支持「从 ASR 错误–正确句对中挖掘近音对」作为字表补充。

2. **与现有混淆集的集成方式**
   - 与 `phonetic_correction_zh` 现有 `SAME_PINYIN_GROUPS` 合并维护，或单独「近音字组」文件再加载。

3. **按口音/方言的可选策略**
   - 是否按用户/会话配置「口音类型」或「方言区域」，加载不同近音字子集（如仅 n/l、仅前后鼻音等），以控制候选规模与延迟。

4. **评估与迭代**
   - 如何评估近音字表对 WER/纠错率/用户满意度的影响；如何收集口音相关错误样本以迭代字表。

---

## 5. 语义修复与近音字表的协同（设计方向）

### 5.1 问题

能否让**语义修复服务**根据近音字表（或同音纠错产生的候选）进行优化，**选择最可能符合用户原意的文本组合**？

### 5.2 当前分工

- **同音纠错**：用混淆集生成字级候选句，由 **KenLM** 打分选优，输出一条「纠错后」文本给下游。
- **语义修复**：接收同音纠错后的单条文本，由 **LLM** 做语义连贯/改写/纠错，输出一条「修复后」文本。

二者目前是串行、单候选传递：同音纠错只把「最优一条」交给语义修复，语义修复看不到其它候选。

### 5.3 协同方向（可选优化，实现待定）

在**不改变现有单候选链路**的前提下，可预留以下方向，供后续实现方案设计：

1. **多候选传入语义修复**
   - 同音纠错除输出「LM 最优」外，可选地输出 **Top‑k 条候选**（如 2～5 条）。
   - 语义修复接收「原文 + 多条候选」，由 LLM 做**歧义消解**：在给定上下文下，选择或改写为「最符合用户原意」的一条（或在此基础上再做语义改写）。
   - 好处：LLM 可利用上下文和常识在「圈人/确认」「超市/超时」等近音组合中选更合理的一种；坏处：多一次（或多次）LLM 调用或更长 prompt，延迟与成本需评估。

2. **语义修复侧显式使用近音字表**
   - 语义修复服务在改写前，可选地根据**近音字表**对句中「可替换位点」生成若干候选解释，再交给 LLM 做「选最佳解释 + 连贯改写」。
   - 与 1 的区别：候选生成在语义修复内部、且可复用同一套近音字表，与同音纠错是否传多候选解耦；实现上需在语义修复服务内接入近音字表或候选生成逻辑，具体接口与数据格式待定。

3. **联合排序**
   - 同音纠错输出多候选，语义修复对每条候选做「语义合理性」打分或排序，再选最优一条进入 NMT。
   - 对延迟与成本影响最大，适合作为可选策略（如仅对低置信度句开启）。

### 5.4 设计原则

- **不强制**：现有「同音纠错单条 → 语义修复单条」链路保留；上述协同为**可选增强**，可在实现方案中按场景开关（如按会话、按口音类型开启）。
- **效率可控**：多候选/多解释会带来额外 LLM 调用或更长 prompt，需在实现方案中给出上界与降级策略（如最多 3 候选、超时则退回单候选）。

---

## 6. 相关文档

- 方言语料与训练：`docs/train/WU_DIALECT_CORPUS_DESIGN_GUIDE_SHANGHAINESE.md`、`docs/train/HOME_PC_CLUSTER_ASR_TRAINING_FEASIBILITY.md`。
- 同音纠错实现（当前）：`electron_node/services/phonetic_correction_zh/`（混淆集 `core/confusion_set.py`，LM 打分 `core/rescore.py`）。
- 语义修复实现（当前）：`electron_node/services/semantic_repair_en_zh/`（中文 `processors/zh_repair_processor.py` 等）。
