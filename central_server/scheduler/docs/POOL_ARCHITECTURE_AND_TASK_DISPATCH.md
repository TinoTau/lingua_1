# Pool 架构与任务调度设计文档

## 文档信息

- **版本**: v3.0
- **日期**: 2026-01-07
- **目的**: 说明 Pool 架构设计、任务分配流程，以及一个节点属于多个 Pool 的影响分析
- **状态**: 已实现
- **目标读者**: 决策部门、架构评审委员会

---

## 一、执行摘要

### 1.1 核心设计决策

**当前实现**：一个节点可以同时属于多个 Pool（支持多个语言对）。

**设计原因**：
- 节点通常支持多个语言对（如 `zh-en` 和 `en-zh`）
- 如果节点只属于一个 Pool，会导致其他 Pool 为空，浪费资源
- 节点具备处理多个语言对任务的能力，应该充分利用

**影响**：
- ✅ **优点**：充分利用节点能力，避免空 Pool，提高资源利用率
- ⚠️ **风险**：同一个节点可能同时处理多个不同语言的翻译任务
- ✅ **控制措施**：通过 `max_concurrent_jobs` 和资源阈值限制节点并发任务数

### 1.2 风险与缓解措施

| 风险 | 影响 | 缓解措施 | 状态 |
|------|------|----------|------|
| 节点负载过高 | 任务处理延迟 | `max_concurrent_jobs` 限制（默认 4） | ✅ 已实现 |
| 资源竞争 | GPU/CPU 资源不足 | 资源阈值检查（CPU/GPU/内存） | ✅ 已实现 |
| 任务调度冲突 | 多个语言对任务同时到达 | 负载均衡算法（选择负载最低的节点） | ✅ 已实现 |
| 模型切换开销 | 不同语言对需要不同模型 | 模型预加载和缓存机制 | ✅ 节点端处理 |

---

## 二、调度服务器架构

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                    调度服务器 (Scheduler)                     │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌──────────────────────────────────────────────────────┐  │
│  │          Phase 3: Pool 管理模块                       │  │
│  │  - Pool 生成（精确池 + 混合池）                        │  │
│  │  - 节点分配到 Pool（支持多 Pool）                      │  │
│  │  - Pool 索引维护                                       │  │
│  └──────────────────────────────────────────────────────┘  │
│                          │                                   │
│                          ▼                                   │
│  ┌──────────────────────────────────────────────────────┐  │
│  │          Phase 3: 任务调度模块                        │  │
│  │  - Pool 选择（根据语言对）                            │  │
│  │  - 节点选择（负载均衡）                                │  │
│  │  - 资源检查（CPU/GPU/内存）                           │  │
│  └──────────────────────────────────────────────────────┘  │
│                          │                                   │
│                          ▼                                   │
│  ┌──────────────────────────────────────────────────────┐  │
│  │          节点注册与心跳模块                            │  │
│  │  - 节点注册（语言能力检测）                            │  │
│  │  - 心跳更新（语言能力变化检测）                        │  │
│  │  - 状态管理（Registering → Ready）                    │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                               │
└─────────────────────────────────────────────────────────────┘
                          │
                          │ WebSocket
                          ▼
┌─────────────────────────────────────────────────────────────┐
│                      节点 (Node)                             │
│  - ASR 服务（语音识别）                                      │
│  - NMT 服务（机器翻译）                                      │
│  - TTS 服务（语音合成）                                      │
│  - 语义修复服务（关键：决定语言可用性）                       │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 核心数据结构

#### 2.2.1 Pool 配置

```rust
pub struct Phase3PoolConfig {
    pub pool_id: u16,
    pub name: String,              // "zh-en" 或 "*-en"
    pub required_services: Vec<String>,
    pub language_requirements: Option<PoolLanguageRequirements>,
}
```

#### 2.2.2 节点到 Pool 的映射

```rust
// 一个节点可以属于多个 Pool
phase3_node_pool: HashMap<String, HashSet<u16>>  // node_id -> pool_ids

// Pool 到节点的映射（用于快速查找）
phase3_pool_index: HashMap<u16, HashSet<String>>  // pool_id -> node_ids
```

#### 2.2.3 节点状态

```rust
pub struct Node {
    pub node_id: String,
    pub status: NodeStatus,        // Registering → Ready
    pub online: bool,
    pub current_jobs: usize,       // 当前正在处理的任务数
    pub max_concurrent_jobs: usize, // 最大并发任务数（默认 4）
    pub cpu_usage: f32,
    pub gpu_usage: Option<f32>,
    pub memory_usage: f32,
    pub language_capabilities: Option<NodeLanguageCapabilities>,
    // ...
}
```

---

## 三、Pool 设计

### 3.1 Pool 类型

#### 3.1.1 精确池（一对一语言对 Pool）

**命名格式**：`{src_lang}-{tgt_lang}`（如 `zh-en`、`en-zh`）

**用途**：用于已知源语言和目标语言的场景（面对面模式）

**节点匹配条件**：
1. 语义修复服务支持源语言和目标语言（**必需**）
2. ASR 服务支持源语言
3. TTS 服务支持目标语言
4. NMT 服务支持该语言对

**示例**：
- Pool `zh-en`：中文到英文翻译
- Pool `en-zh`：英文到中文翻译

#### 3.1.2 混合池（多对一 Pool）

**命名格式**：`*-{tgt_lang}`（如 `*-en`、`*-zh`）

**用途**：用于 `src_lang = "auto"` 场景，支持 ASR 多语言自动识别

**节点匹配条件**：
1. 语义修复服务支持目标语言（**必需**）
2. TTS 服务支持目标语言
3. NMT 服务支持任意源语言到目标语言
4. 至少有一个源语言在语义修复服务支持的语言列表中

**示例**：
- Pool `*-en`：任意语言到英文翻译（支持自动识别源语言）
- Pool `*-zh`：任意语言到中文翻译（支持自动识别源语言）

### 3.2 Pool 生成逻辑

#### 3.2.1 精确池生成

1. **收集语言对**：遍历所有节点，收集每个节点支持的语言对
   - 节点端计算：基于语义修复服务的语言能力
   - 只统计源语言和目标语言都在语义修复服务支持列表中的语言对

2. **统计节点数**：统计每个语言对的节点数

3. **过滤**：只保留节点数 >= `min_nodes_per_pool` 的语言对（默认 1）

4. **排序**：按节点数降序排序，优先创建节点数多的 Pool

5. **限制数量**：最多创建 `max_pools` 个精确池（默认 50 个）

6. **生成配置**：为每个语言对创建 Pool 配置

#### 3.2.2 混合池生成

1. **收集目标语言**：遍历所有节点，收集每个目标语言的节点

2. **统计节点数**：统计每个目标语言的节点数

3. **过滤**：只保留节点数 >= `min_nodes_per_pool` 的目标语言

4. **生成配置**：为每个目标语言创建混合池配置（**无数量限制**）

### 3.3 节点分配到 Pool

#### 3.3.1 分配逻辑

**关键设计**：一个节点可以同时属于多个 Pool。

**分配流程**：

1. **节点注册时**：
   - 检测节点的语言能力（基于语义修复服务）
   - 计算节点支持的语言对列表
   - 为每个匹配的语言对创建 Pool（如果不存在）
   - 将节点分配到所有匹配的 Pool

2. **心跳更新时**：
   - 检测语言能力变化（语义修复服务启动/停止）
   - 重新计算语言对列表
   - 更新节点到 Pool 的分配（添加新 Pool，移除不再匹配的 Pool）

**示例场景**：

```
节点支持的语言对：zh-en, en-zh
语义修复服务支持：zh, en

分配结果：
- 节点分配到 Pool 1 (zh-en)
- 节点分配到 Pool 2 (en-zh)
```

#### 3.3.2 动态 Pool 创建

当节点通过心跳更新语言能力时，如果节点支持的语言对不在现有 Pool 中，系统会动态创建新的 Pool。

**流程**：
1. 节点心跳更新语言能力
2. 尝试匹配现有 Pool
3. 如果未匹配到任何 Pool，检查语言对是否在现有 Pool 中
4. 如果不在，动态创建新的精确池
5. 将节点添加到新创建的 Pool

---

## 四、任务分配流程

### 4.1 任务分配整体流程

```
任务到达（src_lang, tgt_lang）
    │
    ▼
选择 Pool（精确池或混合池）
    │
    ▼
从 Pool 中选择节点（负载均衡）
    │
    ▼
检查节点资源（CPU/GPU/内存/并发数）
    │
    ▼
分配任务到节点
```

### 4.2 Pool 选择逻辑

#### 4.2.1 精确池选择

**条件**：`src_lang != "auto"`

**逻辑**：
```rust
// 选择精确匹配的语言对 Pool
let pool_name = format!("{}-{}", src_lang, tgt_lang);
let eligible_pools = pools.filter(|p| p.name == pool_name);
```

**示例**：
- 任务：`src_lang = "zh"`, `tgt_lang = "en"`
- 选择：Pool `zh-en`

#### 4.2.2 混合池选择

**条件**：`src_lang == "auto"`

**逻辑**：
```rust
// 选择所有以 *-tgt_lang 格式命名的混合池
let pool_name = format!("*-{}", tgt_lang);
let eligible_pools = pools.filter(|p| p.name == pool_name);
```

**示例**：
- 任务：`src_lang = "auto"`, `tgt_lang = "en"`
- 选择：Pool `*-en`

### 4.3 节点选择逻辑

#### 4.3.1 两级调度（Two-level）

**第一级：Pool 选择**
- 根据 `routing_key`（通常是 `session_id`）使用 hash 选择 preferred pool
- 如果 preferred pool 没有可用节点，按配置 fallback 到其他 pool

**第二级：节点选择**
- 在选定的 Pool 内，选择负载最低的节点
- 负载计算：`effective_jobs = max(current_jobs, reserved_jobs)`

#### 4.3.2 节点过滤条件

节点必须满足以下所有条件才能被选中：

1. **状态检查**：
   - `online == true`
   - `status == Ready`

2. **服务能力检查**：
   - 具备任务所需的所有服务类型（ASR、NMT、TTS 等）
   - 服务状态为 `ready`

3. **语言能力检查**：
   - 语义修复服务支持源语言和目标语言（**必需**）
   - ASR 支持源语言
   - TTS 支持目标语言
   - NMT 支持该语言对

4. **资源检查**：
   - `effective_jobs < max_concurrent_jobs`（默认 4）
   - CPU 使用率 < 阈值
   - GPU 使用率 < 阈值（如果使用 GPU）
   - 内存使用率 < 阈值

5. **其他检查**：
   - 不在排除列表中
   - 接受公共任务（如果任务为公共任务）

#### 4.3.3 负载均衡算法

**目标**：选择负载最低的节点

**算法**：
```rust
// 计算每个节点的有效负载
let effective_jobs = max(node.current_jobs, reserved_jobs);

// 选择 effective_jobs 最小的节点
let best_node = nodes.min_by_key(|n| effective_jobs(n));
```

**优势**：
- 自动负载均衡：负载低的节点优先被选中
- 避免热点：多个语言对任务会分散到不同节点
- 资源利用：充分利用所有可用节点

---

## 五、一个节点属于多个 Pool 的影响分析

### 5.1 场景描述

**示例**：
- 节点 A 支持语言对：`zh-en`、`en-zh`
- 节点 A 被分配到：Pool 1 (`zh-en`)、Pool 2 (`en-zh`)

**可能的情况**：
- 任务 1（`zh-en`）从 Pool 1 分配到节点 A
- 任务 2（`en-zh`）从 Pool 2 分配到节点 A
- 节点 A 同时处理两个不同语言对的翻译任务

### 5.2 影响分析

#### 5.2.1 正面影响

1. **资源利用率提高**
   - 节点能力得到充分利用
   - 避免空 Pool，减少资源浪费

2. **任务处理能力增强**
   - 节点可以处理所有支持的语言对任务
   - 提高系统整体吞吐量

3. **Pool 管理简化**
   - 不需要为每个语言对单独维护 Pool
   - 减少 Pool 数量，降低管理复杂度

#### 5.2.2 潜在风险

1. **节点负载增加**
   - **风险**：一个节点可能同时处理多个不同语言对的任务
   - **影响**：节点负载可能较高
   - **缓解措施**：
     - `max_concurrent_jobs` 限制（默认 4）
     - 负载均衡算法确保任务分散到多个节点
     - 资源阈值检查防止过载

2. **资源竞争**
   - **风险**：多个任务可能竞争 GPU/CPU 资源
   - **影响**：单个任务的处理时间可能增加
   - **缓解措施**：
     - GPU/CPU 使用率阈值检查
     - 内存使用率检查
     - 任务优先级机制（如果实现）

3. **模型切换开销**
   - **风险**：不同语言对可能需要不同的模型
   - **影响**：模型加载和切换可能增加延迟
   - **缓解措施**：
     - 模型预加载和缓存（节点端处理）
     - 模型常驻内存（如果资源允许）

4. **任务调度冲突**
   - **风险**：多个语言对任务同时到达，可能都选择同一个节点
   - **影响**：节点可能成为热点
   - **缓解措施**：
     - 负载均衡算法（选择负载最低的节点）
     - `routing_key` hash 分散任务到不同节点
     - Fallback 机制（如果 preferred pool 无可用节点）

### 5.3 控制措施

#### 5.3.1 并发任务数限制

```rust
pub struct Node {
    pub current_jobs: usize,        // 当前正在处理的任务数
    pub max_concurrent_jobs: usize, // 最大并发任务数（默认 4）
    // ...
}

// 节点选择时检查
if effective_jobs >= node.max_concurrent_jobs {
    // 节点已满，跳过
    continue;
}
```

**效果**：
- 限制节点同时处理的任务数
- 防止节点过载
- 确保任务处理质量

#### 5.3.2 资源阈值检查

```rust
pub struct ResourceThreshold {
    pub cpu_percent: f32,      // 默认：90%
    pub gpu_percent: f32,      // 默认：90%
    pub memory_percent: f32,   // 默认：90%
}

// 节点选择时检查
if !is_node_resource_available(node, threshold) {
    // 资源不足，跳过
    continue;
}
```

**效果**：
- 防止节点资源耗尽
- 确保任务有足够的资源处理
- 保护节点稳定性

#### 5.3.3 负载均衡算法

```rust
// 选择负载最低的节点
let best_node = nodes.min_by_key(|n| {
    let effective_jobs = max(n.current_jobs, reserved_jobs);
    effective_jobs
});
```

**效果**：
- 自动分散任务到多个节点
- 避免单个节点成为热点
- 提高系统整体性能

#### 5.3.4 任务路由分散

```rust
// 使用 routing_key (session_id) hash 选择 preferred pool
let preferred_pool = hash(routing_key) % pool_count;
```

**效果**：
- 不同会话的任务分散到不同 Pool
- 进一步分散任务到不同节点
- 减少任务冲突

### 5.4 实际运行情况

#### 5.4.1 典型场景

**场景 1：单节点多 Pool**
- 节点 A 支持：`zh-en`、`en-zh`
- 节点 A 被分配到：Pool 1 (`zh-en`)、Pool 2 (`en-zh`)
- 任务分配：
  - 任务 1（`zh-en`）→ Pool 1 → 节点 A（如果负载最低）
  - 任务 2（`en-zh`）→ Pool 2 → 节点 A（如果负载最低）
  - 节点 A 同时处理 2 个任务（在 `max_concurrent_jobs` 限制内）

**场景 2：多节点多 Pool**
- 节点 A 支持：`zh-en`、`en-zh`
- 节点 B 支持：`zh-en`、`en-zh`
- 两个节点都被分配到：Pool 1 (`zh-en`)、Pool 2 (`en-zh`)
- 任务分配：
  - 任务 1（`zh-en`）→ Pool 1 → 选择负载最低的节点（A 或 B）
  - 任务 2（`en-zh`）→ Pool 2 → 选择负载最低的节点（A 或 B）
  - 负载均衡确保任务分散到两个节点

#### 5.4.2 负载分布

**理想情况**：
- 多个节点支持相同的语言对
- 任务通过负载均衡分散到多个节点
- 每个节点的负载相对均衡

**实际情况**：
- 如果只有一个节点支持某个语言对，该节点会处理所有该语言对的任务
- 但受 `max_concurrent_jobs` 限制，不会无限增加
- 如果节点过载，新任务会等待或失败（取决于配置）

---

## 六、架构优势与权衡

### 6.1 架构优势

1. **资源利用率最大化**
   - 节点能力得到充分利用
   - 避免空 Pool，减少资源浪费
   - 提高系统整体吞吐量

2. **灵活性和可扩展性**
   - 支持动态添加新语言对
   - 支持节点能力变化（热插拔服务）
   - 支持多语言场景

3. **负载均衡**
   - 自动分散任务到多个节点
   - 避免单个节点过载
   - 提高系统稳定性

4. **语义修复服务优先**
   - 确保语音识别质量
   - 只分配有语义修复服务的节点
   - 提高用户体验

### 6.2 架构权衡

| 方面 | 优势 | 权衡 |
|------|------|------|
| **资源利用** | 充分利用节点能力 | 节点可能处理多个语言对任务 |
| **Pool 管理** | 减少空 Pool | 节点可能属于多个 Pool |
| **任务调度** | 负载均衡 | 需要更复杂的调度逻辑 |
| **性能** | 提高吞吐量 | 可能增加单个任务延迟（如果节点负载高） |

### 6.3 与其他方案的对比

#### 方案 A：一个节点只属于一个 Pool（旧方案）

**优点**：
- 简单明了
- 节点负载可预测

**缺点**：
- 产生大量空 Pool
- 资源利用率低
- 节点能力浪费

#### 方案 B：一个节点属于多个 Pool（当前方案）

**优点**：
- 资源利用率高
- 避免空 Pool
- 充分利用节点能力

**缺点**：
- 节点可能处理多个语言对任务
- 需要更复杂的调度逻辑

**结论**：方案 B 更优，因为：
1. 资源利用率显著提高
2. 风险可控（通过并发限制和资源检查）
3. 负载均衡确保任务分散

---

## 七、监控与运维

### 7.1 关键指标

1. **Pool 指标**：
   - 每个 Pool 的节点数
   - 每个 Pool 的在线节点数
   - 每个 Pool 的 Ready 节点数

2. **节点指标**：
   - 节点所属的 Pool 数量
   - 节点的当前任务数
   - 节点的资源使用率（CPU/GPU/内存）

3. **任务指标**：
   - 任务分配成功率
   - 任务处理延迟
   - 节点负载分布

### 7.2 告警建议

1. **Pool 告警**：
   - Pool 节点数为 0（空 Pool）
   - Pool Ready 节点数 < 阈值

2. **节点告警**：
   - 节点 `current_jobs >= max_concurrent_jobs`
   - 节点资源使用率 > 阈值
   - 节点所属 Pool 数量异常

3. **任务告警**：
   - 任务分配失败率 > 阈值
   - 任务处理延迟 > 阈值

---

## 八、总结与建议

### 8.1 设计总结

**当前设计**：一个节点可以同时属于多个 Pool，支持多个语言对。

**核心优势**：
- ✅ 资源利用率最大化
- ✅ 避免空 Pool
- ✅ 充分利用节点能力
- ✅ 负载均衡确保任务分散

**风险控制**：
- ✅ `max_concurrent_jobs` 限制节点并发任务数
- ✅ 资源阈值检查防止节点过载
- ✅ 负载均衡算法分散任务
- ✅ 任务路由分散减少冲突

### 8.2 建议

1. **监控节点负载**
   - 监控节点的 `current_jobs` 和资源使用率
   - 如果节点经常达到 `max_concurrent_jobs`，考虑增加节点或调整限制

2. **调整并发限制**
   - 根据实际运行情况调整 `max_concurrent_jobs`
   - 考虑节点硬件配置（GPU 内存、CPU 核心数）

3. **优化资源阈值**
   - 根据实际运行情况调整资源阈值
   - 考虑不同任务类型的资源需求

4. **定期审查 Pool 配置**
   - 检查是否有空 Pool（所有节点都不支持）
   - 检查节点分配是否合理

### 8.3 决策建议

**推荐采用当前设计**（一个节点属于多个 Pool），原因：

1. **资源利用率显著提高**
   - 避免空 Pool，减少资源浪费
   - 充分利用节点能力

2. **风险可控**
   - 通过并发限制和资源检查控制风险
   - 负载均衡确保任务分散

3. **实际影响有限**
   - 节点通常支持多个语言对，这是正常情况
   - 多个语言对任务分配给同一个节点是合理的资源利用

4. **可监控和调整**
   - 通过监控指标可以及时发现和解决问题
   - 可以根据实际运行情况调整参数

---

## 附录

### A. 相关文档

- `POOL_ARCHITECTURE.md` - Pool 架构详细设计
- `NODE_REGISTRATION_AND_POOL_GENERATION.md` - 节点注册与 Pool 生成流程
- `POOL_MECHANISM_AND_MULTI_INSTANCE_COMPATIBILITY.md` - Pool 机制与多实例兼容性

### B. 配置参数

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `min_nodes_per_pool` | 1 | 创建 Pool 的最小节点数 |
| `max_pools` | 50 | 最大精确池数量 |
| `max_concurrent_jobs` | 4 | 节点最大并发任务数 |
| `cpu_threshold` | 90% | CPU 使用率阈值 |
| `gpu_threshold` | 90% | GPU 使用率阈值 |
| `memory_threshold` | 90% | 内存使用率阈值 |

### C. 代码位置

- Pool 分配逻辑：`central_server/scheduler/src/node_registry/phase3_pool_allocation.rs`
- 任务调度逻辑：`central_server/scheduler/src/node_registry/selection/selection_phase3.rs`
- Pool 管理：`central_server/scheduler/src/node_registry/phase3_pool.rs`
- 节点注册：`central_server/scheduler/src/node_registry/core.rs`

---

**文档结束**
