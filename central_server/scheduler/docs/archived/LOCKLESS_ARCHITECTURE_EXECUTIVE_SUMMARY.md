# 基于 Redis 的无锁架构设计方案 - 执行摘要

## 1. 问题与动机

### 当前问题
- ❌ **锁竞争严重**：心跳更新和节点选择同时竞争锁，导致阻塞
- ❌ **性能瓶颈**：节点选择延迟 50-200ms，心跳更新延迟 10-50ms
- ❌ **不可扩展**：无法水平扩展（多实例部署受限）
- ❌ **阻塞累积**：多个心跳同时触发时，阻塞时间累加（N × 50ms）

### 业务影响
- 任务分配延迟高，影响用户体验
- 系统负载增加时性能急剧下降
- 无法通过增加实例数量提升处理能力

---

## 2. 解决方案概述

### 核心思想
**将共享状态存储到 Redis，每个调度器实例维护本地缓存，使用版本号和发布/订阅机制实现缓存失效和一致性保证。**

### 关键特性
- ✅ **完全无锁**：读取操作直接从本地缓存读取（延迟 < 1ms）
- ✅ **高性能**：节点选择延迟降低 10-20 倍（1-10ms vs 50-200ms）
- ✅ **可扩展**：支持多实例水平扩展，自动同步状态
- ✅ **一致性保证**：使用 Redis 原子操作和版本号机制保证最终一致性

---

## 3. 架构对比

### 当前架构（有锁）

```
任务分配路径：
  └─> 获取快照读锁（可能被写锁阻塞 50-500ms）
      └─> 节点选择
          └─> 返回结果

心跳更新路径：
  └─> 获取管理锁写锁
      └─> 更新节点状态
  └─> 获取快照写锁（阻塞所有读操作）
      └─> 克隆整个 HashMap（50ms）
          └─> 更新快照
```

### 无锁架构

```
任务分配路径：
  └─> 从本地缓存读取（无锁，< 1ms）
      └─> 检查版本号（异步，不阻塞）
      └─> 节点选择
          └─> 返回结果

心跳更新路径：
  └─> 写入 Redis（原子操作，1-5ms）
      └─> 发布更新事件（通知其他实例）
      └─> 异步更新本地缓存
```

---

## 4. 关键业务流程

### 4.1 任务分配流程（无锁版本）

#### 步骤 1: 创建任务
- **方法**: `JobDispatcher::create_job()`
- **操作**: 无锁，创建任务 ID

#### 步骤 2: 决定 preferred_pool
- **方法**: `SessionRuntimeManager::decide_pool_for_session()`
- **操作**: Session 锁内决定（Session 级锁定，不影响其他任务）

#### 步骤 3: 节点选择
- **方法**: `LocklessCache::get_node()` → `LocklessCache::select_nodes_for_pool()`
- **操作**:
  1. 从本地缓存读取节点数据（无锁，DashMap）
  2. 异步检查版本号（非阻塞，超时 50ms 则假设缓存有效）
  3. 如果版本号匹配，直接返回（常见情况）
  4. 如果版本号不匹配，从 Redis 刷新（罕见情况）

#### 步骤 4: Redis 预留节点槽位
- **方法**: `Phase2Runtime::reserve_node_slot()`
- **操作**: Redis Lua 脚本保证原子性（已有实现，无需修改）

#### 步骤 5: 创建 Job 对象
- **方法**: `JobDispatcher::create_job()`（后续步骤）
- **操作**: 无锁，创建内存对象

**总延迟**: 1-10ms（vs 当前 50-200ms）

### 4.2 心跳更新流程（无锁版本）

#### 步骤 1: 接收心跳
- **方法**: `WebSocketHandler::handle_node_heartbeat()`
- **操作**: 无锁，接收消息

#### 步骤 2: 更新 Redis
- **方法**: `LocklessCache::update_node_heartbeat()`
- **操作**:
  1. Redis Lua 脚本原子更新（版本号自增 + 写入数据）
  2. 更新节点索引（在线节点集合）
  3. 设置 TTL（30 秒，心跳超时自动过期）

#### 步骤 3: 发布更新事件
- **方法**: `LocklessCache::publish_update_event()`
- **操作**: Redis PUBLISH 通知其他实例

#### 步骤 4: 更新本地缓存（异步）
- **方法**: `LocklessCache::refresh_node_from_redis()`（后台任务）
- **操作**: 异步刷新，不阻塞心跳响应

**总延迟**: 1-5ms（vs 当前 10-50ms）

### 4.3 节点注册流程（无锁版本）

#### 步骤 1: 接收注册请求
- **方法**: `WebSocketHandler::handle_node_register()`
- **操作**: 无锁

#### 步骤 2: 写入 Redis
- **方法**: `LocklessCache::register_node()`
- **操作**:
  1. Redis Lua 脚本原子写入（检查节点是否存在 + 写入数据 + 更新索引）
  2. 更新 Pool 成员索引
  3. 添加到在线节点索引

#### 步骤 3: 发布注册事件
- **方法**: `LocklessCache::publish_update_event()`
- **操作**: 通知其他实例

#### 步骤 4: 更新本地缓存
- **方法**: `LocklessCache::refresh_node_from_redis()`
- **操作**: 同步刷新（注册操作较少，可以同步）

**总延迟**: 2-10ms（vs 当前 20-100ms）

---

## 5. 技术实现要点

### 5.1 Redis 数据结构

| 用途 | Key 格式 | 数据类型 | 说明 |
|------|---------|---------|------|
| 节点状态 | `scheduler:nodes:{node_id}` | Hash | 包含所有节点信息 + 版本号 |
| 节点索引 | `scheduler:nodes:index:online` | Set | 在线节点 ID 集合 |
| Pool 成员 | `scheduler:pool:{pool_id}:members` | Set | Pool 成员节点 ID 集合 |
| Phase3 配置 | `scheduler:config:phase3` | String (JSON) | Phase3 配置 + 版本号 |
| 语言索引 | `scheduler:index:lang_pair:{src}:{tgt}` | Set | 语言对 → Pool IDs |
| 版本号 | `scheduler:version:{entity_type}` | String | 全局版本号 |
| 更新事件 | `scheduler:events:node_update` | Pub/Sub | 发布/订阅通道 |

### 5.2 本地缓存结构

```rust
struct LocklessCache {
    // 节点缓存（DashMap 是无锁并发 HashMap）
    nodes: Arc<DashMap<String, CachedNodeSnapshot>>,
    
    // 配置缓存（RwLock，很少更新）
    phase3_config: Arc<RwLock<Option<CachedPhase3Config>>>,
    
    // 版本号跟踪
    cached_versions: Arc<RwLock<CacheVersions>>,
    
    // Redis 客户端
    redis_client: Arc<RedisClient>,
}
```

### 5.3 缓存失效策略

**混合策略**：
1. **写操作时**：更新 Redis + 发布事件（通知其他实例失效缓存）
2. **读操作时**：先检查本地缓存，如果存在则异步检查版本号，如果不匹配则从 Redis 刷新
3. **定期检查**：后台任务定期检查全局版本号，如果变化则批量刷新

---

## 6. 性能对比

| 指标 | 当前架构 | 无锁架构 | 提升 |
|------|---------|---------|------|
| **节点选择延迟（P50）** | 50-200ms | 1-10ms | **10-20x** |
| **节点选择延迟（P99）** | 200-500ms | 10-50ms | **10-20x** |
| **心跳更新延迟** | 10-50ms | 1-5ms | **5-10x** |
| **并发处理能力** | 受锁限制 | 无限制 | **∞** |
| **多实例扩展** | 不支持 | 支持 | ✅ |

---

## 7. 风险评估与缓解

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|---------|
| **Redis 故障** | 高 | 低 | 1. Redis 集群部署 2. 降级到原有架构 3. 本地缓存作为备份 |
| **网络延迟** | 中 | 中 | 1. 本地缓存减少 Redis 访问 2. 异步版本号检查 3. 超时降级策略 |
| **缓存不一致** | 低 | 中 | 1. 版本号机制 2. Pub/Sub 失效 3. 定期全量刷新 |
| **数据丢失** | 高 | 低 | 1. Redis 持久化 2. 定期备份 3. 双写策略（过渡期） |

---

## 8. 实施计划

### 阶段 1: 基础设施准备（2 周）
- Redis 集群部署和配置
- Redis 客户端封装实现
- 序列化/反序列化工具

### 阶段 2: 核心功能实现（4 周）
- LocklessCache 核心功能
- 版本号管理机制
- 发布/订阅失效机制

### 阶段 3: 适配层和迁移工具（2 周）
- 接口适配层（保证兼容性）
- 双写策略（过渡期）
- 数据同步工具

### 阶段 4: 测试和优化（3 周）
- 单元测试（覆盖率 > 80%）
- 集成测试
- 性能测试和优化
- 压力测试

### 阶段 5: 灰度发布（2 周）
- 单实例灰度
- 多实例灰度
- 监控和告警

### 阶段 6: 全量发布（1 周）
- 全量切换
- 原有架构下线
- 文档更新

**总时长**: 约 14 周（3.5 个月）

### 资源需求
- **开发人员**: 2-3 人
- **测试人员**: 1 人
- **运维支持**: 1 人
- **Redis 集群**: 3 节点（主从模式）

---

## 9. 投资回报分析

### 成本
- **开发成本**: 14 周 × 2.5 人 = 35 人周
- **基础设施成本**: Redis 集群（3 节点）≈ $500/月
- **运维成本**: Redis 监控和维护 ≈ 0.5 人月/年

### 收益
- **性能提升**: 节点选择延迟降低 10-20 倍
- **可扩展性**: 支持多实例水平扩展，减少单点故障风险
- **用户体验**: 任务分配更快，用户满意度提升
- **长期收益**: 为未来扩展奠定基础，技术债务减少

### ROI 评估
- **短期**（6 个月内）: 性能提升带来的用户体验改善
- **中期**（1 年内）: 可扩展性带来的业务增长支持
- **长期**（2 年内）: 技术架构升级带来的维护成本降低

---

## 10. 决策建议

### 推荐方案
**✅ 推荐采用无锁架构方案**

**理由**：
1. ✅ **性能提升显著**：节点选择延迟降低 10-20 倍
2. ✅ **可扩展性强**：支持多实例水平扩展
3. ✅ **技术风险可控**：有完善的降级和回滚方案
4. ✅ **长期收益大**：为未来扩展奠定基础

### 实施建议
1. **采用渐进式迁移**：通过适配层平滑迁移，减少代码改动
2. **重视测试和监控**：完善的测试和监控体系
3. **预留回滚窗口**：保留原有架构代码至少 3 个月，确保可以快速回滚

### 不推荐的情况
如果满足以下任一条件，**不推荐**采用：
1. ❌ Redis 基础设施不完善（无集群、无持久化）
2. ❌ 无法接受最终一致性（必须强一致性）
3. ❌ 团队缺乏 Redis 运维经验
4. ❌ 项目时间紧迫（< 3 个月）

---

## 11. 下一步行动

### 决策前
1. [ ] 技术评审会（确认技术可行性）
2. [ ] 风险评估会议（确认风险可控）
3. [ ] 资源分配确认（确认开发资源）

### 决策后
1. [ ] 成立项目组（开发 + 测试 + 运维）
2. [ ] 制定详细实施计划
3. [ ] 开始基础设施准备（Redis 集群部署）

---

## 附录：关键数据

### 当前架构性能数据
- 节点选择延迟（P50）: 50-200ms
- 节点选择延迟（P99）: 200-500ms
- 心跳更新延迟: 10-50ms
- 锁竞争频率: 每分钟 100-500 次
- 锁等待时间（P95）: 100-500ms

### 预期性能数据（无锁架构）
- 节点选择延迟（P50）: 1-10ms
- 节点选择延迟（P99）: 10-50ms
- 心跳更新延迟: 1-5ms
- Redis 读取延迟（P95）: 1-5ms
- 缓存命中率（预期）: > 95%

---

**文档版本**: v1.0  
**创建日期**: 2026-01-10  
**状态**: 待决策部门审批
