
# ASR 高可用与高体验推荐技术方案
## 单工人队列 + 有界背压 + 快速失败/重试（可选：进程隔离）

---

## 1. 文档目标

本方案用于在 **不显著增加性能与资源开销** 的前提下，
提升 ASR 服务的 **系统可用性、稳定性与用户体验**。

核心目标：
- 避免并发推理导致的原生层崩溃（Windows 0xC0000005 等）
- 保留单模型实例（避免显存/内存膨胀）
- 将“不可预测的锁等待”转化为“可控、可观测的排队与背压”
- 让用户获得明确、快速的反馈（Busy / Retry）

---

## 2. 当前问题总结（背景）

已知事实：
- ASR 推理（Faster Whisper / CUDA 路径）**非线程安全**
- 并发请求 + 全局锁 → 请求堆积、锁等待 3–7s
- 第 5 个左右并发请求开始触发访问违规崩溃
- 即使修复 Python 层问题，原生层仍可能在高压力下越界

结论：
> 使用线程并发去驱动“只能串行执行的 GPU 推理引擎”在工程上不可持续。

---

## 3. 推荐总体方案

### 3.1 架构总览

```
Client
  └─ HTTP / WebSocket Request
        ↓
[API Ingress]
  ├─ 限流 / 校验
  ├─ 有界队列（Backpressure）
  └─ Busy / Retry 响应
        ↓
[ASR Worker]
  ├─ 单工人（串行 transcribe）
  ├─ 独占模型实例
  └─ 可选：独立进程
        ↓
[Result]
```

---

## 4. 核心设计原则

1. **ASR 推理严格串行**
2. **排队显式化，不允许隐式锁等待**
3. **队列必须有上限**
4. **快速失败优于长时间阻塞**
5. **所有状态必须可观测（queue depth / wait time）**

---

## 5. 关键组件设计

### 5.1 单工人 ASR Worker

- 每个节点 / GPU：1 个 ASR worker
- worker 内部：
  - 初始化 1 个 ASR 模型实例
  - 顺序执行 `transcribe()`
- 禁止：
  - 多线程并发调用 `transcribe()`
  - 每请求创建模型实例

### 5.2 有界队列（Backpressure）

推荐参数（默认）：

| 参数 | 推荐值 |
|----|----|
| worker 数 | 1 |
| 队列最大长度 | 3 |
| 最大等待时间 | 8s |
| Busy 返回码 | 429 / 503 |
| Retry-After | 0.5–1.5s |

行为定义：
- 队列未满 → 入队
- 队列已满 → 立即返回 Busy
- 等待超时 → 返回 Timeout

### 5.3 用户体验设计

- **不 silent fail**
- 明确返回：
  - `429 Too Many Requests`
  - `503 Service Busy`
- 可选：
  - 同步阻塞（短音频）
  - 异步 `202 Accepted + job_id`

---

## 6. 进程隔离（强烈建议）

### 6.1 为什么需要

- 原生层崩溃（0xC0000005）无法通过 Python try/except 捕获
- 线程隔离不足以保证服务存活

### 6.2 实现方式

- 主进程：
  - 接入请求
  - 管理队列
- Worker 进程：
  - 独占 ASR 模型
  - 执行推理
- 崩溃后：
  - 主进程自动拉起新 worker

---

## 7. 指标与可观测性

必须记录：
- queue_depth
- avg_wait_ms / p95_wait_ms
- in_flight_tasks
- decode_fail_rate
- worker_restart_count

---

## 8. 验收标准（Definition of Done）

功能：
- 连续运行 ≥ 10 分钟无崩溃
- 高并发下不出现访问违规

性能：
- ASR 推理时间与单请求基线一致
- 忙时快速返回（<50ms）

体验：
- 用户始终获得明确状态
- 无“卡住但无反馈”情况

---

## 9. 不推荐方案（说明）

| 方案 | 原因 |
|----|----|
| 并发入口 + 全局锁 | 隐式排队、不可观测、易崩 |
| 每请求模型实例 | 内存/显存成本过高 |
| 提高并发数 | 放大原生层不稳定 |

---

## 10. 结论

> **单工人 + 有界队列 + 快速失败/重试**  
是当前在 **稳定性、成本与体验** 三者之间的最优平衡方案。

该方案不依赖“彻底修复底层库”，而是通过工程设计将风险收敛为可控行为。
