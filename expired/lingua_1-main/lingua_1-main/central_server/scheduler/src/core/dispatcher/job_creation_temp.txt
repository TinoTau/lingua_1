    pub async fn create_job(
        &self,
        session_id: String,
        utterance_index: u64,
        src_lang: String,
        tgt_lang: String,
        dialect: Option<String>,
        features: Option<FeatureFlags>,
        pipeline: PipelineConfig,
        audio_data: Vec<u8>,
        audio_format: String,
        sample_rate: u32,
        preferred_node_id: Option<String>,
        mode: Option<String>,
        lang_a: Option<String>,
        lang_b: Option<String>,
        auto_langs: Option<Vec<String>>,
        enable_streaming_asr: Option<bool>,
        partial_update_interval_ms: Option<u64>,
        trace_id: String,
        tenant_id: Option<String>,
        // Phase 1锛氫换鍔＄骇骞傜瓑 request_id锛堝缓璁皟鐢ㄦ柟浼犲叆绋冲畾鍊硷級
        request_id: Option<String>,
        target_session_ids: Option<Vec<String>>, // 鐩爣鎺ユ敹鑰?session_id 鍒楄〃锛堜細璁妯″紡浣跨敤锛?
        first_chunk_client_timestamp_ms: Option<i64>, // 绗竴涓煶棰戝潡鐨勫鎴风鍙戦€佹椂闂存埑
        padding_ms: Option<u64>, // EDGE-4: Padding 閰嶇疆锛堟绉掞級
        is_manual_cut: bool, // 鏄惁鐢辩敤鎴锋墜鍔ㄥ彂閫?
        is_pause_triggered: bool, // 鏄惁鐢?绉掗潤闊宠Е鍙?
        is_timeout_triggered: bool, // 鏄惁鐢?0绉掕秴鏃惰Е鍙?
    ) -> Job {
        let request_id = request_id.unwrap_or_else(|| format!("req-{}", Uuid::new_v4().to_string()[..12].to_uppercase()));
        let now_ms = chrono::Utc::now().timestamp_millis();
        // Phase 3锛歳outing_key 浼樺厛 tenant_id锛屽叾娆?session_id锛堜繚璇佸悓绉熸埛/鍚屼細璇濈ǔ瀹氳惤 pool锛涗笉褰卞搷 request_id 骞傜瓑锛?
        let routing_key = tenant_id
            .as_deref()
            .filter(|s| !s.trim().is_empty())
            .unwrap_or(session_id.as_str());

        // Phase 2锛氳法瀹炰緥骞傜瓑锛堜紭鍏堜娇鐢?Redis request_id bind锛?
        if let Some(rt) = self.phase2.clone() {
            // 鍏堝仛涓€娆℃棤閿佽鍙栵紙蹇€熻矾寰勶級
            if let Some(b) = rt.get_request_binding(&request_id).await {
                let job_id = b.job_id.clone();
                if let Some(job) = self.get_job(&job_id).await {
                    return job;
                }
                let assigned_node_id = b.node_id.clone();
                let job = Job {
                    job_id: job_id.clone(),
                    request_id: request_id.clone(),
                    dispatched_to_node: b.dispatched_to_node,
                    dispatched_at_ms: None,
                    failover_attempts: 0,
                    dispatch_attempt_id: if assigned_node_id.is_some() { 1 } else { 0 },
                    session_id: session_id.clone(),
                    utterance_index,
                    src_lang: src_lang.clone(),
                    tgt_lang: tgt_lang.clone(),
                    dialect: dialect.clone(),
                    features: features.clone(),
                    pipeline: pipeline.clone(),
                    audio_data: audio_data.clone(),
                    audio_format: audio_format.clone(),
                    sample_rate,
                    assigned_node_id: assigned_node_id.clone(),
                    status: if assigned_node_id.is_some() { JobStatus::Assigned } else { JobStatus::Pending },
                    created_at: chrono::Utc::now(),
                    trace_id: trace_id.clone(),
                    mode: mode.clone(),
                    lang_a: lang_a.clone(),
                    lang_b: lang_b.clone(),
                    auto_langs: auto_langs.clone(),
                    enable_streaming_asr,
                    partial_update_interval_ms,
                    target_session_ids: target_session_ids.clone(),
                    tenant_id: tenant_id.clone(),
                    first_chunk_client_timestamp_ms,
                    padding_ms: None, // EDGE-4: Padding 閰嶇疆锛堝湪 Phase2 骞傜瓑妫€鏌ユ椂锛宲adding_ms 灏氭湭纭畾锛?
                    is_manual_cut: false,
                    is_pause_triggered: false,
                    is_timeout_triggered: false,
                };
                self.jobs.write().await.insert(job_id, job.clone());
                return job;
            }

            // 鍔犻攣璺緞锛氶伩鍏嶅悓 request_id 骞跺彂鍒涘缓/鍗犵敤
            let lock_owner = format!("{}:{}", rt.instance_id, Uuid::new_v4().to_string());
            let deadline = tokio::time::Instant::now() + std::time::Duration::from_millis(1000);
            let mut locked = false;
            while tokio::time::Instant::now() < deadline {
                if rt.acquire_request_lock(&request_id, &lock_owner, 1500).await {
                    locked = true;
                    break;
                }
                tokio::time::sleep(std::time::Duration::from_millis(50)).await;
            }

            if locked {
                // lock 鍚庡鏌?
                if let Some(b) = rt.get_request_binding(&request_id).await {
                    rt.release_request_lock(&request_id, &lock_owner).await;
                    let job_id = b.job_id.clone();
                    if let Some(job) = self.get_job(&job_id).await {
                        return job;
                    }
                    let assigned_node_id = b.node_id.clone();
                    let job = Job {
                        job_id: job_id.clone(),
                        request_id: request_id.clone(),
                        dispatched_to_node: b.dispatched_to_node,
                        dispatched_at_ms: None,
                        failover_attempts: 0,
                        dispatch_attempt_id: if assigned_node_id.is_some() { 1 } else { 0 },
                        session_id: session_id.clone(),
                        utterance_index,
                        src_lang: src_lang.clone(),
                        tgt_lang: tgt_lang.clone(),
                        dialect: dialect.clone(),
                        features: features.clone(),
                        pipeline: pipeline.clone(),
                        audio_data: audio_data.clone(),
                        audio_format: audio_format.clone(),
                        sample_rate,
                        assigned_node_id: assigned_node_id.clone(),
                        status: if assigned_node_id.is_some() { JobStatus::Assigned } else { JobStatus::Pending },
                        created_at: chrono::Utc::now(),
                        trace_id: trace_id.clone(),
                        mode: mode.clone(),
                        lang_a: lang_a.clone(),
                        lang_b: lang_b.clone(),
                        auto_langs: auto_langs.clone(),
                        enable_streaming_asr,
                        partial_update_interval_ms,
                        target_session_ids: target_session_ids.clone(),
                    tenant_id: tenant_id.clone(),
                    first_chunk_client_timestamp_ms,
                    padding_ms: None, // EDGE-4: Padding 閰嶇疆锛堝湪 Phase2 骞傜瓑妫€鏌ユ椂锛宲adding_ms 灏氭湭纭畾锛?
                    is_manual_cut, // 浣跨敤浼犲叆鐨勫弬鏁?
                    is_pause_triggered, // 浣跨敤浼犲叆鐨勫弬鏁?
                    is_timeout_triggered, // 浣跨敤浼犲叆鐨勫弬鏁?
                    };
                    self.jobs.write().await.insert(job_id, job.clone());
                    return job;
                }

                // 杩樻病鏈夌粦瀹氾細鍒涘缓鏂?job_id锛屽苟璧扳€滄湰鍦伴€夎妭鐐?-> Redis reserve -> 鍐?bind鈥?
                let job_id = format!("job-{}", Uuid::new_v4().to_string()[..8].to_uppercase());

                // Prometheus锛氳嫢鏈€缁?NO_AVAILABLE_NODE锛屽垯璁板綍鈥滄寜鍘熷洜鎷嗗垎鈥濈殑涓€娆¤鏁?
                let mut no_available_node_metric: Option<(&'static str, &'static str)> = None;

                // Phase 1锛氬彲閫夆€滄墦鏁ｂ€濈瓥鐣?
                let exclude_node_id = if self.spread_enabled {
                    self.last_dispatched_node_by_session
                        .read()
                        .await
                        .get(&session_id)
                        .and_then(|(nid, ts)| {
                            if now_ms - *ts <= self.spread_window_ms {
                                Some(nid.clone())
                            } else {
                                None
                            }
                        })
                } else {
                    None
                };

                let mut assigned_node_id = if let Some(node_id) = preferred_node_id.clone() {
                    if self.node_registry.is_node_available(&node_id).await {
                        Some(node_id)
                    } else {
                        None
                    }
                } else {
                    let excluded = exclude_node_id.as_deref();
                    let first = self
                        .select_node_with_module_expansion_with_breakdown(
                            routing_key,
                            &src_lang,
                            &tgt_lang,
                            features.clone(),
                            &pipeline,
                            true,
                            excluded,
                        )
                        .await;
                    if first.selector == "phase3" {
                        if let Some(ref dbg) = first.phase3_debug {
                            if dbg.fallback_used || dbg.selected_pool.is_none() {
                                tracing::warn!(
                                    trace_id = %trace_id,
                                    request_id = %request_id,
                                    pool_count = dbg.pool_count,
                                    preferred_pool = dbg.preferred_pool,
                                    selected_pool = ?dbg.selected_pool,
                                    fallback_used = dbg.fallback_used,
                                    attempts = ?dbg.attempts,
                                    "Phase3 two-level scheduling used fallback or failed"
                                );
                            } else {
                                tracing::debug!(
                                    trace_id = %trace_id,
                                    request_id = %request_id,
                                    pool_count = dbg.pool_count,
                                    preferred_pool = dbg.preferred_pool,
                                    selected_pool = ?dbg.selected_pool,
                                    attempts = ?dbg.attempts,
                                    "Phase3 two-level scheduling decision"
                                );
                            }
                        }
                    }
                    if first.node_id.is_some() {
                        first.node_id
                    } else {
                        let second = self
                            .select_node_with_module_expansion_with_breakdown(
                                routing_key,
                                &src_lang,
                                &tgt_lang,
                                features.clone(),
                                &pipeline,
                                true,
                                None,
                            )
                            .await;
                        if second.selector == "phase3" {
                            if let Some(ref dbg) = second.phase3_debug {
                                tracing::warn!(
                                    trace_id = %trace_id,
                                    request_id = %request_id,
                                    pool_count = dbg.pool_count,
                                    preferred_pool = dbg.preferred_pool,
                                    selected_pool = ?dbg.selected_pool,
                                    fallback_used = dbg.fallback_used,
                                    attempts = ?dbg.attempts,
                                    "Phase3 two-level scheduling second attempt"
                                );
                            }
                        }
                        if second.node_id.is_none() {
                            no_available_node_metric =
                                Some((second.selector, second.breakdown.best_reason_label()));
                        }
                        second.node_id
                    }
                };

                // Phase 2锛氬叏灞€骞跺彂鍗犵敤锛圧edis reserve锛?
                if let Some(ref node_id) = assigned_node_id {
                    let ttl_s = self.reserved_ttl_seconds.max(1);
                    let node = self.node_registry.get_node_snapshot(node_id).await;
                    let (running_jobs, max_jobs) = node
                        .as_ref()
                        .map(|n| (n.current_jobs, n.max_concurrent_jobs))
                        .unwrap_or((0, 1));
                    let ok = rt
                        .reserve_node_slot(node_id, &job_id, ttl_s, running_jobs, max_jobs)
                        .await;
                    if !ok {
                        assigned_node_id = None;
                        no_available_node_metric = Some(("reserve", "reserve_denied"));
                    }
                }

                // 鍐欏叆 request_id bind锛堝嵆浣挎湭鍒嗛厤鍒拌妭鐐癸紝涔熷啓鍏ヤ互閬垮厤鐭椂闂撮噸澶嶅垱寤猴級
                rt.set_request_binding(
                    &request_id,
                    &job_id,
                    assigned_node_id.as_deref(),
                    self.lease_seconds.max(1),
                    false,
                )
                .await;

                // Phase 2锛氬垵濮嬪寲 Job FSM锛圕REATED锛?
                let fsm_ttl = std::cmp::max(self.lease_seconds, self.reserved_ttl_seconds).saturating_add(300);
                rt.job_fsm_init(&job_id, assigned_node_id.as_deref(), 1, fsm_ttl).await;
                rt.release_request_lock(&request_id, &lock_owner).await;

                if assigned_node_id.is_none() {
                    if let Some((selector, reason)) = no_available_node_metric {
                        crate::metrics::prometheus_metrics::on_no_available_node(selector, reason);
                    } else {
                        crate::metrics::prometheus_metrics::on_no_available_node("unknown", "unknown");
                    }
                }

                let job = Job {
                    job_id: job_id.clone(),
                    request_id: request_id.clone(),
                    dispatched_to_node: false,
                    dispatched_at_ms: None,
                    failover_attempts: 0,
                    dispatch_attempt_id: if assigned_node_id.is_some() { 1 } else { 0 },
                    session_id,
                    utterance_index,
                    src_lang,
                    tgt_lang,
                    dialect,
                    features,
                    pipeline,
                    audio_data,
                    audio_format,
                    sample_rate,
                    assigned_node_id: assigned_node_id.clone(),
                    status: if assigned_node_id.is_some() { JobStatus::Assigned } else { JobStatus::Pending },
                    created_at: chrono::Utc::now(),
                    trace_id: trace_id.clone(),
                    mode,
                    lang_a,
                    lang_b,
                    auto_langs,
                    enable_streaming_asr,
                    partial_update_interval_ms,
                    target_session_ids,
                    tenant_id: tenant_id.clone(),
                    first_chunk_client_timestamp_ms,
                    padding_ms,
                    is_manual_cut, // 浣跨敤浼犲叆鐨勫弬鏁?
                    is_pause_triggered, // 浣跨敤浼犲叆鐨勫弬鏁?
                    is_timeout_triggered, // 浣跨敤浼犲叆鐨勫弬鏁?
                };
                self.jobs.write().await.insert(job_id, job.clone());
                return job;
            }
        }

        // 骞傜瓑锛氳嫢 request_id 鍦?lease 鍐呭凡鐢熸垚杩?job锛屽垯鐩存帴杩斿洖鍚屼竴涓?job锛堥伩鍏嶉噸澶嶆淳鍙?閲嶅鍗犵敤骞跺彂妲斤級
        if let Some((existing_job_id, exp_ms)) = self.request_bindings.read().await.get(&request_id).cloned() {
            if exp_ms > now_ms {
                if let Some(job) = self.get_job(&existing_job_id).await {
                    return job;
                }
            }
        }

        let job_id = format!("job-{}", Uuid::new_v4().to_string()[..8].to_uppercase());
        
        // 鐢ㄤ簬 Prometheus锛氳嫢鏈€缁?NO_AVAILABLE_NODE锛屽垯璁板綍鈥滄寜鍘熷洜鎷嗗垎鈥濈殑涓€娆¤鏁?
        let mut no_available_node_metric: Option<(&'static str, &'static str)> = None;

        // Phase 1锛氬彲閫夆€滄墦鏁ｂ€濈瓥鐣ャ€傝嫢寮€鍚笖绐楀彛鍐呭瓨鍦ㄤ笂涓€娆″凡娲惧彂鑺傜偣锛屽垯浼樺厛閬垮紑锛堣嫢鏃犲叾浠栧€欓€夊垯鍥為€€锛?
        let exclude_node_id = if self.spread_enabled {
            self.last_dispatched_node_by_session
                .read()
                .await
                .get(&session_id)
                .and_then(|(nid, ts)| {
                    if now_ms - *ts <= self.spread_window_ms {
                        Some(nid.clone())
                    } else {
                        None
                    }
                })
        } else {
            None
        };

        // 鏍规嵁 v2 鎶€鏈鏄庝功锛屼娇鐢ㄦā鍧椾緷璧栧睍寮€绠楁硶閫夋嫨鑺傜偣
        let mut assigned_node_id = if let Some(node_id) = preferred_node_id {
            // 濡傛灉鎸囧畾浜嗚妭鐐癸紝妫€鏌ヨ妭鐐规槸鍚﹀彲鐢?
            if self.node_registry.is_node_available(&node_id).await {
                // 杩橀渶瑕佹鏌ヨ妭鐐规槸鍚﹀叿澶囨墍闇€鐨勬ā鍨嬭兘鍔?
                if let Some(features) = &features {
                        if let Ok(required_models) =
                            self.get_required_types_for_features(&pipeline, Some(features), &src_lang, &tgt_lang)
                        {
                        if !self.node_registry.check_node_has_types_ready(&node_id, &required_models).await {
                            // 鑺傜偣涓嶅叿澶囨墍闇€妯″瀷锛屽洖閫€鍒板姛鑳芥劅鐭ラ€夋嫨
                            let o = self
                                .select_node_with_module_expansion_with_breakdown(
                                    routing_key,
                                    &src_lang,
                                    &tgt_lang,
                                    Some(features.clone()),
                                    &pipeline,
                                    true,
                                    None,
                                )
                                .await;
                            if o.selector == "phase3" {
                                if let Some(ref dbg) = o.phase3_debug {
                                    tracing::debug!(
                                        trace_id = %trace_id,
                                        request_id = %request_id,
                                        pool_count = dbg.pool_count,
                                        preferred_pool = dbg.preferred_pool,
                                        selected_pool = ?dbg.selected_pool,
                                        fallback_used = dbg.fallback_used,
                                        attempts = ?dbg.attempts,
                                        "Phase3 two-level scheduling fallback from preferred node"
                                    );
                                }
                            }
                            if o.node_id.is_none() {
                                no_available_node_metric =
                                    Some((o.selector, o.breakdown.best_reason_label()));
                            }
                            o.node_id
                        } else {
                            Some(node_id)
                        }
                    } else {
                        Some(node_id)
                    }
                } else {
                    Some(node_id)
                }
            } else {
                // 鍥為€€鍒板姛鑳芥劅鐭ラ€夋嫨
                let o = self
                    .select_node_with_module_expansion_with_breakdown(
                        routing_key,
                        &src_lang,
                        &tgt_lang,
                        features.clone(),
                        &pipeline,
                        true,
                        None,
                    )
                    .await;
                if o.selector == "phase3" {
                    if let Some(ref dbg) = o.phase3_debug {
                        tracing::debug!(
                            trace_id = %trace_id,
                            request_id = %request_id,
                            pool_count = dbg.pool_count,
                            preferred_pool = dbg.preferred_pool,
                            selected_pool = ?dbg.selected_pool,
                            fallback_used = dbg.fallback_used,
                            attempts = ?dbg.attempts,
                            "Phase3 two-level scheduling fallback from unavailable preferred node"
                        );
                    }
                }
                if o.node_id.is_none() {
                    no_available_node_metric = Some((o.selector, o.breakdown.best_reason_label()));
                }
                o.node_id
            }
        } else {
            // 浣跨敤妯″潡渚濊禆灞曞紑绠楁硶閫夋嫨鑺傜偣
            // 鍏堝皾璇曢伩寮€涓婁竴鑺傜偣锛涘鏋滄棤鍊欓€夊啀鍥為€€涓嶉伩寮€
            let excluded = exclude_node_id.as_deref();
            let first = self
                .select_node_with_module_expansion_with_breakdown(
                    routing_key,
                    &src_lang,
                    &tgt_lang,
                    features.clone(),
                    &pipeline,
                    true,
                    excluded,
                )
                .await;
            if first.selector == "phase3" {
                if let Some(ref dbg) = first.phase3_debug {
                    if dbg.fallback_used || dbg.selected_pool.is_none() {
                        tracing::warn!(
                            trace_id = %trace_id,
                            request_id = %request_id,
                                pool_count = dbg.pool_count,
                            preferred_pool = dbg.preferred_pool,
                            selected_pool = ?dbg.selected_pool,
                            fallback_used = dbg.fallback_used,
                            attempts = ?dbg.attempts,
                            "Phase3 two-level scheduling used fallback or failed"
                        );
                    }
                }
            }
            if first.node_id.is_some() {
                first.node_id
            } else {
                let second = self
                    .select_node_with_module_expansion_with_breakdown(
                        routing_key,
                        &src_lang,
                        &tgt_lang,
                        features.clone(),
                        &pipeline,
                        true,
                        None,
                    )
                    .await;
                if second.selector == "phase3" {
                    if let Some(ref dbg) = second.phase3_debug {
                        tracing::warn!(
                            trace_id = %trace_id,
                            request_id = %request_id,
                            pool_count = dbg.pool_count,
                            preferred_pool = dbg.preferred_pool,
                            selected_pool = ?dbg.selected_pool,
                            fallback_used = dbg.fallback_used,
                            attempts = ?dbg.attempts,
                            "Phase3 two-level scheduling second attempt"
                        );
                    }
                }
                if second.node_id.is_none() {
                    // 浠呰褰曟渶缁堝け璐ョ殑鍘熷洜锛堢浜屾锛氫笉閬垮紑涓婁竴鑺傜偣锛?
                    no_available_node_metric =
                        Some((second.selector, second.breakdown.best_reason_label()));
                }
                second.node_id
            }
        };

        // Phase 1锛氬苟鍙戜竴鑷存€э紙reserve锛夆€斺€旂粦瀹氭垚鍔?鈮?鍗犵敤 1 涓Ы
        if let Some(ref node_id) = assigned_node_id {
            let ttl = std::time::Duration::from_secs(self.reserved_ttl_seconds);
            let reserved = self
                .node_registry
                .reserve_job_slot(node_id, &job_id, ttl)
                .await;
            if !reserved {
                assigned_node_id = None;
                // 閫夋嫨鍒颁簡鑺傜偣浣?reserve 澶辫触锛氬鏁版槸骞跺彂妲界珵浜?蹇冭烦婊炲悗瀵艰嚧
                no_available_node_metric = Some(("reserve", "reserve_denied"));
            }
        }

        // 鍐欏叆 request_id lease锛堝彧鍦ㄦ垚鍔熷垱寤烘椂鍐欏叆锛涙棤璁烘槸鍚﹀垎閰嶅埌鑺傜偣锛岄兘鍐欏叆浠ラ伩鍏嶇煭鏃堕棿閲嶅鍒涘缓锛?
        let lease_ms = (self.lease_seconds as i64) * 1000;
        let exp_ms = now_ms + lease_ms;
        self.request_bindings
            .write()
            .await
            .insert(request_id.clone(), (job_id.clone(), exp_ms));

        use tracing::debug;
        debug!(trace_id = %trace_id, job_id = %job_id, request_id = %request_id, session_id = %session_id, utterance_index = utterance_index, node_id = ?assigned_node_id, "鍒涘缓 Job");

        if assigned_node_id.is_none() {
            if let Some((selector, reason)) = no_available_node_metric {
                crate::metrics::prometheus_metrics::on_no_available_node(selector, reason);
                // 娣诲姞璇︾粏鐨勮瘖鏂棩蹇?
                warn!(
                    trace_id = %trace_id,
                    job_id = %job_id,
                    session_id = %session_id,
                    utterance_index = utterance_index,
                    selector = selector,
                    reason = reason,
                    "Job鍒涘缓鏃舵湭鎵惧埌鍙敤鑺傜偣锛岃妫€鏌ヨ妭鐐圭姸鎬佸拰鏈嶅姟鍖呭畨瑁呮儏鍐?
                );
            } else {
                crate::metrics::prometheus_metrics::on_no_available_node("unknown", "unknown");
                warn!(
                    trace_id = %trace_id,
                    job_id = %job_id,
                    session_id = %session_id,
                    utterance_index = utterance_index,
                    "Job鍒涘缓鏃舵湭鎵惧埌鍙敤鑺傜偣锛堝師鍥犳湭鐭ワ級"
                );
            }
        }

        let job = Job {
            job_id: job_id.clone(),
            request_id: request_id.clone(),
            dispatched_to_node: false,
            dispatched_at_ms: None,
            failover_attempts: 0,
            dispatch_attempt_id: if assigned_node_id.is_some() { 1 } else { 0 },
            session_id,
            utterance_index,
            src_lang,
            tgt_lang,
            dialect,
            features,
            pipeline,
            audio_data,
            audio_format,
            sample_rate,
            assigned_node_id: assigned_node_id.clone(),
            status: if assigned_node_id.is_some() {
                JobStatus::Assigned
            } else {
                JobStatus::Pending
            },
            created_at: chrono::Utc::now(),
            trace_id: trace_id.clone(),
            mode,
            lang_a,
            lang_b,
            auto_langs,
            enable_streaming_asr,
            partial_update_interval_ms,
            target_session_ids,
            tenant_id: tenant_id.clone(),
            first_chunk_client_timestamp_ms,
            padding_ms,
            is_manual_cut,
            is_pause_triggered,
            is_timeout_triggered,
        };

        let mut jobs = self.jobs.write().await;
        jobs.insert(job_id, job.clone());
        job
    }
